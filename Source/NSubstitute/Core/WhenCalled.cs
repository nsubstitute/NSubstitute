using System;
using System.Collections.Generic;
using NSubstitute.Routing;

namespace NSubstitute.Core
{
    public class WhenCalled<T>
    {
        private readonly T _substitute;
        private readonly Action<T> _call;
        private readonly MatchArgs _matchArgs;
        private readonly ICallRouter _callRouter;
        private readonly IRouteFactory _routeFactory;

        public WhenCalled(ISubstitutionContext context, T substitute, Action<T> call, MatchArgs matchArgs)
        {
            _substitute = substitute;
            _call = call;
            _matchArgs = matchArgs;
            _callRouter = context.GetCallRouterFor(substitute);
            _routeFactory = context.GetRouteFactory();
        }

        /// <summary>
        /// Perform this action when called.
        /// </summary>
        /// <param name="callbackWithArguments"></param>
        public void Do(Action<CallInfo> callbackWithArguments)
        {
            _callRouter.SetRoute(x => _routeFactory.DoWhenCalled(x, callbackWithArguments, _matchArgs));
            _call(_substitute);
        }

        /// <summary>
        /// Perform this actions when consecutively called.
        /// </summary>
        /// <param name="callbacksWithArguments"></param>
        /// <remarks>If number of calls is greater then number of actions, the last action will be repeated for every next call.</remarks>
        public void Do(params Action<CallInfo>[] callbacksWithArguments)
        {
            var cc = new ConsecutiveCall(callbacksWithArguments);
            Do(cc.Call);
        }

        private class ConsecutiveCall
        {
            private readonly Stack<Action<CallInfo>> actions;

            public ConsecutiveCall(params Action<CallInfo>[] actions)
            {
                this.actions = new Stack<Action<CallInfo>>();
                for (int i = actions.Length; i > 0; i--)
                    this.actions.Push(actions[i - 1]);
            }

            public void Call(CallInfo ci)
            {
                var action = actions.Count > 1
                    ? actions.Pop()
                    : actions.Peek();
                action.Invoke(ci);
            }
        }

        /// <summary>
        /// Do not call the base implementation on future calls. For use with partial substitutes.
        /// </summary>
        public void DoNotCallBase()
        {
            _callRouter.SetRoute(x => _routeFactory.DoNotCallBase(x, _matchArgs));
            _call(_substitute);
        }

        /// <summary>
        /// Throw the specified exception when called.
        /// </summary>
        public void Throw(Exception exception)
        {
            Do(ci => { throw exception; });
        }

        /// <summary>
        /// Throw an exception of the given type when called.
        /// </summary>
        public TException Throw<TException>() where TException : Exception, new()
        {
            var exception = new TException();
            Do(ci =>
            {
                throw exception;
            });
            return exception;
        }

        /// <summary>
        /// Throw an exception generated by the specified function when called.
        /// </summary>
        public void Throw(Func<CallInfo, Exception> createException)
        {
            Do(ci => { throw createException(ci); });
        }
    }
}