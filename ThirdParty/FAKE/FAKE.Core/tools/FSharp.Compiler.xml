<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>FSharp.Compiler</name></assembly>
<members>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSComp.SR.valueIsNotAccessible(System.String)">
<summary>
 The value &apos;%s&apos; is not accessible from this code location
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:964)
</summary>
</member>
<member name="M:FSComp.SR.unionCasesAreNotAccessible(System.String)">
<summary>
 The union cases or fields of the type &apos;%s&apos; are not accessible from this code location
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:963)
</summary>
</member>
<member name="M:FSComp.SR.unionCaseIsNotAccessible(System.String)">
<summary>
 The union case &apos;%s&apos; is not accessible from this code location
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:965)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameValueOfConstructor(System.String)">
<summary>
 The value or constructor &apos;%s&apos; is not defined
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:6)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameValueNamespaceTypeOrModule(System.String)">
<summary>
 The value, namespace, type or module &apos;%s&apos; is not defined
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:7)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameValueConstructorNamespaceOrType(System.String)">
<summary>
 The value, constructor, namespace or type &apos;%s&apos; is not defined
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:5)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameTypeParameter(System.String)">
<summary>
 The type parameter &apos;%s&apos; is not defined
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:12)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameType(System.String)">
<summary>
 The type &apos;%s&apos; is not defined
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:9)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameRecordLabelOrNamespace(System.String)">
<summary>
 The record label or namespace &apos;%s&apos; is not defined
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:10)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameRecordLabel(System.String)">
<summary>
 The record label &apos;%s&apos; is not defined
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:11)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNamePatternDiscriminator(System.String)">
<summary>
 The pattern discriminator &apos;%s&apos; is not defined
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:13)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameNamespaceOrModule(System.String)">
<summary>
 The namespace or module &apos;%s&apos; is not defined
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:3)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameNamespace(System.String)">
<summary>
 The namespace &apos;%s&apos; is not defined
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:2)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameFieldConstructorOrMember(System.String)">
<summary>
 The field, constructor or member &apos;%s&apos; is not defined
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:4)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameConstructorModuleOrNamespace(System.String)">
<summary>
 The constructor, module or namespace &apos;%s&apos; is not defined
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:8)
</summary>
</member>
<member name="M:FSComp.SR.typrelTypeImplementsIComparableShouldOverrideObjectEquals(System.String)">
<summary>
 The type &apos;%s&apos; implements &apos;System.IComparable&apos;. Consider also adding an explicit override for &apos;Object.Equals&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:173)
</summary>
</member>
<member name="M:FSComp.SR.typrelTypeImplementsIComparableDefaultObjectEqualsProvided(System.String)">
<summary>
 The type &apos;%s&apos; implements &apos;System.IComparable&apos; explicitly but provides no corresponding override for &apos;Object.Equals&apos;. An implementation of &apos;Object.Equals&apos; has been automatically provided, implemented via &apos;System.IComparable&apos;. Consider implementing the override &apos;Object.Equals&apos; explicitly
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:174)
</summary>
</member>
<member name="M:FSComp.SR.typrelSigImplNotCompatibleParamCountsDiffer">
<summary>
 The signature and implementation are not compatible because the respective type parameter counts differ
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:169)
</summary>
</member>
<member name="M:FSComp.SR.typrelSigImplNotCompatibleConstraintsDifferRemove(System.String,System.String)">
<summary>
 The signature and implementation are not compatible because the type parameter &apos;%s&apos; has a constraint of the form %s but the implementation does not. Either remove this constraint from the signature or add it to the implementation.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:172)
</summary>
</member>
<member name="M:FSComp.SR.typrelSigImplNotCompatibleConstraintsDiffer(System.String,System.String)">
<summary>
 The signature and implementation are not compatible because the declaration of the type parameter &apos;%s&apos; requires a constraint of the form %s
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:171)
</summary>
</member>
<member name="M:FSComp.SR.typrelSigImplNotCompatibleCompileTimeRequirementsDiffer">
<summary>
 The signature and implementation are not compatible because the type parameter in the class/signature has a different compile-time requirement to the one in the member/implementation
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:170)
</summary>
</member>
<member name="M:FSComp.SR.typrelOverrideWasAmbiguous(System.String)">
<summary>
 The override for &apos;%s&apos; was ambiguous
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:189)
</summary>
</member>
<member name="M:FSComp.SR.typrelOverrideImplementsMoreThenOneSlot(System.String,System.String,System.String)">
<summary>
 The override &apos;%s&apos; implements more than one abstract slot, e.g. &apos;%s&apos; and &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:192)
</summary>
</member>
<member name="M:FSComp.SR.typrelOverloadNotFound(System.String,System.String)">
<summary>
 No implementations of &apos;%s&apos; had the correct number of arguments and type parameters. The required signature is &apos;%s&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:188)
</summary>
</member>
<member name="M:FSComp.SR.typrelNoImplementationGivenWithSuggestion(System.String)">
<summary>
 No implementation was given for &apos;%s&apos;. Note that all interface members must be implemented and listed under an appropriate &apos;interface&apos; declaration, e.g. &apos;interface ... with member ...&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:197)
</summary>
</member>
<member name="M:FSComp.SR.typrelNoImplementationGiven(System.String)">
<summary>
 No implementation was given for &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:196)
</summary>
</member>
<member name="M:FSComp.SR.typrelNeedExplicitImplementation(System.String)">
<summary>
 The interface &apos;%s&apos; is included in multiple explicitly implemented interface types. Add an explicit implementation of this interface.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:194)
</summary>
</member>
<member name="M:FSComp.SR.typrelNamedArgumentHasBeenAssignedMoreThenOnce">
<summary>
 A named argument has been assigned more than one value
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:195)
</summary>
</member>
<member name="M:FSComp.SR.typrelMoreThenOneOverride(System.String)">
<summary>
 More than one override implements &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:190)
</summary>
</member>
<member name="M:FSComp.SR.typrelModuleNamespaceAttributesDifferInSigAndImpl">
<summary>
 The namespace or module attributes differ between signature and implementation
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:186)
</summary>
</member>
<member name="M:FSComp.SR.typrelMethodIsSealed(System.String)">
<summary>
 The method &apos;%s&apos; is sealed and cannot be overridden
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:191)
</summary>
</member>
<member name="M:FSComp.SR.typrelMethodIsOverconstrained">
<summary>
 This method is over-constrained in its type parameters
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:187)
</summary>
</member>
<member name="M:FSComp.SR.typrelMemberDoesNotHaveCorrectNumberOfTypeParameters(System.String,System.String)">
<summary>
 The member &apos;%s&apos; does not have the correct number of method type parameters. The required signature is &apos;%s&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:199)
</summary>
</member>
<member name="M:FSComp.SR.typrelMemberDoesNotHaveCorrectNumberOfArguments(System.String,System.String)">
<summary>
 The member &apos;%s&apos; does not have the correct number of arguments. The required signature is &apos;%s&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:198)
</summary>
</member>
<member name="M:FSComp.SR.typrelMemberDoesNotHaveCorrectKindsOfGenericParameters(System.String,System.String)">
<summary>
 The member &apos;%s&apos; does not have the correct kinds of generic parameters. The required signature is &apos;%s&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:200)
</summary>
</member>
<member name="M:FSComp.SR.typrelMemberCannotImplement(System.String,System.String,System.String)">
<summary>
 The member &apos;%s&apos; cannot be used to implement &apos;%s&apos;. The required signature is &apos;%s&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:201)
</summary>
</member>
<member name="M:FSComp.SR.typrelInvalidValue">
<summary>
 Invalid value
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:168)
</summary>
</member>
<member name="M:FSComp.SR.typrelExplicitImplementationOfGetHashCodeOrEquals(System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; has an explicit implementation of &apos;Object.GetHashCode&apos; or &apos;Object.Equals&apos;. You must apply the &apos;CustomEquality&apos; attribute to the type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:175)
</summary>
</member>
<member name="M:FSComp.SR.typrelExplicitImplementationOfGetHashCode(System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; has an explicit implementation of &apos;Object.GetHashCode&apos;. Consider implementing a matching override for &apos;Object.Equals(obj)&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:176)
</summary>
</member>
<member name="M:FSComp.SR.typrelExplicitImplementationOfEquals(System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; has an explicit implementation of &apos;Object.Equals&apos;. Consider implementing a matching override for &apos;Object.GetHashCode()&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:177)
</summary>
</member>
<member name="M:FSComp.SR.typrelDuplicateInterface">
<summary>
 Duplicate or redundant interface
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:193)
</summary>
</member>
<member name="M:FSComp.SR.typrelCannotResolveImplicitGenericInstantiation(System.String,System.String)">
<summary>
 The implicit instantiation of a generic construct at or near this point could not be resolved because it could resolve to multiple unrelated types, e.g. &apos;%s&apos; and &apos;%s&apos;. Consider using type annotations to resolve the ambiguity
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:163)
</summary>
</member>
<member name="M:FSComp.SR.typrelCannotResolveAmbiguityInUnmanaged">
<summary>
 Could not resolve the ambiguity in the use of a generic construct with an &apos;unmanaged&apos; constraint at or near this position
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1099)
</summary>
</member>
<member name="M:FSComp.SR.typrelCannotResolveAmbiguityInPrintf">
<summary>
 Could not resolve the ambiguity inherent in the use of a &apos;printf&apos;-style format string
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:165)
</summary>
</member>
<member name="M:FSComp.SR.typrelCannotResolveAmbiguityInOverloadedOperator(System.String)">
<summary>
 Could not resolve the ambiguity inherent in the use of the operator &apos;%s&apos; at or near this program point. Consider using type annotations to resolve the ambiguity.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:164)
</summary>
</member>
<member name="M:FSComp.SR.typrelCannotResolveAmbiguityInEnum">
<summary>
 Could not resolve the ambiguity in the use of a generic construct with an &apos;enum&apos; constraint at or near this position
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:166)
</summary>
</member>
<member name="M:FSComp.SR.typrelCannotResolveAmbiguityInDelegate">
<summary>
 Could not resolve the ambiguity in the use of a generic construct with a &apos;delegate&apos; constraint at or near this position
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:167)
</summary>
</member>
<member name="M:FSComp.SR.typeIsNotAccessible(System.String)">
<summary>
 The type &apos;%s&apos; is not accessible from this code location
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:962)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoUnionCase">
<summary>
 union case
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:935)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoType">
<summary>
 type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:931)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoProperty">
<summary>
 property
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:940)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoPatternVariable">
<summary>
 patvar
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:944)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoOtherOverloads(System.Int32)">
<summary>
 and %d other overloads
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:934)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoNamespaceOrModule">
<summary>
 namespace/module
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:947)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoNamespace">
<summary>
 namespace
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:945)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoModule">
<summary>
 module
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:946)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoInherits">
<summary>
 inherits
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:932)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoImplements">
<summary>
 implements
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:933)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoGeneratedType">
<summary>
 generated type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:951)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoGeneratedProperty">
<summary>
 generated property
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:950)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoFullName">
<summary>
 Full name
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:930)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoFromNext(System.String)">
<summary>
 also from %s
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:949)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoFromFirst(System.String)">
<summary>
 from %s
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:948)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoField">
<summary>
 field
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:938)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoExtension">
<summary>
 extension
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:941)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoEvent">
<summary>
 event
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:939)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoCustomOperation">
<summary>
 custom operation
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:942)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoCallsWord">
<summary>
 Calls
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1272)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoArgument">
<summary>
 argument
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:943)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoActiveRecognizer">
<summary>
 active recognizer
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:937)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoActivePatternResult">
<summary>
 active pattern result
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:936)
</summary>
</member>
<member name="M:FSComp.SR.tlrUnexpectedTExpr">
<summary>
 Unexpected Expr.TyChoose
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:975)
</summary>
</member>
<member name="M:FSComp.SR.tlrLambdaLiftingOptimizationsNotApplied">
<summary>
 Note: Lambda-lifting optimizations have not been applied because of the use of this local constrained generic function as a first class value. Adding type constraints may resolve this condition.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:976)
</summary>
</member>
<member name="M:FSComp.SR.tcVolatileOnlyOnClassLetBindings">
<summary>
 The &apos;VolatileField&apos; attribute may only be used on &apos;let&apos; bindings in classes
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:679)
</summary>
</member>
<member name="M:FSComp.SR.tcVolatileFieldsMustBeMutable">
<summary>
 Volatile fields must be marked &apos;mutable&apos; and cannot be thread-static
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:734)
</summary>
</member>
<member name="M:FSComp.SR.tcValueInSignatureRequiresLiteralAttribute">
<summary>
 A declaration may only be given a value in a signature if the declaration has the [&lt;Literal&gt;] attribute
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:732)
</summary>
</member>
<member name="M:FSComp.SR.tcUseYieldBangForMultipleResults">
<summary>
 In sequence expressions, multiple results are generated using &apos;yield!&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:654)
</summary>
</member>
<member name="M:FSComp.SR.tcUseWhenPatternGuard">
<summary>
 Character range matches have been removed in F#. Consider using a &apos;when&apos; pattern guard instead.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:588)
</summary>
</member>
<member name="M:FSComp.SR.tcUseMayNotBeUsedInQueries">
<summary>
 &apos;use&apos; expressions may not be used in queries
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1290)
</summary>
</member>
<member name="M:FSComp.SR.tcUseForInSequenceExpression">
<summary>
 The use of &apos;let! x = coll&apos; in sequence expressions is not permitted. Use &apos;for x in coll&apos; instead.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:652)
</summary>
</member>
<member name="M:FSComp.SR.tcUnsupportedAttribute">
<summary>
 This attribute cannot be used in this version of F#
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:706)
</summary>
</member>
<member name="M:FSComp.SR.tcUnrecognizedQueryOperator">
<summary>
 This is not a known query operator. Query operators are identifiers such as &apos;select&apos;, &apos;where&apos;, &apos;sortBy&apos;, &apos;thenBy&apos;, &apos;groupBy&apos;, &apos;groupValBy&apos;, &apos;join&apos;, &apos;groupJoin&apos;, &apos;sumBy&apos; and &apos;averageBy&apos;, defined using corresponding methods on the &apos;QueryBuilder&apos; type.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1293)
</summary>
</member>
<member name="M:FSComp.SR.tcUnrecognizedQueryBinaryOperator">
<summary>
 Arguments to query operators may require parentheses, e.g. &apos;where (x &gt; y)&apos; or &apos;groupBy (x.Length / 10)&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1301)
</summary>
</member>
<member name="M:FSComp.SR.tcUnrecognizedAttributeTarget">
<summary>
 Unrecognized attribute target. Valid attribute targets are &apos;assembly&apos;, &apos;module&apos;, &apos;type&apos;, &apos;method&apos;, &apos;property&apos;, &apos;return&apos;, &apos;param&apos;, &apos;field&apos;, &apos;event&apos;, &apos;constructor&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:696)
</summary>
</member>
<member name="M:FSComp.SR.tcUnnamedArgumentsDoNotFormPrefix">
<summary>
 The unnamed arguments do not form a prefix of the arguments of the method called
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:673)
</summary>
</member>
<member name="M:FSComp.SR.tcUnknownUnion">
<summary>
 Unknown union case
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:527)
</summary>
</member>
<member name="M:FSComp.SR.tcUnitsOfMeasureInvalidInTypeConstructor">
<summary>
 Unit-of-measure cannot be used in type constructor application
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:564)
</summary>
</member>
<member name="M:FSComp.SR.tcUnionCaseRequiresOneArgument">
<summary>
 This union case takes one argument
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:582)
</summary>
</member>
<member name="M:FSComp.SR.tcUnionCaseNameConflictsWithGeneratedType(System.String,System.String)">
<summary>
 The union case named &apos;%s&apos; conflicts with the generated type &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1120)
</summary>
</member>
<member name="M:FSComp.SR.tcUnionCaseFieldCannotBeUsedMoreThanOnce(System.String)">
<summary>
 Union case/exception field &apos;%s&apos; cannot be used more than once.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1327)
</summary>
</member>
<member name="M:FSComp.SR.tcUnionCaseExpectsTupledArguments(System.Int32)">
<summary>
 This union case expects %d arguments in tupled form
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:583)
</summary>
</member>
<member name="M:FSComp.SR.tcUnionCaseDoesNotTakeArguments">
<summary>
 This union case does not take arguments
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:581)
</summary>
</member>
<member name="M:FSComp.SR.tcUnionCaseConstructorDoesNotHaveFieldWithGivenName(System.String,System.String)">
<summary>
 Union case/exception &apos;%s&apos; does not have field named &apos;%s&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1326)
</summary>
</member>
<member name="M:FSComp.SR.tcUninitializedValFieldsMustBeMutable">
<summary>
 Uninitialized &apos;val&apos; fields must be mutable and marked with the &apos;[&lt;DefaultValue&gt;]&apos; attribute. Consider using a &apos;let&apos; binding instead of a &apos;val&apos; field.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:735)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedTypeArguments">
<summary>
 Unexpected type arguments
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:573)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedSymbolInTypeExpression(System.String)">
<summary>
 Unexpected %s in type expression
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:567)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedSlashInType">
<summary>
 Unexpected / in type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:572)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedPropertySpec">
<summary>
 Unexpected source-level property specification
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:538)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedPropertyInSyntaxTree">
<summary>
 Unexpected source-level property specification in syntax tree
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:532)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedMeasureAnon">
<summary>
 Unexpected SynMeasure.Anon
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:488)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedExprAtRecInfPoint">
<summary>
 Unexpected expression at recursive inference point
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:517)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedConstUint16Array">
<summary>
 Unexpected Const_uint16array
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:493)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedConstByteArray">
<summary>
 Unexpected Const_bytearray
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:494)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedConditionInImportedAssembly">
<summary>
 Unexpected condition in imported assembly: failed to decode AttributeUsage attribute
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:695)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedBigRationalConstant">
<summary>
 Unexpected big rational constant
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:491)
</summary>
</member>
<member name="M:FSComp.SR.tcUndefinedField(System.String,System.String)">
<summary>
 The field &apos;%s&apos; has been given a value, but is not present in the type &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:620)
</summary>
</member>
<member name="M:FSComp.SR.tcUnableToParseFormatString(System.String)">
<summary>
 Unable to parse format string &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:598)
</summary>
</member>
<member name="M:FSComp.SR.tcTypesCannotInheritFromMultipleConcreteTypes">
<summary>
 Types cannot inherit from multiple concrete types
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:784)
</summary>
</member>
<member name="M:FSComp.SR.tcTypesCannotContainNestedTypes">
<summary>
 Types cannot contain nested type definitions
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:764)
</summary>
</member>
<member name="M:FSComp.SR.tcTypesAreAlwaysSealedStruct">
<summary>
 Struct types are always sealed
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:796)
</summary>
</member>
<member name="M:FSComp.SR.tcTypesAreAlwaysSealedRecord">
<summary>
 Record types are always sealed
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:794)
</summary>
</member>
<member name="M:FSComp.SR.tcTypesAreAlwaysSealedEnum">
<summary>
 Enum types are always sealed
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:798)
</summary>
</member>
<member name="M:FSComp.SR.tcTypesAreAlwaysSealedDelegate">
<summary>
 Delegate types are always sealed
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:797)
</summary>
</member>
<member name="M:FSComp.SR.tcTypesAreAlwaysSealedDU">
<summary>
 Discriminated union types are always sealed
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:793)
</summary>
</member>
<member name="M:FSComp.SR.tcTypesAreAlwaysSealedAssemblyCode">
<summary>
 Assembly code types are always sealed
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:795)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeUsedInInvalidWay(System.String,System.String,System.String)">
<summary>
 The type &apos;%s&apos; is used in an invalid way. A value prior to &apos;%s&apos; has an inferred type involving &apos;%s&apos;, which is an invalid forward reference.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:821)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeTestLossy(System.String,System.String)">
<summary>
 This type test or downcast will erase the provided type &apos;%s&apos; to the type &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1211)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeTestLosesMeasures(System.String)">
<summary>
 This type test or downcast will ignore the unit-of-measure &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1134)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeTestErased(System.String,System.String)">
<summary>
 This type test with a provided type &apos;%s&apos; is not allowed because this provided type will be erased to &apos;%s&apos; at runtime.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1213)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeRequiresDefinition">
<summary>
 This type requires a definition
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:781)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeParametersInferredAreNotStable">
<summary>
 The type parameters inferred for this value are not stable under the erasure of type abbreviations. This is due to the use of type abbreviations which drop or reorder type parameters, e.g. \n\ttype taggedInt&lt;&apos;a&gt; = int or\n\ttype swap&lt;&apos;a,&apos;b&gt; = &apos;b * &apos;a.\nConsider declaring the type parameters for this value explicitly, e.g.\n\tlet f&lt;&apos;a,&apos;b&gt; ((x,y) : swap&lt;&apos;b,&apos;a&gt;) : swap&lt;&apos;a,&apos;b&gt; = (y,x).
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:522)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeParameterInvalidAsTypeConstructor">
<summary>
 Type parameter cannot be used as type constructor
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:568)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeParameterHasBeenConstrained(System.String)">
<summary>
 This type parameter has been used in a way that constrains it to always be &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:521)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeParameterArityMismatch(System.Int32,System.Int32)">
<summary>
 This value, type or method expects %d type parameter(s) but was given %d
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:544)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeOrModule">
<summary>
 type or module
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:766)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeIsNotInterfaceType1(System.String)">
<summary>
 The type &apos;%s&apos; is not an interface type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:742)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeIsNotInterfaceType0">
<summary>
 This type is not an interface type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:759)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeIsNotARecordTypeNeedConstructor">
<summary>
 This type is not a record type. Values of class and struct types must be created using calls to object constructors.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:647)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeIsNotARecordType">
<summary>
 This type is not a record type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:648)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeIsInaccessible">
<summary>
 This type is not accessible from this code location
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:694)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeHasNoNestedTypes">
<summary>
 This type has no nested types
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:566)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeHasNoAccessibleConstructor">
<summary>
 This type has no accessible object constructors
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:657)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeExceptionOrModule">
<summary>
 type, exception or module
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:765)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeDefinitionsWithImplicitConstructionMustHaveOneInherit">
<summary>
 Type definitions may only have one &apos;inherit&apos; specification and it must be the first declaration
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:814)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeDefinitionsWithImplicitConstructionMustHaveLocalBindingsBeforeMembers">
<summary>
 &apos;let&apos; and &apos;do&apos; bindings must come before member and interface definitions in type definitions
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:815)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeDefinitionIsCyclicThroughInheritance">
<summary>
 This type definition involves an immediate cyclic reference through a struct field or inheritance relation
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:810)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeDefinitionIsCyclic">
<summary>
 This type definition involves an immediate cyclic reference through an abbreviation
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:809)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeCastErased(System.String,System.String)">
<summary>
 This downcast will erase the provided type &apos;%s&apos; to the type &apos;%s&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1212)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeCannotBeEnumerated(System.String)">
<summary>
 The type &apos;%s&apos; is not a type whose values can be enumerated with this syntax, i.e. is not compatible with either seq&lt;_&gt;, IEnumerable&lt;_&gt; or IEnumerable and does not have a GetEnumerator method
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:551)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeAbbreviationsMayNotHaveMembers">
<summary>
 Type abbreviations cannot have members
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:749)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeAbbreviationsCannotHaveInterfaceDeclaration">
<summary>
 Type abbreviations cannot have interface declarations
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:757)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeAbbreviationsCannotHaveAugmentations">
<summary>
 Type abbreviations cannot have augmentations
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:819)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeAbbreviationHasTypeParametersMissingOnType">
<summary>
 This type abbreviation has one or more declared type parameters that do not appear in the type being abbreviated. Type abbreviations must use all declared type parameters in the type being abbreviated. Consider removing one or more type parameters, or use a concrete type definition that wraps an underlying type, such as &apos;type C&lt;&apos;a&gt; = C of ...&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:782)
</summary>
</member>
<member name="M:FSComp.SR.tcTryWithMayNotBeUsedInQueries">
<summary>
 &apos;try/with&apos; expressions may not be used in queries
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1294)
</summary>
</member>
<member name="M:FSComp.SR.tcTryIllegalInSequenceExpression">
<summary>
 &apos;try&apos;/&apos;with&apos; cannot be used within sequence expressions
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:653)
</summary>
</member>
<member name="M:FSComp.SR.tcThreadStaticAndContextStaticMustBeStatic">
<summary>
 Thread-static and context-static variables must be static and given the [&lt;DefaultValue&gt;] attribute to indicate that the value is initialized to the default value on each new thread
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:733)
</summary>
</member>
<member name="M:FSComp.SR.tcThisValueMayNotBeInlined">
<summary>
 This member, function or value declaration may not be declared &apos;inline&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1299)
</summary>
</member>
<member name="M:FSComp.SR.tcThisTypeMayNotHaveACLIMutableAttribute">
<summary>
 This type definition may not have the &apos;CLIMutable&apos; attribute. Only record types may have this attribute.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1280)
</summary>
</member>
<member name="M:FSComp.SR.tcTPFieldMustBeLiteral">
<summary>
 Invalid provided field. Provided fields of erased provided types must be literals.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1312)
</summary>
</member>
<member name="M:FSComp.SR.tcSyntaxFormUsedOnlyWithRecordLabelsPropertiesAndFields">
<summary>
 The syntax &apos;expr.id&apos; may only be used with record labels, properties and fields
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:668)
</summary>
</member>
<member name="M:FSComp.SR.tcSyntaxErrorUnexpectedQMark">
<summary>
 Syntax error - unexpected &apos;?&apos; symbol
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:590)
</summary>
</member>
<member name="M:FSComp.SR.tcSyntaxCanOnlyBeUsedToCreateObjectTypes(System.String)">
<summary>
 &apos;%s&apos; may only be used to construct object types
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:618)
</summary>
</member>
<member name="M:FSComp.SR.tcStructuralEqualityNotSatisfied2(System.String,System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; has the &apos;StructuralEquality&apos; attribute but the component type &apos;%s&apos; does not satisfy the &apos;equality&apos; constraint
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1077)
</summary>
</member>
<member name="M:FSComp.SR.tcStructuralEqualityNotSatisfied1(System.String,System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; has the &apos;StructuralEquality&apos; attribute but the type parameter &apos;%s&apos; does not satisfy the &apos;equality&apos; constraint. Consider adding the &apos;equality&apos; constraint to the type parameter
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1076)
</summary>
</member>
<member name="M:FSComp.SR.tcStructuralComparisonNotSatisfied2(System.String,System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; has the &apos;StructuralComparison&apos; attribute but the component type &apos;%s&apos; does not satisfy the &apos;comparison&apos; constraint
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1071)
</summary>
</member>
<member name="M:FSComp.SR.tcStructuralComparisonNotSatisfied1(System.String,System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; has the &apos;StructuralComparison&apos; attribute but the type parameter &apos;%s&apos; does not satisfy the &apos;comparison&apos; constraint. Consider adding the &apos;comparison&apos; constraint to the type parameter
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1070)
</summary>
</member>
<member name="M:FSComp.SR.tcStructsMustDeclareTypesOfImplicitCtorArgsExplicitly">
<summary>
 Each argument of the primary constructor for a struct must be given a type, for example &apos;type S(x1:int, x2: int) = ...&apos;. These arguments determine the fields of the struct.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1078)
</summary>
</member>
<member name="M:FSComp.SR.tcStructsMayNotContainLetBindings">
<summary>
 Structs cannot contain value definitions because the default constructor for structs will not execute these bindings. Consider adding additional arguments to the primary constructor for the type.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:753)
</summary>
</member>
<member name="M:FSComp.SR.tcStructsMayNotContainDoBindings">
<summary>
 Structs cannot contain &apos;do&apos; bindings because the default constructor for structs would not execute these bindings
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:752)
</summary>
</member>
<member name="M:FSComp.SR.tcStructsInterfacesEnumsDelegatesMayNotInheritFromOtherTypes">
<summary>
 Structs, interfaces, enums and delegates cannot inherit from other types
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:783)
</summary>
</member>
<member name="M:FSComp.SR.tcStructsCannotHaveConstructorWithNoArguments">
<summary>
 Structs cannot have an object constructor with no arguments. This is a restriction imposed on all CLI languages as structs automatically support a default constructor.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:725)
</summary>
</member>
<member name="M:FSComp.SR.tcStructsCanOnlyBindThisAtMemberDeclaration">
<summary>
 Structs may only bind a &apos;this&apos; parameter at member declarations
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:516)
</summary>
</member>
<member name="M:FSComp.SR.tcStructTypesCannotContainAbstractMembers">
<summary>
 Struct types cannot contain abstract members
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:803)
</summary>
</member>
<member name="M:FSComp.SR.tcStaticValFieldsMustBeMutableAndPrivate">
<summary>
 Static &apos;val&apos; fields in types must be mutable, private and marked with the &apos;[&lt;DefaultValue&gt;]&apos; attribute. They are initialized to the &apos;null&apos; or &apos;zero&apos; value for their type. Consider also using a &apos;static let mutable&apos; binding in a class type.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:736)
</summary>
</member>
<member name="M:FSComp.SR.tcStaticOptimizationConditionalsOnlyForFSharpLibrary">
<summary>
 Static optimization conditionals are only for use within the F# library
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:674)
</summary>
</member>
<member name="M:FSComp.SR.tcStaticMemberShouldNotHaveThis">
<summary>
 This static member should not have a &apos;this&apos; parameter. Consider using the notation &apos;member Member(args) = ...&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:535)
</summary>
</member>
<member name="M:FSComp.SR.tcStaticLetBindingsRequireClassesWithImplicitConstructors">
<summary>
 Static value definitions may only be used in types with a primary constructor. Consider adding arguments to the type definition, e.g. &apos;type X(args) = ...&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:754)
</summary>
</member>
<member name="M:FSComp.SR.tcStaticInitializersIllegalInInterface">
<summary>
 Interfaces cannot contain definitions of static initializers
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:720)
</summary>
</member>
<member name="M:FSComp.SR.tcStaticInitializerRequiresArgument">
<summary>
 A static initializer requires an argument
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:533)
</summary>
</member>
<member name="M:FSComp.SR.tcStaticFieldUsedWhenInstanceFieldExpected">
<summary>
 A static field was used where an instance field is expected
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:484)
</summary>
</member>
<member name="M:FSComp.SR.tcSimpleMethodNameRequired">
<summary>
 A simple method name is required here
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:627)
</summary>
</member>
<member name="M:FSComp.SR.tcSeqResultsUseYield">
<summary>
 In sequence expressions, results are generated using &apos;yield&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:490)
</summary>
</member>
<member name="M:FSComp.SR.tcRuntimeSuppliedMethodCannotBeUsedInUserCode(System.String)">
<summary>
 Array method &apos;%s&apos; is supplied by the runtime and cannot be directly used in code. For operations with array elements consider using family of GetArray/SetArray functions from LanguagePrimitives.IntrinsicFunctions module.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1325)
</summary>
</member>
<member name="M:FSComp.SR.tcReturnValuesCannotHaveNames">
<summary>
 Return values cannot have names
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:496)
</summary>
</member>
<member name="M:FSComp.SR.tcReturnTypesForUnionMustBeSameAsType">
<summary>
 Return types of union cases must be identical to the type being defined, up to abbreviations
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:740)
</summary>
</member>
<member name="M:FSComp.SR.tcReturnMayNotBeUsedInQueries">
<summary>
 &apos;return&apos; and &apos;return!&apos; may not be used in queries
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1292)
</summary>
</member>
<member name="M:FSComp.SR.tcReservedSyntaxForAugmentation">
<summary>
 The syntax &apos;type X with ...&apos; is reserved for augmentations. Types whose representations are hidden but which have members are now declared in signatures using &apos;type X = ...&apos;. You may also need to add the &apos;[&lt;Sealed&gt;] attribute to the type definition in the signature
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:811)
</summary>
</member>
<member name="M:FSComp.SR.tcRequireVarConstRecogOrLiteral">
<summary>
 This is not a variable, constant, active recognizer or literal
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:586)
</summary>
</member>
<member name="M:FSComp.SR.tcRequireBuilderMethod(System.String)">
<summary>
 This control construct may only be used if the computation expression builder defines a &apos;%s&apos; method
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:565)
</summary>
</member>
<member name="M:FSComp.SR.tcRequireActivePatternWithOneResult">
<summary>
 Only active patterns returning exactly one result may accept arguments
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:578)
</summary>
</member>
<member name="M:FSComp.SR.tcRepresentationOfTypeHiddenBySignature">
<summary>
 The representation of this type is hidden by the signature. It must be given an attribute such as [&lt;Sealed&gt;], [&lt;Class&gt;] or [&lt;Interface&gt;] to indicate the characteristics of the type.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:789)
</summary>
</member>
<member name="M:FSComp.SR.tcRecursiveBindingsWithMembersMustBeDirectAugmentation">
<summary>
 Recursive bindings that include member specifications can only occur as a direct augmentation of a type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:727)
</summary>
</member>
<member name="M:FSComp.SR.tcRecordsUnionsAbbreviationsStructsMayNotHaveAllowNullLiteralAttribute">
<summary>
 Records, union, abbreviations and struct types cannot have the &apos;AllowNullLiteral&apos; attribute
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:785)
</summary>
</member>
<member name="M:FSComp.SR.tcRecordFieldInconsistentTypes">
<summary>
 This record contains fields from inconsistent types
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:514)
</summary>
</member>
<member name="M:FSComp.SR.tcPropertyRequiresExplicitTypeParameters">
<summary>
 A property cannot have explicit type parameters. Consider using a method instead.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:529)
</summary>
</member>
<member name="M:FSComp.SR.tcPropertyOrFieldNotFoundInAttribute">
<summary>
 This property or field was not found on this custom attribute type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:701)
</summary>
</member>
<member name="M:FSComp.SR.tcPropertyIsStatic(System.String)">
<summary>
 Property &apos;%s&apos; is static
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:665)
</summary>
</member>
<member name="M:FSComp.SR.tcPropertyIsNotStatic(System.String)">
<summary>
 Property &apos;%s&apos; is not static
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:662)
</summary>
</member>
<member name="M:FSComp.SR.tcPropertyIsNotReadable(System.String)">
<summary>
 Property &apos;%s&apos; is not readable
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:663)
</summary>
</member>
<member name="M:FSComp.SR.tcPropertyCannotBeSet1(System.String)">
<summary>
 Property &apos;%s&apos; cannot be set
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:666)
</summary>
</member>
<member name="M:FSComp.SR.tcPropertyCannotBeSet0">
<summary>
 This property cannot be set
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:700)
</summary>
</member>
<member name="M:FSComp.SR.tcPredefinedTypeCannotBeUsedAsSuperType">
<summary>
 The types System.ValueType, System.Enum, System.Delegate, System.MulticastDelegate and System.Array cannot be used as super types in an object expression or class
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:628)
</summary>
</member>
<member name="M:FSComp.SR.tcParameterRequiresName">
<summary>
 A parameter with attributes must also be given a name, e.g. &apos;[&lt;Attribute&gt;] Name : Type&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:495)
</summary>
</member>
<member name="M:FSComp.SR.tcParameterInferredByref(System.String)">
<summary>
 The parameter &apos;%s&apos; was inferred to have byref type. Parameters of byref type must be given an explicit type annotation, e.g. &apos;x1: byref&lt;int&gt;&apos;. When used, a byref parameter is implicitly dereferenced.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1095)
</summary>
</member>
<member name="M:FSComp.SR.tcOverridingMethodRequiresAllOrNoTypeParameters">
<summary>
 You must explicitly declare either all or no type parameters when overriding a generic abstract method
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:524)
</summary>
</member>
<member name="M:FSComp.SR.tcOverridesCannotHaveVisibilityDeclarations">
<summary>
 Accessibility modifiers are not permitted on overrides or interface implementations
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:792)
</summary>
</member>
<member name="M:FSComp.SR.tcOverrideArityMismatch">
<summary>
 This override takes a different number of arguments to the corresponding abstract member
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:712)
</summary>
</member>
<member name="M:FSComp.SR.tcOverloadsCannotHaveCurriedArguments">
<summary>
 One or more of the overloads of this method has curried arguments. Consider redesigning these members to take arguments in tupled form.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:672)
</summary>
</member>
<member name="M:FSComp.SR.tcOptionalArgumentsCannotBeUsedInCustomAttribute">
<summary>
 Optional arguments cannot be used in custom attributes
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:699)
</summary>
</member>
<member name="M:FSComp.SR.tcOptionalArgsOnlyOnMembers">
<summary>
 Optional arguments are only permitted on type members
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:574)
</summary>
</member>
<member name="M:FSComp.SR.tcOptionalArgsMustComeAfterNonOptionalArgs">
<summary>
 Optional arguments must come at the end of the argument list, after any non-optional arguments
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1113)
</summary>
</member>
<member name="M:FSComp.SR.tcOperatorRequiresIn(System.String,System.String)">
<summary>
 &apos;%s&apos; must be followed by &apos;in&apos;. Usage: %s.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1319)
</summary>
</member>
<member name="M:FSComp.SR.tcOperatorIncorrectSyntax(System.String,System.String)">
<summary>
 Incorrect syntax for &apos;%s&apos;. Usage: %s.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1244)
</summary>
</member>
<member name="M:FSComp.SR.tcOperatorDoesntAcceptInto(System.String)">
<summary>
 The operator &apos;%s&apos; does not accept the use of &apos;into&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1278)
</summary>
</member>
<member name="M:FSComp.SR.tcOpenUsedWithPartiallyQualifiedPath(System.String)">
<summary>
 This declaration opens the namespace or module &apos;%s&apos; through a partially qualified path. Adjust this code to use the full path of the namespace. This change will make your code more robust as new constructs are added to the F# and CLI libraries.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:747)
</summary>
</member>
<member name="M:FSComp.SR.tcOnlyTypesRepresentingUnitsOfMeasureCanHaveMeasure">
<summary>
 Only types representing units-of-measure may be given the &apos;Measure&apos; attribute
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:791)
</summary>
</member>
<member name="M:FSComp.SR.tcOnlyStructsCanHaveStructLayout">
<summary>
 Only structs and classes without primary constructors may be given the &apos;StructLayout&apos; attribute
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:788)
</summary>
</member>
<member name="M:FSComp.SR.tcOnlySimplePatternsInLetRec">
<summary>
 Only simple variable patterns can be bound in &apos;let rec&apos; constructs
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:728)
</summary>
</member>
<member name="M:FSComp.SR.tcOnlySimpleBindingsCanBeUsedInConstructionExpressions">
<summary>
 Only simple bindings of the form &apos;id = expr&apos; can be used in construction expressions
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:634)
</summary>
</member>
<member name="M:FSComp.SR.tcOnlyRecordFieldsAndSimpleLetCanBeMutable">
<summary>
 Only record fields and simple &apos;let&apos; bindings may be marked mutable
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:729)
</summary>
</member>
<member name="M:FSComp.SR.tcOnlyFunctionsCanBeInline">
<summary>
 Only functions may be marked &apos;inline&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:688)
</summary>
</member>
<member name="M:FSComp.SR.tcOnlyClassesCanHaveAbstract">
<summary>
 Only classes may be given the &apos;AbstractClass&apos; attribute
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:790)
</summary>
</member>
<member name="M:FSComp.SR.tcObjectsMustBeInitializedWithObjectExpression">
<summary>
 Objects must be initialized by an object construction expression that calls an inherited object constructor and assigns a value to each field
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:635)
</summary>
</member>
<member name="M:FSComp.SR.tcObjectOfIndeterminateTypeUsedRequireTypeConstraint">
<summary>
 The operator &apos;expr.[idx]&apos; has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:609)
</summary>
</member>
<member name="M:FSComp.SR.tcObjectExpressionsCanOnlyOverrideAbstractOrVirtual">
<summary>
 Only overrides of abstract and virtual members may be specified in object expressions
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:623)
</summary>
</member>
<member name="M:FSComp.SR.tcObjectExpressionFormDeprecated">
<summary>
 This form of object expression is not used in F#. Use &apos;member this.MemberName ... = ...&apos; to define member implementations in object expressions.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:539)
</summary>
</member>
<member name="M:FSComp.SR.tcObjectConstructorsOnTypeParametersCannotTakeArguments">
<summary>
 Calls to object constructors on type parameters cannot be given arguments
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:611)
</summary>
</member>
<member name="M:FSComp.SR.tcObjectConstructorsIllegalInInterface">
<summary>
 Interfaces cannot contain definitions of object constructors
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:721)
</summary>
</member>
<member name="M:FSComp.SR.tcObjectConstructorRequiresArgument">
<summary>
 An object constructor requires an argument
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:534)
</summary>
</member>
<member name="M:FSComp.SR.tcObjectConstructionExpressionCanOnlyImplementConstructorsInObjectModelTypes">
<summary>
 Object construction expressions (i.e. record expressions with inheritance specifications) may only be used to implement constructors in object model types. Use &apos;new ObjectType(args)&apos; to construct instances of object model types outside of constructors
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:645)
</summary>
</member>
<member name="M:FSComp.SR.tcObjectConstructionCanOnlyBeUsedInClassTypes">
<summary>
 Object construction expressions may only be used to implement constructors in class types
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:633)
</summary>
</member>
<member name="M:FSComp.SR.tcNumericLiteralRequiresModule(System.String)">
<summary>
 This numeric literal requires that a module &apos;%s&apos; defining functions FromZero, FromOne, FromInt32, FromInt64 and FromString be in scope
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:641)
</summary>
</member>
<member name="M:FSComp.SR.tcNotValidEnumCaseName">
<summary>
 This is not a valid name for an enumeration case
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:602)
</summary>
</member>
<member name="M:FSComp.SR.tcNotSufficientlyGenericBecauseOfScope(System.String)">
<summary>
 This code is not sufficiently generic. The type variable %s could not be generalized because it would escape its scope.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:528)
</summary>
</member>
<member name="M:FSComp.SR.tcNotAnException">
<summary>
 Not an exception
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:774)
</summary>
</member>
<member name="M:FSComp.SR.tcNonZeroConstantCannotHaveGenericUnit">
<summary>
 Non-zero constants cannot have generic units. For generic zero, write 0.0&lt;_&gt;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:489)
</summary>
</member>
<member name="M:FSComp.SR.tcNonUniformMemberUse(System.String)">
<summary>
 The generic member &apos;%s&apos; has been used at a non-uniform instantiation prior to this program point. Consider reordering the members so this member occurs first. Alternatively, specify the full type of the member explicitly, including argument types, return type and any additional generic parameters and constraints.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1096)
</summary>
</member>
<member name="M:FSComp.SR.tcNonSimpleLetBindingInQuery">
<summary>
 This &apos;let&apos; definition may not be used in a query. Only simple value definitions may be used in queries.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1295)
</summary>
</member>
<member name="M:FSComp.SR.tcNonLiteralCannotBeUsedInPattern">
<summary>
 This value is not a literal and cannot be used in a pattern
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:547)
</summary>
</member>
<member name="M:FSComp.SR.tcNoWhileInQuery">
<summary>
 &apos;while&apos; expressions may not be used in queries
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1288)
</summary>
</member>
<member name="M:FSComp.SR.tcNoTryFinallyInQuery">
<summary>
 &apos;try/finally&apos; expressions may not be used in queries
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1289)
</summary>
</member>
<member name="M:FSComp.SR.tcNoPropertyFoundForOverride">
<summary>
 No abstract property was found that corresponds to this override
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:715)
</summary>
</member>
<member name="M:FSComp.SR.tcNoMemberFoundForOverride">
<summary>
 No abstract or interface member was found that corresponds to this override
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:711)
</summary>
</member>
<member name="M:FSComp.SR.tcNoInterfaceImplementationForConstructionExpression">
<summary>
 Interface implementations cannot be given on construction expressions
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:632)
</summary>
</member>
<member name="M:FSComp.SR.tcNoIntegerForLoopInQuery">
<summary>
 In queries, use the form &apos;for x in n .. m do ...&apos; for ranging over integers
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1287)
</summary>
</member>
<member name="M:FSComp.SR.tcNoEqualityNeeded2(System.String,System.String,System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; does not support structural equality because the type &apos;%s&apos; does not satisfy the &apos;equality&apos; constraint. Consider adding the &apos;NoEquality&apos; attribute to the type &apos;%s&apos; to clarify that the type does not support structural equality
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1075)
</summary>
</member>
<member name="M:FSComp.SR.tcNoEqualityNeeded1(System.String,System.String,System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; does not support structural equality because the type parameter %s does not satisfy the &apos;equality&apos; constraint. Consider adding the &apos;NoEquality&apos; attribute to the type &apos;%s&apos; to clarify that the type does not support structural equality
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1074)
</summary>
</member>
<member name="M:FSComp.SR.tcNoComparisonNeeded2(System.String,System.String,System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; is not structurally comparable because the type &apos;%s&apos; does not satisfy the &apos;comparison&apos; constraint. Consider adding the &apos;NoComparison&apos; attribute to the type &apos;%s&apos; to clarify that the type is not comparable
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1073)
</summary>
</member>
<member name="M:FSComp.SR.tcNoComparisonNeeded1(System.String,System.String,System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; is not structurally comparable because the type parameter %s does not satisfy the &apos;comparison&apos; constraint. Consider adding the &apos;NoComparison&apos; attribute to the type &apos;%s&apos; to clarify that the type is not comparable
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1072)
</summary>
</member>
<member name="M:FSComp.SR.tcNoArgumentsForRecordValue">
<summary>
 No arguments may be given when constructing a record value
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:631)
</summary>
</member>
<member name="M:FSComp.SR.tcNoAbstractOrVirtualMemberFound(System.String)">
<summary>
 The member &apos;%s&apos; does not correspond to any abstract or virtual method available to override or implement
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:624)
</summary>
</member>
<member name="M:FSComp.SR.tcNewRequiresObjectConstructor">
<summary>
 &apos;new&apos; may only be used with object constructors
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:639)
</summary>
</member>
<member name="M:FSComp.SR.tcNewMustBeUsedWithNamedType">
<summary>
 &apos;new&apos; must be used with a named type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:629)
</summary>
</member>
<member name="M:FSComp.SR.tcNewMemberHidesAbstractMemberWithSuffix(System.String)">
<summary>
 This new member hides the abstract member &apos;%s&apos; once tuples, functions, units of measure and/or provided types are erased. Rename the member or use &apos;override&apos; instead.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:719)
</summary>
</member>
<member name="M:FSComp.SR.tcNewMemberHidesAbstractMember(System.String)">
<summary>
 This new member hides the abstract member &apos;%s&apos;. Rename the member or use &apos;override&apos; instead.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:718)
</summary>
</member>
<member name="M:FSComp.SR.tcNewCannotBeUsedOnInterfaceType">
<summary>
 &apos;new&apos; cannot be used on interface types. Consider using an object expression &apos;{ new ... with ... }&apos; instead.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:615)
</summary>
</member>
<member name="M:FSComp.SR.tcNamespaceCannotContainValues">
<summary>
 Namespaces cannot contain values. Consider using a module to hold your value declarations.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:498)
</summary>
</member>
<member name="M:FSComp.SR.tcNamespaceCannotContainExtensionMembers">
<summary>
 Namespaces cannot contain extension members except in the same file and namespace where the type is defined. Consider using a module to hold declarations of extension members.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:499)
</summary>
</member>
<member name="M:FSComp.SR.tcNamedTypeRequired(System.String)">
<summary>
 &apos;%s&apos; may only be used with named types
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:613)
</summary>
</member>
<member name="M:FSComp.SR.tcNamedArgumentsCannotBeUsedInMemberTraits">
<summary>
 Named arguments cannot be given to member trait calls
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:601)
</summary>
</member>
<member name="M:FSComp.SR.tcNamedArgumentDidNotMatch(System.String)">
<summary>
 The named argument &apos;%s&apos; did not match any argument or mutable property
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:671)
</summary>
</member>
<member name="M:FSComp.SR.tcNameNotBoundInPattern(System.String)">
<summary>
 Name &apos;%s&apos; not bound in pattern context
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:575)
</summary>
</member>
<member name="M:FSComp.SR.tcNameArgumentsMustAppearLast">
<summary>
 Named arguments must appear after all other arguments
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:549)
</summary>
</member>
<member name="M:FSComp.SR.tcMutableValuesSyntax">
<summary>
 Mutable function values should be written &apos;let mutable f = (fun args -&gt; ...)&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:687)
</summary>
</member>
<member name="M:FSComp.SR.tcMutableValuesMayNotHaveGenericParameters">
<summary>
 Mutable values cannot have generic parameters
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:686)
</summary>
</member>
<member name="M:FSComp.SR.tcMutableValuesCannotBeInline">
<summary>
 Mutable values cannot be marked &apos;inline&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:685)
</summary>
</member>
<member name="M:FSComp.SR.tcMultipleVisibilityAttributesWithLet">
<summary>
 Multiple visibility attributes have been specified for this identifier. &apos;let&apos; bindings in classes are always private, as are any &apos;let&apos; bindings inside expressions.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:501)
</summary>
</member>
<member name="M:FSComp.SR.tcMultipleVisibilityAttributes">
<summary>
 Multiple visibility attributes have been specified for this identifier
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:500)
</summary>
</member>
<member name="M:FSComp.SR.tcModuleRequiresQualifiedAccess(System.String)">
<summary>
 This declaration opens the module &apos;%s&apos;, which is marked as &apos;RequireQualifiedAccess&apos;. Adjust your code to use qualified references to the elements of the module instead, e.g. &apos;List.map&apos; instead of &apos;map&apos;. This change will ensure that your code is robust as new constructs are added to libraries.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:746)
</summary>
</member>
<member name="M:FSComp.SR.tcModuleAbbreviationForNamespace(System.String)">
<summary>
 The path &apos;%s&apos; is a namespace. A module abbreviation may not abbreviate a namespace.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:820)
</summary>
</member>
<member name="M:FSComp.SR.tcMissingCustomOperation(System.String)">
<summary>
 A custom query operation for &apos;%s&apos; is required but not specified
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1225)
</summary>
</member>
<member name="M:FSComp.SR.tcMethodOverridesIllegalHere">
<summary>
 Method overrides and interface implementations are not permitted here
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:710)
</summary>
</member>
<member name="M:FSComp.SR.tcMethodNotAccessible(System.String)">
<summary>
 Method &apos;%s&apos; is not accessible from this code location
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:485)
</summary>
</member>
<member name="M:FSComp.SR.tcMembersThatExtendInterfaceMustBePlacedInSeparateModule">
<summary>
 Members that extend interface, delegate or enum types must be placed in a module separate to the definition of the type. This module must either have the AutoOpen attribute or be opened explicitly by client code to bring the extension members into scope.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:812)
</summary>
</member>
<member name="M:FSComp.SR.tcMemberUsedInInvalidWay(System.String,System.String,System.String)">
<summary>
 The member &apos;%s&apos; is used in an invalid way. A use of &apos;%s&apos; has been inferred prior to the definition of &apos;%s&apos;, which is an invalid forward reference.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:822)
</summary>
</member>
<member name="M:FSComp.SR.tcMemberOverridesIllegalInInterface">
<summary>
 Interfaces cannot contain definitions of member overrides
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:722)
</summary>
</member>
<member name="M:FSComp.SR.tcMemberOperatorDefinitionInExtrinsic">
<summary>
 Extension members cannot provide operator overloads.  Consider defining the operator as part of the type definition instead.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1116)
</summary>
</member>
<member name="M:FSComp.SR.tcMemberNotPermittedInInterfaceImplementation">
<summary>
 This member is not permitted in an interface implementation
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:762)
</summary>
</member>
<member name="M:FSComp.SR.tcMemberKindPropertyGetSetNotExpected">
<summary>
 MemberKind.PropertyGetSet only expected in parse trees
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:497)
</summary>
</member>
<member name="M:FSComp.SR.tcMemberIsNotSufficientlyGeneric">
<summary>
 This member is not sufficiently generic
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:730)
</summary>
</member>
<member name="M:FSComp.SR.tcMemberAndLocalClassBindingHaveSameName(System.String)">
<summary>
 A member and a local class binding both have the name &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:756)
</summary>
</member>
<member name="M:FSComp.SR.tcMeasureDefinitionsCannotHaveTypeParameters">
<summary>
 Measure definitions cannot have type parameters
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:780)
</summary>
</member>
<member name="M:FSComp.SR.tcMeasureDeclarationsRequireStaticMembersNotConstructors">
<summary>
 Measure declarations may have only static members: constructors are not available
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:755)
</summary>
</member>
<member name="M:FSComp.SR.tcMeasureDeclarationsRequireStaticMembers">
<summary>
 Measure declarations may have only static members
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:751)
</summary>
</member>
<member name="M:FSComp.SR.tcMatchMayNotBeUsedWithQuery">
<summary>
 &apos;match&apos; expressions may not be used in queries
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1316)
</summary>
</member>
<member name="M:FSComp.SR.tcLookupMayNotBeUsedHere">
<summary>
 This lookup cannot be used here
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:664)
</summary>
</member>
<member name="M:FSComp.SR.tcLocalClassBindingsCannotBeInline">
<summary>
 Local class bindings cannot be marked inline. Consider lifting the definition out of the class or else do not mark it as inline.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:748)
</summary>
</member>
<member name="M:FSComp.SR.tcLiteralCannotHaveGenericParameters">
<summary>
 Literal values cannot have generic parameters
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:692)
</summary>
</member>
<member name="M:FSComp.SR.tcLiteralCannotBeMutable">
<summary>
 A literal value cannot be marked &apos;mutable&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:690)
</summary>
</member>
<member name="M:FSComp.SR.tcLiteralCannotBeInline">
<summary>
 A literal value cannot be marked &apos;inline&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:691)
</summary>
</member>
<member name="M:FSComp.SR.tcLiteralAttributeRequiresConstantValue">
<summary>
 A declaration may only be the [&lt;Literal&gt;] attribute if a constant value is also given, e.g. &apos;val x : int = 1&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:731)
</summary>
</member>
<member name="M:FSComp.SR.tcListLiteralMaxSize">
<summary>
 This list expression exceeds the maximum size for list literals. Use an array for larger literals and call Array.ToList.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:599)
</summary>
</member>
<member name="M:FSComp.SR.tcLetAndDoRequiresImplicitConstructionSequence">
<summary>
 This definition may only be used in a type with a primary constructor. Consider adding arguments to your type definition, e.g. &apos;type X(args) = ...&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:818)
</summary>
</member>
<member name="M:FSComp.SR.tcLessGenericBecauseOfAnnotation(System.String,System.String)">
<summary>
 This code is less generic than required by its annotations because the explicit type variable &apos;%s&apos; could not be generalized. It was constrained to be &apos;%s&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:518)
</summary>
</member>
<member name="M:FSComp.SR.tcKindOfTypeSpecifiedDoesNotMatchDefinition">
<summary>
 The kind of the type specified by its attributes does not match the kind implied by its definition
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:779)
</summary>
</member>
<member name="M:FSComp.SR.tcJoinMustUseSimplePattern(System.String)">
<summary>
 In queries, &apos;%s&apos; must use a simple pattern
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1224)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidUseOfTypeNameOrConstructorWithOverloads(System.String)">
<summary>
 Invalid use of a type name and/or object constructor. If necessary use &apos;new&apos; and apply the constructor to its arguments, e.g. &apos;new Type(args)&apos;. The required signature is:\n\t%s.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:659)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidUseOfTypeNameOrConstructor">
<summary>
 Invalid use of a type name and/or object constructor. If necessary use &apos;new&apos; and apply the constructor to its arguments, e.g. &apos;new Type(args)&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:658)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidUseOfTypeName">
<summary>
 Invalid use of a type name
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:656)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidUseOfInterfaceType">
<summary>
 Invalid use of an interface type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:660)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidUseOfDelegate">
<summary>
 Invalid use of a delegate constructor. Use the syntax &apos;new Type(args)&apos; or just &apos;Type(args)&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:661)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidUseNullAsTrueValue">
<summary>
 The &apos;UseNullAsTrueValue&apos; attribute flag may only be used with union types that have one nullary case and at least one non-nullary case
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1094)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidUseBinding">
<summary>
 &apos;use&apos; bindings must be of the form &apos;use &lt;var&gt; = &lt;expr&gt;&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:708)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidUseBangBinding">
<summary>
 &apos;use!&apos; bindings must be of the form &apos;use! &lt;var&gt; = &lt;expr&gt;&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1129)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidUnitsOfMeasurePrefix">
<summary>
 Units-of-measure cannot be used as prefix arguments to a type. Rewrite as postfix arguments in angle brackets.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:563)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidTypeForUnitsOfMeasure">
<summary>
 Units-of-measure supported only on float, float32, decimal and signed integer types
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:492)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidTypeForLiteralEnumeration">
<summary>
 Literal enumerations must have type int, uint, int16, uint16, int64, uint64, byte, sbyte or char
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:807)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidTypeExtension">
<summary>
 Invalid type extension
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:777)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidTypeArgumentUsage">
<summary>
 Type arguments cannot be specified here
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:577)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidTypeArgumentCount(System.Int32,System.Int32)">
<summary>
 The number of type arguments did not match: &apos;%d&apos; given, &apos;%d&apos; expected. This may be related to a previously reported error.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1218)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidSignatureForSet">
<summary>
 Invalid signature for set member
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:717)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidSequenceExpressionSyntaxForm">
<summary>
 Invalid record, sequence or computation expression. Sequence expressions should be of the form &apos;seq { ... }&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:596)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidRelationInJoin(System.String)">
<summary>
 Invalid join relation in &apos;%s&apos;. Expected &apos;expr &lt;op&gt; expr&apos;, where &lt;op&gt; is =, =?, ?= or ?=?.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1271)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidRecordConstruction">
<summary>
 Invalid record construction
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:642)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidPropertyType">
<summary>
 This property has an invalid type. Properties taking multiple indexer arguments should have types of the form &apos;ty1 * ty2 -&gt; ty3&apos;. Properties returning functions should have types of the form &apos;(ty1 -&gt; ty2)&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:558)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidPattern">
<summary>
 This is not a valid pattern
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:587)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidOptionalAssignmentToPropertyOrField">
<summary>
 Invalid optional assignment to a property or field
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:676)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidOperatorDefinitionRelational(System.String)">
<summary>
 The &apos;%s&apos; operator should not normally be redefined. To define overloaded comparison semantics for a particular type, implement the &apos;System.IComparable&apos; interface in the definition of that type.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:506)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidOperatorDefinitionEquality(System.String)">
<summary>
 The &apos;%s&apos; operator should not normally be redefined. To define equality semantics for a type, override the &apos;Object.Equals&apos; member in the definition of that type.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:507)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidOperatorDefinition(System.String)">
<summary>
 The &apos;%s&apos; operator should not normally be redefined. Consider using a different operator name
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:508)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidObjectSequenceOrRecordExpression">
<summary>
 Invalid object, sequence or record expression
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:595)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidObjectExpressionSyntaxForm">
<summary>
 Invalid object expression. Objects without overrides or interfaces should use the expression form &apos;new Type(args)&apos; without braces.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:594)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidObjectConstructionExpression">
<summary>
 This is not a valid object construction expression. Explicit object constructors must either call an alternate constructor or initialize all fields of the object and specify a call to a super class constructor.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:553)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidNonPrimitiveLiteralInPatternMatch">
<summary>
 Non-primitive numeric literal constants cannot be used in pattern matches because they can be mapped to multiple different types through the use of a NumericLiteral module. Consider using replacing with a variable, and use &apos;when &lt;variable&gt; = &lt;constant&gt;&apos; at the end of the match clause.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:576)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidNewConstraint">
<summary>
 &apos;new&apos; constraints must take one argument of type &apos;unit&apos; and return the constructed type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:557)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidNamespaceModuleTypeUnionName">
<summary>
 Invalid namespace, module, type or union case name
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:738)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidModuleName">
<summary>
 Invalid module name
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:776)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidMixtureOfRecursiveForms">
<summary>
 This recursive binding uses an invalid mixture of recursive forms
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:552)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidMethodNameForRelationalOperator(System.String,System.String)">
<summary>
 The name &apos;(%s)&apos; should not be used as a member name. To define comparison semantics for a type, implement the &apos;System.IComparable&apos; interface. If defining a static member for use from other CLI languages then use the name &apos;%s&apos; instead.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:502)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidMethodNameForEquality(System.String,System.String)">
<summary>
 The name &apos;(%s)&apos; should not be used as a member name. To define equality semantics for a type, override the &apos;Object.Equals&apos; member. If defining a static member for use from other CLI languages then use the name &apos;%s&apos; instead.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:503)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidMemberNameFixedTypes(System.String)">
<summary>
 The name &apos;(%s)&apos; should not be used as a member name because it is given a standard definition in the F# library over fixed types
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:505)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidMemberNameCtor">
<summary>
 Invalid member name. Members may not have name &apos;.ctor&apos; or &apos;.cctor&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1216)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidMemberName(System.String,System.String)">
<summary>
 The name &apos;(%s)&apos; should not be used as a member name. If defining a static member for use from other CLI languages then use the name &apos;%s&apos; instead.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:504)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidInlineSpecification">
<summary>
 Invalid inline specification
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:707)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidIndexerExpression">
<summary>
 Invalid indexer expression
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:608)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidIndexOperatorDefinition(System.String)">
<summary>
 The &apos;%s&apos; operator cannot be redefined. Consider using a different operator name
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:509)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidIndexIntoActivePatternArray">
<summary>
 Internal error. Invalid index into active pattern array
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:580)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidEnumerationLiteral">
<summary>
 This is not a valid value for an enumeration literal
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:741)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidEnumConstraint">
<summary>
 An &apos;enum&apos; constraint must be of the form &apos;enum&lt;type&gt;&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:556)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidDelegateSpecification">
<summary>
 Delegate specifications must be of the form &apos;typ -&gt; typ&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:805)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidDeclaration">
<summary>
 Invalid declaration
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:540)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidConstraintTypeSealed">
<summary>
 Invalid constraint: the type used for the constraint is sealed, which means the constraint could only be satisfied by at most one solution
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:555)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidConstraint">
<summary>
 Invalid constraint
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:554)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidConstantExpression">
<summary>
 This is not a valid constant expression
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:693)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidAssignment">
<summary>
 Invalid assignment
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:655)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidArgForParameterizedPattern">
<summary>
 Invalid argument to parameterized pattern label
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:579)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidActivePatternName">
<summary>
 This is not a valid name for an active pattern
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:683)
</summary>
</member>
<member name="M:FSComp.SR.tcIntoNeedsRestOfQuery">
<summary>
 A use of &apos;into&apos; must be followed by the remainder of the computation
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1277)
</summary>
</member>
<member name="M:FSComp.SR.tcInterfacesShouldUseInheritNotInterface">
<summary>
 Interfaces inherited by other interfaces should be declared using &apos;inherit ...&apos; instead of &apos;interface ...&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1105)
</summary>
</member>
<member name="M:FSComp.SR.tcInterfaceTypesCannotBeSealed">
<summary>
 Interface types cannot be sealed
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:804)
</summary>
</member>
<member name="M:FSComp.SR.tcInterfaceTypesAndDelegatesCannotContainFields">
<summary>
 Interface types and delegate types cannot contain fields
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:799)
</summary>
</member>
<member name="M:FSComp.SR.tcInstanceMemberRequiresTarget">
<summary>
 This instance member needs a parameter to represent the object being invoked. Make the member static or use the notation &apos;member x.Member(args) = ...&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:531)
</summary>
</member>
<member name="M:FSComp.SR.tcInheritedTypeIsNotObjectModelType">
<summary>
 The inherited type is not an object model type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:644)
</summary>
</member>
<member name="M:FSComp.SR.tcInheritIllegalHere">
<summary>
 A inheritance declaration is not permitted here
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:745)
</summary>
</member>
<member name="M:FSComp.SR.tcInheritDeclarationMissingArguments">
<summary>
 This &apos;inherit&apos; declaration specifies the inherited type but no arguments. Consider supplying arguments, e.g. &apos;inherit BaseType(args)&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:816)
</summary>
</member>
<member name="M:FSComp.SR.tcInheritConstructionCallNotPartOfImplicitSequence">
<summary>
 This &apos;inherit&apos; declaration has arguments, but is not in a type with a primary constructor. Consider adding arguments to your type definition, e.g. &apos;type X(args) = ...&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:817)
</summary>
</member>
<member name="M:FSComp.SR.tcInheritCannotBeUsedOnInterfaceType">
<summary>
 &apos;inherit&apos; cannot be used on interface types. Consider implementing the interface by using &apos;interface ... with ... end&apos; instead.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:614)
</summary>
</member>
<member name="M:FSComp.SR.tcInferredGenericTypeGivesRiseToInconsistency(System.String,System.String)">
<summary>
 The function or member &apos;%s&apos; is used in a way that requires further type annotations at its definition to ensure consistency of inferred types. The inferred signature is &apos;%s&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1217)
</summary>
</member>
<member name="M:FSComp.SR.tcImplicitMeasureFollowingSlash">
<summary>
 Implicit product of measures following /
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:487)
</summary>
</member>
<member name="M:FSComp.SR.tcImplementsIStructuralEquatableExplicitly(System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; implements the interface &apos;System.IStructuralEquatable&apos; explicitly. Apply the &apos;CustomEquality&apos; attribute to the type.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:767)
</summary>
</member>
<member name="M:FSComp.SR.tcImplementsIStructuralComparableExplicitly(System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; implements the interface &apos;System.IStructuralComparable&apos; explicitly. Apply the &apos;CustomComparison&apos; attribute to the type.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:513)
</summary>
</member>
<member name="M:FSComp.SR.tcImplementsIEquatableExplicitly(System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; implements the interface &apos;System.IEquatable&lt;_&gt;&apos; explicitly. Apply the &apos;CustomEquality&apos; attribute to the type and provide a consistent implementation of the non-generic override &apos;System.Object.Equals(obj)&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:768)
</summary>
</member>
<member name="M:FSComp.SR.tcImplementsIComparableExplicitly(System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; implements the interface &apos;System.IComparable&apos; explicitly. You must apply the &apos;CustomComparison&apos; attribute to the type.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:511)
</summary>
</member>
<member name="M:FSComp.SR.tcImplementsGenericIComparableExplicitly(System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; implements the interface &apos;System.IComparable&lt;_&gt;&apos; explicitly. You must apply the &apos;CustomComparison&apos; attribute to the type, and should also provide a consistent implementation of the non-generic interface System.IComparable.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:512)
</summary>
</member>
<member name="M:FSComp.SR.tcIllegalSyntaxInTypeExpression">
<summary>
 Illegal syntax in type expression
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:569)
</summary>
</member>
<member name="M:FSComp.SR.tcIllegalStructTypeForConstantExpression">
<summary>
 This is not valid literal expression. The [&lt;Literal&gt;] attribute will be ignored.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1331)
</summary>
</member>
<member name="M:FSComp.SR.tcIllegalPattern">
<summary>
 Illegal pattern
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:589)
</summary>
</member>
<member name="M:FSComp.SR.tcIllegalFormForExplicitTypeDeclaration">
<summary>
 Explicit type declarations for constructors must be of the form &apos;ty1 * ... * tyN -&gt; resTy&apos;. Parentheses may be required around &apos;resTy&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:739)
</summary>
</member>
<member name="M:FSComp.SR.tcIllegalAttributesForLiteral">
<summary>
 A literal value cannot be given the [&lt;ThreadStatic&gt;] or [&lt;ContextStatic&gt;] attributes
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:689)
</summary>
</member>
<member name="M:FSComp.SR.tcIfThenElseMayNotBeUsedWithinQueries">
<summary>
 An if/then/else expression may not be used within queries. Consider using either an if/then expression, or use a sequence expression instead.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1234)
</summary>
</member>
<member name="M:FSComp.SR.tcIDisposableTypeShouldUseNew">
<summary>
 It is recommended that objects that support the IDisposable interface are created using &apos;new Type(args)&apos; rather than &apos;Type(args)&apos; to indicate that resources may be owned by the generated value
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:617)
</summary>
</member>
<member name="M:FSComp.SR.tcGenericTypesCannotHaveStructLayout">
<summary>
 Generic types cannot be given the &apos;StructLayout&apos; attribute
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:787)
</summary>
</member>
<member name="M:FSComp.SR.tcGenericParameterHasBeenConstrained(System.String)">
<summary>
 A generic type parameter has been used in a way that constrains it to always be &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:520)
</summary>
</member>
<member name="M:FSComp.SR.tcGeneratedTypesShouldBeInternalOrPrivate">
<summary>
 The provided types generated by this use of a type provider may not be used from other F# assemblies and should be marked internal or private. Consider using &apos;type internal TypeName = ...&apos; or &apos;type private TypeName = ...&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1323)
</summary>
</member>
<member name="M:FSComp.SR.tcFunctionRequiresExplicitTypeArguments(System.String)">
<summary>
 The generic function &apos;%s&apos; must be given explicit type argument(s)
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:542)
</summary>
</member>
<member name="M:FSComp.SR.tcFunctionRequiresExplicitLambda(System.Int32)">
<summary>
 This function value is being used to construct a delegate type whose signature includes a byref argument. You must use an explicit lambda expression taking %d arguments.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:550)
</summary>
</member>
<member name="M:FSComp.SR.tcFormalArgumentIsNotOptional">
<summary>
 The corresponding formal argument is not optional
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:675)
</summary>
</member>
<member name="M:FSComp.SR.tcFieldsDoNotDetermineUniqueRecordType">
<summary>
 The field labels and expected type of this record expression or pattern do not uniquely determine a corresponding record type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:525)
</summary>
</member>
<member name="M:FSComp.SR.tcFieldValIllegalHere">
<summary>
 A field/val declaration is not permitted here
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:744)
</summary>
</member>
<member name="M:FSComp.SR.tcFieldRequiresName">
<summary>
 This field requires a name
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:737)
</summary>
</member>
<member name="M:FSComp.SR.tcFieldRequiresAssignment(System.String,System.String)">
<summary>
 No assignment given for field &apos;%s&apos; of type &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:621)
</summary>
</member>
<member name="M:FSComp.SR.tcFieldNotLiteralCannotBeUsedInPattern">
<summary>
 This field is not a literal and cannot be used in a pattern
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:585)
</summary>
</member>
<member name="M:FSComp.SR.tcFieldNameIsUsedModeThanOnce(System.String)">
<summary>
 Named field &apos;%s&apos; is used more than once.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1328)
</summary>
</member>
<member name="M:FSComp.SR.tcFieldNameConflictsWithGeneratedNameForAnonymousField(System.String)">
<summary>
 Named field &apos;%s&apos; conflicts with autogenerated name for anonymous field.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1329)
</summary>
</member>
<member name="M:FSComp.SR.tcFieldIsReadonly">
<summary>
 This field is readonly
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:548)
</summary>
</member>
<member name="M:FSComp.SR.tcFieldIsNotStatic(System.String)">
<summary>
 Field &apos;%s&apos; is not static
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:584)
</summary>
</member>
<member name="M:FSComp.SR.tcFieldIsNotMutable">
<summary>
 This field is not mutable
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:603)
</summary>
</member>
<member name="M:FSComp.SR.tcFieldAppearsTwiceInRecord(System.String)">
<summary>
 The field &apos;%s&apos; appears twice in this record expression or pattern
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:526)
</summary>
</member>
<member name="M:FSComp.SR.tcFSharpCoreRequiresExplicit">
<summary>
 All record, union and struct types in FSharp.Core.dll must be explicitly labelled with &apos;StructuralComparison&apos; or &apos;NoComparison&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1069)
</summary>
</member>
<member name="M:FSComp.SR.tcExtraneousFieldsGivenValues">
<summary>
 Extraneous fields have been given values
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:622)
</summary>
</member>
<member name="M:FSComp.SR.tcExpressionWithIfRequiresParenthesis">
<summary>
 This list or array expression includes an element of the form &apos;if ... then ... else&apos;. Parenthesize this expression to indicate it is an individual element of the list or array, to disambiguate this from a list generated using a sequence expression
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:597)
</summary>
</member>
<member name="M:FSComp.SR.tcExpressionRequiresSequence">
<summary>
 This expression form may only be used in sequence and computation expressions
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:593)
</summary>
</member>
<member name="M:FSComp.SR.tcExpressionFormRequiresRecordTypes">
<summary>
 The expression form { expr with ... } may only be used with record types. To build object types use { new Type(...) with ... }
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:643)
</summary>
</member>
<member name="M:FSComp.SR.tcExpressionFormRequiresObjectConstructor">
<summary>
 The expression form &apos;expr then expr&apos; may only be used as part of an explicit object constructor
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:600)
</summary>
</member>
<member name="M:FSComp.SR.tcExpressionCountMisMatch(System.Int32,System.Int32)">
<summary>
 Expected %d expressions, got %d
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:591)
</summary>
</member>
<member name="M:FSComp.SR.tcExprUndelayed">
<summary>
 TcExprUndelayed: delayed
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:592)
</summary>
</member>
<member name="M:FSComp.SR.tcExplicitTypeSpecificationCannotBeUsedForExceptionConstructors">
<summary>
 Explicit type specifications cannot be used for exception constructors
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:769)
</summary>
</member>
<member name="M:FSComp.SR.tcExplicitTypeParameterInvalid">
<summary>
 Explicit type parameters may only be used on module or member bindings
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:523)
</summary>
</member>
<member name="M:FSComp.SR.tcExplicitStaticInitializerSyntax">
<summary>
 An explicit static initializer should use the syntax &apos;static new(args) = expr&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:536)
</summary>
</member>
<member name="M:FSComp.SR.tcExplicitObjectConstructorSyntax">
<summary>
 An explicit object constructor should use the syntax &apos;new(args) = expr&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:537)
</summary>
</member>
<member name="M:FSComp.SR.tcExpectedUnitOfMeasureNotType">
<summary>
 Expected unit-of-measure, not type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:562)
</summary>
</member>
<member name="M:FSComp.SR.tcExpectedUnitOfMeasureMarkWithAttribute">
<summary>
 Expected unit-of-measure parameter, not type parameter. Explicit unit-of-measure parameters must be marked with the [&lt;Measure&gt;] attribute.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:559)
</summary>
</member>
<member name="M:FSComp.SR.tcExpectedTypeParameter">
<summary>
 Expected type parameter, not unit-of-measure parameter
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:560)
</summary>
</member>
<member name="M:FSComp.SR.tcExpectedTypeNotUnitOfMeasure">
<summary>
 Expected type, not unit-of-measure
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:561)
</summary>
</member>
<member name="M:FSComp.SR.tcExpectedInterfaceType">
<summary>
 Expected an interface type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:636)
</summary>
</member>
<member name="M:FSComp.SR.tcExpectModuleOrNamespaceParent(System.String)">
<summary>
 Expected module or namespace parent %s
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:510)
</summary>
</member>
<member name="M:FSComp.SR.tcExceptionAbbreviationsShouldNotHaveArgumentList">
<summary>
 Exception abbreviations should not have argument lists
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:770)
</summary>
</member>
<member name="M:FSComp.SR.tcExceptionAbbreviationsMustReferToValidExceptions">
<summary>
 Exception abbreviations must refer to existing exceptions or F# types deriving from System.Exception
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:772)
</summary>
</member>
<member name="M:FSComp.SR.tcEventIsStatic(System.String)">
<summary>
 Event &apos;%s&apos; is static
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:669)
</summary>
</member>
<member name="M:FSComp.SR.tcEventIsNotStatic(System.String)">
<summary>
 Event &apos;%s&apos; is not static
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:670)
</summary>
</member>
<member name="M:FSComp.SR.tcEnumerationsMayNotHaveMembers">
<summary>
 Enumerations cannot have members
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:750)
</summary>
</member>
<member name="M:FSComp.SR.tcEnumerationsCannotHaveInterfaceDeclaration">
<summary>
 Enumerations cannot have interface declarations
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:758)
</summary>
</member>
<member name="M:FSComp.SR.tcEnumTypeCannotBeEnumerated(System.String)">
<summary>
 The type &apos;%s&apos; is not a valid enumerator type , i.e. does not have a &apos;MoveNext()&apos; method returning a bool, and a &apos;Current&apos; property
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1131)
</summary>
</member>
<member name="M:FSComp.SR.tcEntryPointAttributeRequiresFunctionInModule">
<summary>
 The &apos;EntryPointAttribute&apos; attribute may only be used on function definitions in modules
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:684)
</summary>
</member>
<member name="M:FSComp.SR.tcEmptyRecordInvalid">
<summary>
 &apos;{ }&apos; is not a valid expression. Records must include at least one field. Empty sequences are specified by using Seq.empty or an empty list &apos;[]&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:646)
</summary>
</member>
<member name="M:FSComp.SR.tcEmptyCopyAndUpdateRecordInvalid">
<summary>
 Copy-and-update record expressions must include at least one field.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1321)
</summary>
</member>
<member name="M:FSComp.SR.tcDuplicateSpecOfInterface">
<summary>
 Duplicate specification of an interface
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:743)
</summary>
</member>
<member name="M:FSComp.SR.tcDoesNotAllowExplicitTypeArguments(System.String)">
<summary>
 The method or function &apos;%s&apos; should not be given explicit type argument(s) because it does not declare its type parameters explicitly
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:543)
</summary>
</member>
<member name="M:FSComp.SR.tcDoBangIllegalInSequenceExpression">
<summary>
 &apos;do!&apos; cannot be used within sequence expressions
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:651)
</summary>
</member>
<member name="M:FSComp.SR.tcDllImportStubsCannotBeInlined">
<summary>
 DLLImport stubs cannot be inlined
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:515)
</summary>
</member>
<member name="M:FSComp.SR.tcDllImportNotAllowed">
<summary>
 DLLImport bindings must be static members in a class or function definitions in a module
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1122)
</summary>
</member>
<member name="M:FSComp.SR.tcDelegatesCannotBeCurried">
<summary>
 Delegate specifications must not be curried types. Use &apos;typ * ... * typ -&gt; typ&apos; for multi-argument delegates, and &apos;typ -&gt; (typ -&gt; typ)&apos; for delegates returning function values.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:806)
</summary>
</member>
<member name="M:FSComp.SR.tcDelegateConstructorMustBePassed">
<summary>
 A delegate constructor must be passed a single function value
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:677)
</summary>
</member>
<member name="M:FSComp.SR.tcDefaultValueAttributeRequiresVal">
<summary>
 The &apos;DefaultValue&apos; attribute may only be used on &apos;val&apos; declarations
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:681)
</summary>
</member>
<member name="M:FSComp.SR.tcDefaultStructConstructorCall">
<summary>
 The default, zero-initializing constructor of a struct type may only be used if all the fields of the struct type admit default initialization
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:545)
</summary>
</member>
<member name="M:FSComp.SR.tcDefaultImplementationForInterfaceHasAlreadyBeenAdded">
<summary>
 A default implementation of this interface has already been added because the explicit implementation of the interface was not specified at the definition of the type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:761)
</summary>
</member>
<member name="M:FSComp.SR.tcDefaultImplementationAlreadyExists">
<summary>
 This method already has a default implementation
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:713)
</summary>
</member>
<member name="M:FSComp.SR.tcDefaultAmbiguous">
<summary>
 The method implemented by this default is ambiguous
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:714)
</summary>
</member>
<member name="M:FSComp.SR.tcDeclaredTypeParametersForExtensionDoNotMatchOriginal(System.String)">
<summary>
 The declared type parameters for this type extension do not match the declared type parameters on the original type &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:813)
</summary>
</member>
<member name="M:FSComp.SR.tcDeclarationElementNotPermittedInAugmentation">
<summary>
 This declaration element is not permitted in an augmentation
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:763)
</summary>
</member>
<member name="M:FSComp.SR.tcCustomOperationNotUsedCorrectly2(System.String,System.String)">
<summary>
 &apos;%s&apos; is not used correctly. Usage: %s. This is a custom operation in this query or computation expression.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1239)
</summary>
</member>
<member name="M:FSComp.SR.tcCustomOperationNotUsedCorrectly(System.String)">
<summary>
 &apos;%s&apos; is not used correctly. This is a custom operation in this query or computation expression.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1238)
</summary>
</member>
<member name="M:FSComp.SR.tcCustomOperationMayNotBeUsedInConjunctionWithNonSimpleLetBindings">
<summary>
 A custom operation may not be used in conjunction with a non-value or recursive &apos;let&apos; binding in another part of this computation expression
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1231)
</summary>
</member>
<member name="M:FSComp.SR.tcCustomOperationMayNotBeUsedHere">
<summary>
 A custom operation may not be used in conjunction with &apos;use&apos;, &apos;try/with&apos;, &apos;try/finally&apos;, &apos;if/then/else&apos; or &apos;match&apos; operators within this computation expression
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1232)
</summary>
</member>
<member name="M:FSComp.SR.tcCustomOperationMayNotBeOverloaded(System.String)">
<summary>
 The custom operation &apos;%s&apos; refers to a method which is overloaded. The implementations of custom operations may not be overloaded.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1233)
</summary>
</member>
<member name="M:FSComp.SR.tcCustomOperationInvalid(System.String)">
<summary>
 The definition of the custom operator &apos;%s&apos; does not use a valid combination of attribute flags
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1279)
</summary>
</member>
<member name="M:FSComp.SR.tcCustomOperationHasIncorrectArgCount(System.String,System.Int32,System.Int32)">
<summary>
 &apos;%s&apos; is used with an incorrect number of arguments. This is a custom operation in this query or computation expression. Expected %d argument(s), but given %d.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1246)
</summary>
</member>
<member name="M:FSComp.SR.tcCustomAttributeMustInvokeConstructor">
<summary>
 A custom attribute must invoke an object constructor
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:704)
</summary>
</member>
<member name="M:FSComp.SR.tcCustomAttributeMustBeReferenceType">
<summary>
 A custom attribute must be a reference type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:702)
</summary>
</member>
<member name="M:FSComp.SR.tcCustomAttributeArgumentMismatch">
<summary>
 The number of args for a custom attribute does not match the expected number of args for the attribute constructor
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:703)
</summary>
</member>
<member name="M:FSComp.SR.tcCouldNotFindIDisposable">
<summary>
 Couldn&apos;t find Dispose on IDisposable, or it was overloaded
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:546)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructorsIllegalForThisType">
<summary>
 Constructors cannot be defined for this type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:726)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructorsDisallowedInExceptionAugmentation">
<summary>
 Constructors cannot be specified in exception augmentations
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:724)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructorsCannotBeFirstClassValues">
<summary>
 Constructors must be applied to arguments and cannot be used as first-class values. If necessary use an anonymous function &apos;(fun arg1 ... argN -&gt; new Type(arg1,...,argN))&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:667)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructorRequiresCall(System.String)">
<summary>
 Constructors for the type &apos;%s&apos; must directly or indirectly call its implicit object constructor. Use a call to the implicit object constructor instead of a record expression.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:619)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructorRequiresArguments">
<summary>
 This object constructor requires arguments
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:638)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructorForInterfacesDoNotTakeArguments">
<summary>
 Constructor expressions for interfaces do not take arguments
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:637)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructorCannotHaveTypeParameters">
<summary>
 A constructor cannot have explicit type parameters. Consider using a static construction method instead.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:530)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructRequiresSequenceOrComputations">
<summary>
 This construct may only be used within sequence or computation expressions
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:606)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructRequiresListArrayOrSequence">
<summary>
 This construct may only be used within list, array and sequence expressions, e.g. expressions of the form &apos;seq { ... }&apos;, &apos;[ ... ]&apos; or &apos;[| ... |]&apos;. These use the syntax &apos;for ... in ... do ... yield...&apos; to generate elements
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:604)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructRequiresComputationExpressions">
<summary>
 This construct may only be used within computation expressions. To return a value from an ordinary function simply write the expression without &apos;return&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:605)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructRequiresComputationExpression">
<summary>
 This construct may only be used within computation expressions
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:607)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructIsAmbiguousInSequenceExpression">
<summary>
 This construct is ambiguous as part of a sequence expression. Nested expressions may be written using &apos;let _ = (...)&apos; and nested sequences using &apos;yield! seq {... }&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:650)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructIsAmbiguousInComputationExpression">
<summary>
 This construct is ambiguous as part of a computation expression. Nested expressions may be written using &apos;let _ = (...)&apos; and nested computations using &apos;let! res = builder { ... }&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:649)
</summary>
</member>
<member name="M:FSComp.SR.tcConstrainedTypeVariableCannotBeGeneralized">
<summary>
 One or more of the explicit class or function type variables for this binding could not be generalized, because they were constrained to other types
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:519)
</summary>
</member>
<member name="M:FSComp.SR.tcConditionalAttributeUsage">
<summary>
 Attribute &apos;System.Diagnostics.ConditionalAttribute&apos; is only valid on methods or attribute classes
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1114)
</summary>
</member>
<member name="M:FSComp.SR.tcConditionalAttributeRequiresMembers">
<summary>
 The &apos;ConditionalAttribute&apos; attribute may only be used on members
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:682)
</summary>
</member>
<member name="M:FSComp.SR.tcConcreteMembersIllegalInInterface">
<summary>
 Interfaces cannot contain definitions of concrete members. You may need to define a constructor on your type to indicate that the type is a class.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:723)
</summary>
</member>
<member name="M:FSComp.SR.tcCompiledNameAttributeMisused">
<summary>
 The &apos;CompiledName&apos; attribute cannot be used with this language element
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:612)
</summary>
</member>
<member name="M:FSComp.SR.tcCannotOverrideSealedMethod(System.String)">
<summary>
 Cannot override inherited member &apos;%s&apos; because it is sealed
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1219)
</summary>
</member>
<member name="M:FSComp.SR.tcCannotInheritFromVariableType">
<summary>
 Cannot inherit from a variable type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:610)
</summary>
</member>
<member name="M:FSComp.SR.tcCannotInheritFromSealedType">
<summary>
 Cannot inherit a sealed type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:801)
</summary>
</member>
<member name="M:FSComp.SR.tcCannotInheritFromInterfaceType">
<summary>
 Cannot inherit from interface type. Use interface ... with instead.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:802)
</summary>
</member>
<member name="M:FSComp.SR.tcCannotInheritFromErasedType">
<summary>
 Cannot inherit from erased provided type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1214)
</summary>
</member>
<member name="M:FSComp.SR.tcCannotCreateExtensionOfSealedType">
<summary>
 Cannot create an extension of a sealed type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:630)
</summary>
</member>
<member name="M:FSComp.SR.tcCannotCallAbstractBaseMember(System.String)">
<summary>
 Cannot call an abstract base member: &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1098)
</summary>
</member>
<member name="M:FSComp.SR.tcBindingCannotBeUseAndRec">
<summary>
 A binding cannot be marked both &apos;use&apos; and &apos;rec&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:678)
</summary>
</member>
<member name="M:FSComp.SR.tcBindMayNotBeUsedInQueries">
<summary>
 &apos;let!&apos;, &apos;use!&apos; and &apos;do!&apos; expressions may not be used in queries
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1291)
</summary>
</member>
<member name="M:FSComp.SR.tcBinaryOperatorRequiresVariable(System.String,System.String)">
<summary>
 &apos;%s&apos; must be followed by a variable name. Usage: %s.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1243)
</summary>
</member>
<member name="M:FSComp.SR.tcBinaryOperatorRequiresBody(System.String,System.String)">
<summary>
 &apos;%s&apos; must come after a &apos;for&apos; selection clause and be followed by the rest of the query. Syntax: ... %s ...
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1245)
</summary>
</member>
<member name="M:FSComp.SR.tcAutoPropertyRequiresImplicitConstructionSequence">
<summary>
 &apos;member val&apos; definitions are only permitted in types with a primary constructor. Consider adding arguments to your type definition, e.g. &apos;type X(args) = ...&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1281)
</summary>
</member>
<member name="M:FSComp.SR.tcAttributesOfTypeSpecifyMultipleKindsForType">
<summary>
 The attributes of this type specify multiple kinds for the type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:778)
</summary>
</member>
<member name="M:FSComp.SR.tcAttributesInvalidInPatterns">
<summary>
 Attributes are not allowed within patterns
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:541)
</summary>
</member>
<member name="M:FSComp.SR.tcAttributesAreNotPermittedOnLetBindings">
<summary>
 Attributes are not permitted on &apos;let&apos; bindings in expressions
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:680)
</summary>
</member>
<member name="M:FSComp.SR.tcAttributeIsNotValidForLanguageElementUseDo">
<summary>
 This attribute is not valid for use on this language element. Assembly attributes should be attached to a &apos;do ()&apos; declaration, if necessary within an F# module.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:697)
</summary>
</member>
<member name="M:FSComp.SR.tcAttributeIsNotValidForLanguageElement">
<summary>
 This attribute is not valid for use on this language element
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:698)
</summary>
</member>
<member name="M:FSComp.SR.tcAttributeExpressionsMustBeConstructorCalls">
<summary>
 Attribute expressions must be calls to object constructors
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:705)
</summary>
</member>
<member name="M:FSComp.SR.tcAttributeAutoOpenWasIgnored(System.String,System.String)">
<summary>
 The attribute &apos;AutoOpen(\&quot;%s\&quot;)&apos; in the assembly &apos;%s&apos; did not refer to a valid module or namespace in that assembly and has been ignored
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:825)
</summary>
</member>
<member name="M:FSComp.SR.tcAttribArgsDiffer(System.String)">
<summary>
 The attribute &apos;%s&apos; appears in both the implementation and the signature, but the attribute arguments differ. Only the attribute from the signature will be included in the compiled code.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1097)
</summary>
</member>
<member name="M:FSComp.SR.tcAtLeastOneOverrideIsInvalid">
<summary>
 At least one override did not correctly implement its corresponding abstract member
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:640)
</summary>
</member>
<member name="M:FSComp.SR.tcArgumentArityMismatchOneOverload(System.String,System.Int32)">
<summary>
 The member &apos;%s&apos; does not accept the correct number of arguments. One overload accepts %d arguments.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:626)
</summary>
</member>
<member name="M:FSComp.SR.tcArgumentArityMismatch(System.String,System.Int32)">
<summary>
 The member &apos;%s&apos; does not accept the correct number of arguments, %d arguments are expected
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:625)
</summary>
</member>
<member name="M:FSComp.SR.tcAnonymousUnitsOfMeasureCannotBeNested">
<summary>
 Anonymous unit-of-measure cannot be nested inside another unit-of-measure expression
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:570)
</summary>
</member>
<member name="M:FSComp.SR.tcAnonymousTypeInvalidInDeclaration">
<summary>
 Anonymous type variables are not permitted in this declaration
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:571)
</summary>
</member>
<member name="M:FSComp.SR.tcAllowNullTypesMayOnlyInheritFromAllowNullTypes">
<summary>
 Types with the &apos;AllowNullLiteral&apos; attribute may only inherit from or implement types which also allow the use of the null literal
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:786)
</summary>
</member>
<member name="M:FSComp.SR.tcAllImplementedInterfacesShouldBeDeclared">
<summary>
 All implemented interfaces should be declared on the initial declaration of the type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:760)
</summary>
</member>
<member name="M:FSComp.SR.tcAbstractTypeCannotBeInstantiated">
<summary>
 Instances of this type cannot be created since it has been marked abstract or not all methods have been given implementations. Consider using an object expression &apos;{ new ... with ... }&apos; instead.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:616)
</summary>
</member>
<member name="M:FSComp.SR.tcAbstractPropertyMissingGetOrSet(System.String)">
<summary>
 This property overrides or implements an abstract property but the abstract property doesn&apos;t have a corresponding %s
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:716)
</summary>
</member>
<member name="M:FSComp.SR.tcAbstractMembersIllegalInAugmentation">
<summary>
 Abstract members are not permitted in an augmentation - they must be defined as part of the type itself
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:709)
</summary>
</member>
<member name="M:FSComp.SR.tcAbbreviationsFordotNetExceptionsMustHaveMatchingObjectConstructor">
<summary>
 Abbreviations for Common IL exception types must have a matching object constructor
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:773)
</summary>
</member>
<member name="M:FSComp.SR.tcAbbreviationsFordotNetExceptionsCannotTakeArguments">
<summary>
 Abbreviations for Common IL exceptions cannot take arguments
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:771)
</summary>
</member>
<member name="M:FSComp.SR.tcAbbreviatedTypesCannotBeSealed">
<summary>
 Abbreviated types cannot be given the &apos;Sealed&apos; attribute
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:800)
</summary>
</member>
<member name="M:FSComp.SR.tastopsMaxArrayFour">
<summary>
 F# supports a maximum array rank of 4
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1286)
</summary>
</member>
<member name="M:FSComp.SR.tastValueMustBeLocalAndMutable">
<summary>
 A value must be mutable in order to mutate the contents or take the address of a value type, e.g. &apos;let mutable x = ...&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:83)
</summary>
</member>
<member name="M:FSComp.SR.tastValueHasBeenCopied">
<summary>
 The value has been copied to ensure the original is not mutated by this operation
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:85)
</summary>
</member>
<member name="M:FSComp.SR.tastValueDoesNotHaveSetterType">
<summary>
 This value does not have a valid property setter type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:79)
</summary>
</member>
<member name="M:FSComp.SR.tastUnexpectedDecodeOfInternalsVisibleToAttribute">
<summary>
 Unexpected decode of InternalsVisibleToAttribute
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:90)
</summary>
</member>
<member name="M:FSComp.SR.tastUnexpectedDecodeOfInterfaceDataVersionAttribute">
<summary>
 Unexpected decode of InterfaceDataVersionAttribute
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:91)
</summary>
</member>
<member name="M:FSComp.SR.tastUnexpectedDecodeOfAutoOpenAttribute">
<summary>
 Unexpected decode of AutoOpenAttribute
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:89)
</summary>
</member>
<member name="M:FSComp.SR.tastUnexpectedByRef">
<summary>
 Unexpected use of a byref-typed variable
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:82)
</summary>
</member>
<member name="M:FSComp.SR.tastUndefinedTyconItemUnionCase(System.String,System.String)">
<summary>
 The type %s did not contain the union case &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1090)
</summary>
</member>
<member name="M:FSComp.SR.tastUndefinedTyconItemField(System.String,System.String)">
<summary>
 The type %s did not contain the field &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1089)
</summary>
</member>
<member name="M:FSComp.SR.tastUndefinedItemRefVal(System.String,System.String,System.String)">
<summary>
 The module/namespace &apos;%s&apos; from compilation unit &apos;%s&apos; did not contain the val &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1092)
</summary>
</member>
<member name="M:FSComp.SR.tastUndefinedItemRefModuleNamespaceType(System.String,System.String,System.String)">
<summary>
 The module/namespace &apos;%s&apos; from compilation unit &apos;%s&apos; did not contain the namespace, module or type &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1093)
</summary>
</member>
<member name="M:FSComp.SR.tastUndefinedItemRefModuleNamespace(System.String,System.String,System.String)">
<summary>
 The module/namespace &apos;%s&apos; from compilation unit &apos;%s&apos; did not contain the module/namespace &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1091)
</summary>
</member>
<member name="M:FSComp.SR.tastTypeOrModuleNotConcrete(System.String)">
<summary>
 The type/module &apos;%s&apos; is not a concrete module or type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:69)
</summary>
</member>
<member name="M:FSComp.SR.tastTypeHasAssemblyCodeRepresentation(System.String)">
<summary>
 The type &apos;%s&apos; has an inline assembly code representation
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:70)
</summary>
</member>
<member name="M:FSComp.SR.tastTwoModulesWithSameNameInAssembly(System.String)">
<summary>
 Two modules named &apos;%s&apos; occur in two parts of this assembly
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:72)
</summary>
</member>
<member name="M:FSComp.SR.tastRecursiveValuesMayNotBeInConstructionOfTuple">
<summary>
 Recursively defined values cannot appear directly as part of the construction of a tuple value within a recursive binding
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:86)
</summary>
</member>
<member name="M:FSComp.SR.tastRecursiveValuesMayNotBeAssignedToNonMutableField(System.String,System.String)">
<summary>
 Recursive values cannot be directly assigned to the non-mutable field &apos;%s&apos; of the type &apos;%s&apos; within a recursive binding. Consider using a mutable field instead.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:88)
</summary>
</member>
<member name="M:FSComp.SR.tastRecursiveValuesMayNotAppearInConstructionOfType(System.String)">
<summary>
 Recursive values cannot appear directly as a construction of the type &apos;%s&apos; within a recursive binding. This feature has been removed from the F# language. Consider using a record instead.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:87)
</summary>
</member>
<member name="M:FSComp.SR.tastNotAConstantExpression">
<summary>
 This is not a valid constant expression or custom attribute value
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:93)
</summary>
</member>
<member name="M:FSComp.SR.tastNamespaceAndModuleWithSameNameInAssembly(System.String)">
<summary>
 A namespace and a module named &apos;%s&apos; both occur in two parts of this assembly
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:71)
</summary>
</member>
<member name="M:FSComp.SR.tastInvalidMutationOfConstant">
<summary>
 Invalid mutation of a constant expression. Consider copying the expression to a mutable local, e.g. &apos;let mutable x = ...&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:84)
</summary>
</member>
<member name="M:FSComp.SR.tastInvalidMemberSignature">
<summary>
 Invalid member signature encountered because of an earlier error
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:78)
</summary>
</member>
<member name="M:FSComp.SR.tastInvalidFormForPropertySetter">
<summary>
 Invalid form for a property setter. At least one argument is required.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:81)
</summary>
</member>
<member name="M:FSComp.SR.tastInvalidFormForPropertyGetter">
<summary>
 Invalid form for a property getter. At least one &apos;()&apos; argument is required when using the explicit syntax.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:80)
</summary>
</member>
<member name="M:FSComp.SR.tastInvalidAddressOfMutableAcrossAssemblyBoundary">
<summary>
 This operation accesses a mutable top-level value defined in another assembly in an unsupported way. The value cannot be accessed through its address. Consider copying the expression to a mutable local, e.g. &apos;let mutable x = ...&apos;, and if necessary assigning the value back after the completion of the operation
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1085)
</summary>
</member>
<member name="M:FSComp.SR.tastDuplicateTypeDefinitionInAssembly(System.String,System.String)">
<summary>
 Two type definitions named &apos;%s&apos; occur in namespace &apos;%s&apos; in two parts of this assembly
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:73)
</summary>
</member>
<member name="M:FSComp.SR.tastConstantExpressionOverflow">
<summary>
 This literal expression or attribute argument results in an arithmetic overflow.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1330)
</summary>
</member>
<member name="M:FSComp.SR.tastConflictingModuleAndTypeDefinitionInAssembly(System.String,System.String)">
<summary>
 A module and a type definition named &apos;%s&apos; occur in namespace &apos;%s&apos; in two parts of this assembly
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:74)
</summary>
</member>
<member name="M:FSComp.SR.tastActivePatternsLimitedToSeven">
<summary>
 Active patterns cannot return more than 7 possibilities
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:92)
</summary>
</member>
<member name="M:FSComp.SR.structOrClassFieldIsNotAccessible(System.String)">
<summary>
 The struct or class field &apos;%s&apos; is not accessible from this code location
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:967)
</summary>
</member>
<member name="P:FSComp.SR.SwallowResourceText(System.Boolean)">
<summary>
 If set to true, then all error messages will just return the filled &apos;holes&apos; delimited by &apos;,,,&apos;s - this is for language-neutral testing (e.g. localization-invariant baselines).
</summary>
</member>
<member name="M:FSComp.SR.recursiveClassHierarchy(System.String)">
<summary>
 Recursive class hierarchy in type &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:959)
</summary>
</member>
<member name="M:FSComp.SR.pickleErrorReadingWritingMetadata(System.String,System.String)">
<summary>
 Error reading/writing metadata for the F# compiled DLL &apos;%s&apos;. Was the DLL compiled with an earlier version of the F# compiler? (error: &apos;%s&apos;).
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:65)
</summary>
</member>
<member name="M:FSComp.SR.pathIsInvalid(System.String)">
<summary>
 Problem with filename &apos;%s&apos;: Illegal characters in path.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1161)
</summary>
</member>
<member name="M:FSComp.SR.patcPartialActivePatternsGenerateOneResult">
<summary>
 Partial active patterns may only generate one result
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:986)
</summary>
</member>
<member name="M:FSComp.SR.patcMissingVariable(System.String)">
<summary>
 Missing variable &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:985)
</summary>
</member>
<member name="M:FSComp.SR.parsWhileDoExpected">
<summary>
 Missing &apos;do&apos; in &apos;while&apos; expression. Expected &apos;while &lt;expr&gt; do &lt;expr&gt;&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1269)
</summary>
</member>
<member name="M:FSComp.SR.parsVisibilityIllegalOnInherit">
<summary>
 Accessibility modifiers are not permitted on an &apos;inherits&apos; declaration
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:435)
</summary>
</member>
<member name="M:FSComp.SR.parsVisibilityDeclarationsShouldComePriorToIdentifier">
<summary>
 Accessibility modifiers should come immediately prior to the identifier naming a construct
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:406)
</summary>
</member>
<member name="M:FSComp.SR.parsUseBindingsIllegalInModules">
<summary>
 &apos;use&apos; bindings are not permitted in modules and are treated as &apos;let&apos; bindings
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:399)
</summary>
</member>
<member name="M:FSComp.SR.parsUseBindingsIllegalInImplicitClassConstructors">
<summary>
 &apos;use&apos; bindings are not permitted in primary constructors
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:398)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedWith">
<summary>
 Unmatched &apos;with&apos; or badly formatted &apos;with&apos; block
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:422)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedUseBang">
<summary>
 Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the &apos;use!&apos; keyword.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1267)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedUse">
<summary>
 Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the &apos;use&apos; keyword.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1268)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedParen">
<summary>
 Unmatched &apos;(&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:448)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedLetBang">
<summary>
 Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the &apos;let!&apos; keyword.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1266)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedLet">
<summary>
 Incomplete value or function definition. If this is in an expression, the body of the expression must be indented to the same column as the &apos;let&apos; keyword.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1265)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedLBrackLess">
<summary>
 Unmatched &apos;[&lt;&apos;. Expected closing &apos;&gt;]&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1249)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedClassInterfaceOrStruct">
<summary>
 Unmatched &apos;class&apos;, &apos;interface&apos; or &apos;struct&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:420)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedBracketBar">
<summary>
 Unmatched &apos;[|&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:464)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedBracket">
<summary>
 Unmatched &apos;[&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:459)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedBrace">
<summary>
 Unmatched &apos;{&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:465)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedBeginOrStruct">
<summary>
 Unmatched &apos;begin&apos; or &apos;struct&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:413)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedBegin">
<summary>
 Unmatched &apos;begin&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:425)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatched(System.String)">
<summary>
 Unmatched &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:463)
</summary>
</member>
<member name="M:FSComp.SR.parsUnionCasesCannotHaveVisibilityDeclarations">
<summary>
 Accessibility modifiers are not permitted on union cases. Use &apos;type U = internal ...&apos; or &apos;type U = private ...&apos; to give an accessibility to the whole representation.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:443)
</summary>
</member>
<member name="M:FSComp.SR.parsUnfinishedExpression(System.String)">
<summary>
 Unexpected token &apos;%s&apos; or incomplete expression
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1307)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedVisibilityDeclaration">
<summary>
 Accessibility modifiers are not permitted here
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:404)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedTypeParameter">
<summary>
 Syntax error: unexpected type parameter specification
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:475)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedSemicolon">
<summary>
 A semicolon is not expected at this point
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:402)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedQuotationOperatorInTypeAliasDidYouMeanVerbatimString">
<summary>
 Unexpected quotation operator &apos;&lt;@&apos; in type definition. If you intend to pass a verbatim string as a static argument to a type provider, put a space between the &apos;&lt;&apos; and &apos;@&apos; characters.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1137)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedOperatorForUnitOfMeasure">
<summary>
 Unexpected infix operator in unit-of-measure expression. Legal operators are &apos;*&apos;, &apos;/&apos; and &apos;^&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:473)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedIntegerLiteralForUnitOfMeasure">
<summary>
 Unexpected integer literal in unit-of-measure expression
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:474)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedInfixOperator">
<summary>
 Unexpected infix operator in type expression
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:470)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedIdentifier(System.String)">
<summary>
 Unexpected identifier: &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:442)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileWith">
<summary>
 Unexpected end of input in &apos;match&apos; or &apos;try&apos; expression
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1254)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileWhile">
<summary>
 Unexpected end of input in &apos;while&apos; expression. Expected &apos;while &lt;expr&gt; do &lt;expr&gt;&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1252)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileTypeSignature">
<summary>
 Unexpected end of input in type signature
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1259)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileTypeDefinition">
<summary>
 Unexpected end of input in type definition
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1260)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileTypeArgs">
<summary>
 Unexpected end of input in type arguments
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1258)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileTry">
<summary>
 Unexpected end of input in &apos;try&apos; expression. Expected &apos;try &lt;expr&gt; with &lt;rules&gt;&apos; or &apos;try &lt;expr&gt; finally &lt;expr&gt;&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1251)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileThen">
<summary>
 Unexpected end of input in &apos;then&apos; branch of conditional expression. Expected &apos;if &lt;expr&gt; then &lt;expr&gt;&apos; or &apos;if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1255)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileObjectMembers">
<summary>
 Unexpected end of input in object members
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1261)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileMatch">
<summary>
 Unexpected end of input in &apos;match&apos; expression. Expected &apos;match &lt;expr&gt; with | &lt;pat&gt; -&gt; &lt;expr&gt; | &lt;pat&gt; -&gt; &lt;expr&gt; ...&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1250)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileFunBody">
<summary>
 Unexpected end of input in body of lambda expression. Expected &apos;fun &lt;pat&gt; ... &lt;pat&gt; -&gt; &lt;expr&gt;&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1257)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileFor">
<summary>
 Unexpected end of input in &apos;for&apos; expression. Expected &apos;for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1253)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileExpression">
<summary>
 Unexpected end of input in expression
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1263)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileElse">
<summary>
 Unexpected end of input in &apos;else&apos; branch of conditional expression. Expected &apos;if &lt;expr&gt; then &lt;expr&gt;&apos; or &apos;if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1256)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileDefinition">
<summary>
 Unexpected end of input in value, function or member definition
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1262)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFile">
<summary>
 Unexpected end of input
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:403)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEmptyModuleDefn">
<summary>
 Unexpected empty type moduleDefn list
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:415)
</summary>
</member>
<member name="M:FSComp.SR.parsUnderscoreInvalidFieldName">
<summary>
 &apos;_&apos; cannot be used as field name
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1322)
</summary>
</member>
<member name="M:FSComp.SR.parsUnClosedBlockInHashLight">
<summary>
 Unclosed block
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:412)
</summary>
</member>
<member name="M:FSComp.SR.parsTypeNameCannotBeEmpty">
<summary>
 Type name cannot be empty.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1310)
</summary>
</member>
<member name="M:FSComp.SR.parsTypeAnnotationsOnGetSet">
<summary>
 Type annotations on property getters and setters must be given after the &apos;get()&apos; or &apos;set(v)&apos;, e.g. &apos;with get() : string = ...&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:428)
</summary>
</member>
<member name="M:FSComp.SR.parsTypeAbbreviationsCannotHaveVisibilityDeclarations">
<summary>
 Accessibility modifiers are not permitted in this position for type abbreviations
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:438)
</summary>
</member>
<member name="M:FSComp.SR.parsSyntaxModuleStructEndDeprecated">
<summary>
 The syntax &apos;module ... = struct .. end&apos; is not used in F# code. Consider using &apos;module ... = begin .. end&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:479)
</summary>
</member>
<member name="M:FSComp.SR.parsSyntaxModuleSigEndDeprecated">
<summary>
 The syntax &apos;module ... : sig .. end&apos; is not used in F# code. Consider using &apos;module ... = begin .. end&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:480)
</summary>
</member>
<member name="M:FSComp.SR.parsSyntaxErrorInLabeledType">
<summary>
 Syntax error in labelled type argument
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:469)
</summary>
</member>
<member name="M:FSComp.SR.parsSyntaxError">
<summary>
 Syntax error
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:418)
</summary>
</member>
<member name="M:FSComp.SR.parsSuccessivePatternsShouldBeSpacedOrTupled">
<summary>
 Successive patterns should be separated by spaces or tupled
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:449)
</summary>
</member>
<member name="M:FSComp.SR.parsSuccessiveArgsShouldBeSpacedOrTupled">
<summary>
 Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:458)
</summary>
</member>
<member name="M:FSComp.SR.parsSetterAtMostTwoArguments">
<summary>
 A setter property may have at most two argument groups
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1082)
</summary>
</member>
<member name="M:FSComp.SR.parsSetSyntax">
<summary>
 Property setters must be defined using &apos;set value = &apos;, &apos;set idx value = &apos; or &apos;set (idx1,...,idxN) value = ... &apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:431)
</summary>
</member>
<member name="M:FSComp.SR.parsRecordFieldsCannotHaveVisibilityDeclarations">
<summary>
 Accessibility modifiers are not permitted on record fields. Use &apos;type R = internal ...&apos; or &apos;type R = private ...&apos; to give an accessibility to the whole representation.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:446)
</summary>
</member>
<member name="M:FSComp.SR.parsParenFormIsForML">
<summary>
 In F# code you may use &apos;expr.[expr]&apos;. A type annotation may be required to indicate the first expression is an array
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:461)
</summary>
</member>
<member name="M:FSComp.SR.parsOnlyOneWithAugmentationAllowed">
<summary>
 At most one &apos;with&apos; augmentation is permitted
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:401)
</summary>
</member>
<member name="M:FSComp.SR.parsOnlyHashDirectivesAllowed">
<summary>
 Only &apos;#&apos; compiler directives may occur prior to the first &apos;namespace&apos; declaration
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:405)
</summary>
</member>
<member name="M:FSComp.SR.parsOnlyClassCanTakeValueArguments">
<summary>
 Only class types may take value arguments
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:424)
</summary>
</member>
<member name="M:FSComp.SR.parsNonAtomicType">
<summary>
 The use of the type syntax &apos;int C&apos; and &apos;C  &lt;int&gt;&apos; is not permitted here. Consider adjusting this type to be written in the form &apos;C&lt;int&gt;&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1088)
</summary>
</member>
<member name="M:FSComp.SR.parsNonAdjacentTypars">
<summary>
 Type parameters must be placed directly adjacent to the type name, e.g. \&quot;type C&lt;&apos;T&gt;\&quot;, not     type \&quot;C   &lt;&apos;T&gt;\&quot;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1086)
</summary>
</member>
<member name="M:FSComp.SR.parsNonAdjacentTyargs">
<summary>
 Type arguments must be placed directly adjacent to the type name, e.g. \&quot;C&lt;&apos;T&gt;\&quot;, not \&quot;C  &lt;&apos;T&gt;\&quot;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1087)
</summary>
</member>
<member name="M:FSComp.SR.parsNoMatchingInForLet">
<summary>
 No matching &apos;in&apos; found for this &apos;let&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:450)
</summary>
</member>
<member name="M:FSComp.SR.parsNoHashEndIfFound">
<summary>
 No #endif found for #if or #else
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:396)
</summary>
</member>
<member name="M:FSComp.SR.parsNoEqualShouldFollowNamespace">
<summary>
 No &apos;=&apos; symbol should follow a &apos;namespace&apos; declaration
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:478)
</summary>
</member>
<member name="M:FSComp.SR.parsNamespaceOrModuleNotBoth">
<summary>
 Files should begin with either a namespace or module declaration, e.g. &apos;namespace SomeNamespace.SubNamespace&apos; or &apos;module SomeNamespace.SomeModule&apos;, but not both. To define a module within a namespace use &apos;module SomeModule = ...&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:407)
</summary>
</member>
<member name="M:FSComp.SR.parsMutableOnAutoPropertyShouldBeGetSetNotJustSet">
<summary>
 To indicate that this property can be set, use &apos;member val PropertyName = expr with get,set&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1283)
</summary>
</member>
<member name="M:FSComp.SR.parsMutableOnAutoPropertyShouldBeGetSet">
<summary>
 Property definitions may not be declared mutable. To indicate that this property can be set, use &apos;member val PropertyName = expr with get,set&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1282)
</summary>
</member>
<member name="M:FSComp.SR.parsMultipleAccessibilitiesForGetSet">
<summary>
 Multiple accessibilities given for property getter or setter
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:430)
</summary>
</member>
<member name="M:FSComp.SR.parsMultiArgumentGenericTypeFormDeprecated">
<summary>
 The syntax &apos;(typ,...,typ) ident&apos; is not used in F# code. Consider using &apos;ident&lt;typ,...,typ&gt;&apos; instead
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:471)
</summary>
</member>
<member name="M:FSComp.SR.parsModuleDefnMustBeSimpleName">
<summary>
 A module name must be a simple name, not a path
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:414)
</summary>
</member>
<member name="M:FSComp.SR.parsModuleAbbreviationMustBeSimpleName">
<summary>
 A module abbreviation must be a simple name, not a path
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:408)
</summary>
</member>
<member name="M:FSComp.SR.parsMissingTypeArgs">
<summary>
 Expected type argument or static argument
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1135)
</summary>
</member>
<member name="M:FSComp.SR.parsMissingQualificationAfterDot">
<summary>
 Missing qualification after &apos;.&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:460)
</summary>
</member>
<member name="M:FSComp.SR.parsMissingGreaterThan">
<summary>
 Unmatched &apos;&lt;&apos;. Expected closing &apos;&gt;&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1136)
</summary>
</member>
<member name="M:FSComp.SR.parsMissingFunctionBody">
<summary>
 Missing function body
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:468)
</summary>
</member>
<member name="M:FSComp.SR.parsMismatchedQuote(System.String)">
<summary>
 Mismatched quotation, beginning with &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:462)
</summary>
</member>
<member name="M:FSComp.SR.parsMismatchedQuotationName(System.String)">
<summary>
 Mismatched quotation operator name, beginning with &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:476)
</summary>
</member>
<member name="M:FSComp.SR.parsMemberIllegalInObjectImplementation">
<summary>
 This member is not permitted in an object implementation
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:467)
</summary>
</member>
<member name="M:FSComp.SR.parsLetAndForNonRecBindings">
<summary>
 The declaration form &apos;let ... and ...&apos; for non-recursive bindings is not used in F# code. Consider using a sequence of &apos;let&apos; bindings
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:447)
</summary>
</member>
<member name="M:FSComp.SR.parsInvalidProperty">
<summary>
 Invalid property getter or setter
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1083)
</summary>
</member>
<member name="M:FSComp.SR.parsInvalidPrefixOperatorDefinition">
<summary>
 Invalid operator definition. Prefix operator definitions must use a valid prefix operator name.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1107)
</summary>
</member>
<member name="M:FSComp.SR.parsInvalidPrefixOperator">
<summary>
 Invalid prefix operator
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1106)
</summary>
</member>
<member name="M:FSComp.SR.parsInvalidLiteralInType">
<summary>
 Invalid literal in type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:472)
</summary>
</member>
<member name="M:FSComp.SR.parsInvalidDeclarationSyntax">
<summary>
 Invalid declaration syntax
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:426)
</summary>
</member>
<member name="M:FSComp.SR.parsInterfacesHaveSameVisibilityAsEnclosingType">
<summary>
 Interfaces always have the same visibility as the enclosing type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:432)
</summary>
</member>
<member name="M:FSComp.SR.parsIntegerForLoopRequiresSimpleIdentifier">
<summary>
 An integer for loop must use a simple identifier
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:400)
</summary>
</member>
<member name="M:FSComp.SR.parsInlineAssemblyCannotHaveVisibilityDeclarations">
<summary>
 Accessibility modifiers are not permitted on inline assembly code types
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:441)
</summary>
</member>
<member name="M:FSComp.SR.parsInheritDeclarationsCannotHaveAsBindings">
<summary>
 &apos;inherit&apos; declarations cannot have &apos;as&apos; bindings. To access members of the base class when overriding a method, the syntax &apos;base.SomeMember&apos; may be used; &apos;base&apos; is a keyword. Remove this &apos;as&apos; binding.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:436)
</summary>
</member>
<member name="M:FSComp.SR.parsIndexerPropertyRequiresAtLeastOneArgument">
<summary>
 An indexer property must be given at least one argument
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1084)
</summary>
</member>
<member name="M:FSComp.SR.parsIncompleteIf">
<summary>
 Incomplete conditional. Expected &apos;if &lt;expr&gt; then &lt;expr&gt;&apos; or &apos;if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:453)
</summary>
</member>
<member name="M:FSComp.SR.parsInOrEqualExpected">
<summary>
 &apos;in&apos; or &apos;=&apos; expected
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:456)
</summary>
</member>
<member name="M:FSComp.SR.parsIllegalMemberVarInObjectImplementation">
<summary>
 Neither &apos;member val&apos; nor &apos;override val&apos; definitions are permitted in object expressions.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1320)
</summary>
</member>
<member name="M:FSComp.SR.parsIgnoreVisibilityOnModuleAbbreviationAlwaysPrivate">
<summary>
 Ignoring visibility attribute on module abbreviation. Module abbreviations are always private.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:411)
</summary>
</member>
<member name="M:FSComp.SR.parsIgnoreAttributesOnModuleAbbreviationAlwaysPrivate">
<summary>
 Ignoring accessibility attribute on module abbreviation. Module abbreviations are always private.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:410)
</summary>
</member>
<member name="M:FSComp.SR.parsIgnoreAttributesOnModuleAbbreviation">
<summary>
 Ignoring attributes on module abbreviation
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:409)
</summary>
</member>
<member name="M:FSComp.SR.parsIdentifierExpected">
<summary>
 Identifier expected
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:455)
</summary>
</member>
<member name="M:FSComp.SR.parsGetterMustHaveAtLeastOneArgument">
<summary>
 A getter property is expected to be a function, e.g. &apos;get() = ...&apos; or &apos;get(index) = ...&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:429)
</summary>
</member>
<member name="M:FSComp.SR.parsGetterAtMostOneArgument">
<summary>
 A getter property may have at most one argument group
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1081)
</summary>
</member>
<member name="M:FSComp.SR.parsGetOrSetRequired">
<summary>
 &apos;get&apos;, &apos;set&apos; or &apos;get,set&apos; required
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:423)
</summary>
</member>
<member name="M:FSComp.SR.parsGetAndOrSetRequired">
<summary>
 &apos;get&apos; and/or &apos;set&apos; required
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:427)
</summary>
</member>
<member name="M:FSComp.SR.parsForDoExpected">
<summary>
 Missing &apos;do&apos; in &apos;for&apos; expression. Expected &apos;for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1270)
</summary>
</member>
<member name="M:FSComp.SR.parsFieldBinding">
<summary>
 Field bindings must have the form &apos;id = expr;&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:466)
</summary>
</member>
<member name="M:FSComp.SR.parsExpectedTypeAfterToken">
<summary>
 Expected a type after this point
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1248)
</summary>
</member>
<member name="M:FSComp.SR.parsExpectedStatementAfterLet(System.String)">
<summary>
 Block following this &apos;%s&apos; is unfinished. Expect an expression.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:452)
</summary>
</member>
<member name="M:FSComp.SR.parsExpectedNameAfterToken">
<summary>
 Unexpected end of type. Expected a name after this point.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1264)
</summary>
</member>
<member name="M:FSComp.SR.parsExpectedExpressionAfterToken">
<summary>
 Expected an expression after this point
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1247)
</summary>
</member>
<member name="M:FSComp.SR.parsErrorParsingAsOperatorName">
<summary>
 Attempted to parse this as an operator name, but failed
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1138)
</summary>
</member>
<member name="M:FSComp.SR.parsErrorInReturnForLetIncorrectIndentation">
<summary>
 Error in the return expression for this &apos;let&apos;. Possible incorrect indentation.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:451)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInVerbatimStringInComment">
<summary>
 End of file in verbatim string embedded in comment begun at or before here
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:393)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInVerbatimString">
<summary>
 End of file in verbatim string begun at or before here
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:390)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInTripleQuoteStringInComment">
<summary>
 End of file in triple-quote string embedded in comment begun at or before here
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1133)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInTripleQuoteString">
<summary>
 End of file in triple-quote string begun at or before here
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1132)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInStringInComment">
<summary>
 End of file in string embedded in comment begun at or before here
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:392)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInString">
<summary>
 End of file in string begun at or before here
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:389)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInIfOcaml">
<summary>
 End of file in IF-OCAML section begun at or before here
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:394)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInHashIf">
<summary>
 End of file in #if section begun at or after here
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:388)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInDirective">
<summary>
 End of file in directive begun at or before here
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:395)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInComment">
<summary>
 End of file in comment begun at or before here
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:391)
</summary>
</member>
<member name="M:FSComp.SR.parsEnumTypesCannotHaveVisibilityDeclarations">
<summary>
 Accessibility modifiers are not permitted in this position for enum types
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:439)
</summary>
</member>
<member name="M:FSComp.SR.parsEnumFieldsCannotHaveVisibilityDeclarations">
<summary>
 Accessibility modifiers are not permitted on enumeration fields
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:444)
</summary>
</member>
<member name="M:FSComp.SR.parsEmptyTypeDefinition">
<summary>
 A type definition requires one or more members or other declarations. If you intend to define an empty class, struct or interface, then use &apos;type ... = class end&apos;, &apos;interface end&apos; or &apos;struct end&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:421)
</summary>
</member>
<member name="M:FSComp.SR.parsDoCannotHaveVisibilityDeclarations">
<summary>
 Accessibility modifiers are not permitted on &apos;do&apos; bindings
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:387)
</summary>
</member>
<member name="M:FSComp.SR.parsConsiderUsingSeparateRecordType">
<summary>
 Consider using a separate record type instead
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:445)
</summary>
</member>
<member name="M:FSComp.SR.parsAugmentationsIllegalOnDelegateType">
<summary>
 Augmentations are not permitted on delegate type moduleDefns
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:419)
</summary>
</member>
<member name="M:FSComp.SR.parsAttributesMustComeBeforeVal">
<summary>
 Attributes should be placed before &apos;val&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:416)
</summary>
</member>
<member name="M:FSComp.SR.parsAttributesIllegalOnInherit">
<summary>
 Attributes are not permitted on &apos;inherit&apos; declarations
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:434)
</summary>
</member>
<member name="M:FSComp.SR.parsAttributesIllegalHere">
<summary>
 Attributes are not allowed here
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:437)
</summary>
</member>
<member name="M:FSComp.SR.parsAttributesIgnored">
<summary>
 Attributes have been ignored in this construct
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:397)
</summary>
</member>
<member name="M:FSComp.SR.parsAttributesAreNotPermittedOnInterfaceImplementations">
<summary>
 Attributes are not permitted on interface implementations
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:417)
</summary>
</member>
<member name="M:FSComp.SR.parsAttributeOnIncompleteCode">
<summary>
 Cannot find code target for this attribute, possibly because the code after the attribute is incomplete.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1309)
</summary>
</member>
<member name="M:FSComp.SR.parsAssertIsNotFirstClassValue">
<summary>
 &apos;assert&apos; may not be used as a first class value. Use &apos;assert &lt;expr&gt;&apos; instead.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:454)
</summary>
</member>
<member name="M:FSComp.SR.parsArrowUseIsLimited">
<summary>
 The use of &apos;-&gt;&apos; in sequence and computation expressions is limited to the form &apos;for pat in expr -&gt; expr&apos;. Use the syntax &apos;for ... in ... do ... yield...&apos; to generate elements in more complex sequence expressions.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:457)
</summary>
</member>
<member name="M:FSComp.SR.parsAllEnumFieldsRequireValues">
<summary>
 All enum fields must be given values
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:440)
</summary>
</member>
<member name="M:FSComp.SR.parsActivePatternCaseMustBeginWithUpperCase">
<summary>
 Active pattern case identifiers must begin with an uppercase letter
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:477)
</summary>
</member>
<member name="M:FSComp.SR.parsAccessibilityModsIllegalForAbstract">
<summary>
 Accessibility modifiers are not allowed on this member. Abstract slots always have the same visibility as the enclosing type.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:433)
</summary>
</member>
<member name="M:FSComp.SR.optsWriteXml">
<summary>
 Write the xmldoc of the assembly to the given file
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:861)
</summary>
</member>
<member name="M:FSComp.SR.optsWin32res">
<summary>
 Specify a Win32 resource file (.res)
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:869)
</summary>
</member>
<member name="M:FSComp.SR.optsWin32manifest">
<summary>
 Specify a Win32 manifest file
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:870)
</summary>
</member>
<member name="M:FSComp.SR.optsWarnaserrorPM">
<summary>
 Report all warnings as errors
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:879)
</summary>
</member>
<member name="M:FSComp.SR.optsWarnaserror">
<summary>
 Report specific warnings as errors
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:880)
</summary>
</member>
<member name="M:FSComp.SR.optsWarnOn">
<summary>
 Enable specific warnings that may be off by default
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:883)
</summary>
</member>
<member name="M:FSComp.SR.optsWarn">
<summary>
 Set a warning level (0-5)
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:881)
</summary>
</member>
<member name="M:FSComp.SR.optsUtf8output">
<summary>
 Output messages in UTF-8 encoding
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:890)
</summary>
</member>
<member name="M:FSComp.SR.optsUseHighEntropyVA">
<summary>
 Enable high-entropy ASLR
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:921)
</summary>
</member>
<member name="M:FSComp.SR.optsUnrecognizedTarget(System.String)">
<summary>
 Unrecognized target &apos;%s&apos;, expected &apos;exe&apos;, &apos;winexe&apos;, &apos;library&apos; or &apos;module&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:900)
</summary>
</member>
<member name="M:FSComp.SR.optsUnrecognizedDebugType(System.String)">
<summary>
 Unrecognized debug type &apos;%s&apos;, expected &apos;pdbonly&apos; or &apos;full&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:901)
</summary>
</member>
<member name="M:FSComp.SR.optsUnknownPlatform(System.String)">
<summary>
 Unrecognized platform &apos;%s&apos;, valid values are &apos;x86&apos;, &apos;x64&apos;, &apos;Itanium&apos;, &apos;anycpu32bitpreferred&apos;, and &apos;anycpu&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:915)
</summary>
</member>
<member name="M:FSComp.SR.optsUnknownArgumentToTheTestSwitch(System.String)">
<summary>
 Unknown --test argument: &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:914)
</summary>
</member>
<member name="M:FSComp.SR.optsTargetProfile">
<summary>
 Specify target framework profile of this assembly. Valid values are mscorlib or netcore. Default - mscorlib
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:923)
</summary>
</member>
<member name="M:FSComp.SR.optsTailcalls">
<summary>
 Enable or disable tailcalls
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:877)
</summary>
</member>
<member name="M:FSComp.SR.optsSubSystemVersion">
<summary>
 Specify subsystem version of this assembly
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:922)
</summary>
</member>
<member name="M:FSComp.SR.optsStrongKeyFile">
<summary>
 Specify a strong name key file
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:862)
</summary>
</member>
<member name="M:FSComp.SR.optsStrongKeyContainer">
<summary>
 Specify a strong name key container
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:863)
</summary>
</member>
<member name="M:FSComp.SR.optsStaticlink">
<summary>
 Statically link the given assembly and all referenced DLLs that depend on this assembly. Use an assembly name e.g. mylib, not a DLL name.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:896)
</summary>
</member>
<member name="M:FSComp.SR.optsStandalone">
<summary>
 Statically link the F# library and all referenced DLLs that depend on it into the assembly being generated
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:895)
</summary>
</member>
<member name="M:FSComp.SR.optsSimpleresolution">
<summary>
 Resolve assembly references using directory-based rules rather than MSBuild resolution
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:899)
</summary>
</member>
<member name="M:FSComp.SR.optsSig">
<summary>
 Print the inferred interface of the assembly to a file
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:867)
</summary>
</member>
<member name="M:FSComp.SR.optsShortFormOf(System.String)">
<summary>
 Short form of &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:903)
</summary>
</member>
<member name="M:FSComp.SR.optsResource">
<summary>
 Embed the specified managed resource
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:872)
</summary>
</member>
<member name="M:FSComp.SR.optsResident">
<summary>
 Use a resident background compilation service to improve compiler startup times.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:897)
</summary>
</member>
<member name="M:FSComp.SR.optsReference">
<summary>
 Reference an assembly (Short form: -r)
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:868)
</summary>
</member>
<member name="M:FSComp.SR.optsProblemWithCodepage(System.Int32,System.String)">
<summary>
 Problem with codepage &apos;%d&apos;: %s
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:853)
</summary>
</member>
<member name="M:FSComp.SR.optsPlatform">
<summary>
 Limit which platforms this code can run on: x86, Itanium, x64, anycpu32bitpreferred, or anycpu. The default is anycpu.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:864)
</summary>
</member>
<member name="M:FSComp.SR.optsPdb">
<summary>
 Name the output debug file
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:898)
</summary>
</member>
<member name="M:FSComp.SR.optsOptimize">
<summary>
 Enable optimizations (Short form: -O)
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:876)
</summary>
</member>
<member name="M:FSComp.SR.optsNowin32manifest">
<summary>
 Do not include the default Win32 manifest
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:871)
</summary>
</member>
<member name="M:FSComp.SR.optsNowarn">
<summary>
 Disable specific warning messages
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:882)
</summary>
</member>
<member name="M:FSComp.SR.optsNologo">
<summary>
 Suppress compiler copyright message
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:887)
</summary>
</member>
<member name="M:FSComp.SR.optsNoframework">
<summary>
 Do not reference the default CLI assemblies by default
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:894)
</summary>
</member>
<member name="M:FSComp.SR.optsNoOpt">
<summary>
 Only include optimization information essential for implementing inlined constructs. Inhibits cross-module inlining but improves binary compatibility.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:865)
</summary>
</member>
<member name="M:FSComp.SR.optsNoInterface">
<summary>
 Don&apos;t add a resource to the generated assembly containing F#-specific metadata
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:866)
</summary>
</member>
<member name="M:FSComp.SR.optsNameOfOutputFile">
<summary>
 Name of the output file (Short form: -o)
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:855)
</summary>
</member>
<member name="M:FSComp.SR.optsMlcompatibility">
<summary>
 Ignore ML compatibility warnings
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:886)
</summary>
</member>
<member name="M:FSComp.SR.optsLinkresource">
<summary>
 Link the specified resource to this assembly where the resinfo format is &lt;file&gt;[,&lt;string name&gt;[,public|private]]
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:873)
</summary>
</member>
<member name="M:FSComp.SR.optsLib">
<summary>
 Specify a directory for the include path which is used to resolve source files and assemblies (Short form: -I)
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:892)
</summary>
</member>
<member name="M:FSComp.SR.optsInvalidWarningLevel(System.Int32)">
<summary>
 Invalid warning level &apos;%d&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:902)
</summary>
</member>
<member name="M:FSComp.SR.optsInvalidTargetProfile(System.String)">
<summary>
 Invalid value &apos;%s&apos; for &apos;--targetprofile&apos;, valid values are &apos;mscorlib&apos; or &apos;netcore&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:926)
</summary>
</member>
<member name="M:FSComp.SR.optsInvalidSubSystemVersion(System.String)">
<summary>
 Invalid version &apos;%s&apos; for &apos;--subsystemversion&apos;. The version must be 4.00 or greater.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:925)
</summary>
</member>
<member name="M:FSComp.SR.optsInternalNoDescription(System.String)">
<summary>
 The command-line option &apos;%s&apos; is for internal use only
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:916)
</summary>
</member>
<member name="M:FSComp.SR.optsHelpBannerResources">
<summary>
 - RESOURCES -
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:908)
</summary>
</member>
<member name="M:FSComp.SR.optsHelpBannerOutputFiles">
<summary>
 - OUTPUT FILES -
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:906)
</summary>
</member>
<member name="M:FSComp.SR.optsHelpBannerMisc">
<summary>
 - MISCELLANEOUS -
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:911)
</summary>
</member>
<member name="M:FSComp.SR.optsHelpBannerLanguage">
<summary>
 - LANGUAGE -
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:912)
</summary>
</member>
<member name="M:FSComp.SR.optsHelpBannerInputFiles">
<summary>
 - INPUT FILES -
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:907)
</summary>
</member>
<member name="M:FSComp.SR.optsHelpBannerErrsAndWarns">
<summary>
 - ERRORS AND WARNINGS -
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:913)
</summary>
</member>
<member name="M:FSComp.SR.optsHelpBannerCodeGen">
<summary>
 - CODE GENERATION -
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:909)
</summary>
</member>
<member name="M:FSComp.SR.optsHelpBannerAdvanced">
<summary>
 - ADVANCED -
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:910)
</summary>
</member>
<member name="M:FSComp.SR.optsHelp">
<summary>
 Display this usage message (Short form: -?)
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:888)
</summary>
</member>
<member name="M:FSComp.SR.optsFullpaths">
<summary>
 Output messages with fully qualified paths
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:891)
</summary>
</member>
<member name="M:FSComp.SR.optsEmitDebugInfoInQuotations">
<summary>
 Emit debug information in quotations
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:924)
</summary>
</member>
<member name="M:FSComp.SR.optsDelaySign">
<summary>
 Delay-sign the assembly using only the public portion of the strong name key
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:860)
</summary>
</member>
<member name="M:FSComp.SR.optsDefine">
<summary>
 Define conditional compilation symbols (Short form: -d)
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:885)
</summary>
</member>
<member name="M:FSComp.SR.optsDebugPM">
<summary>
 Emit debug information (Short form: -g)
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:874)
</summary>
</member>
<member name="M:FSComp.SR.optsDebug">
<summary>
 Specify debugging type: full, pdbonly. (&apos;full&apos; is the default and enables attaching a debugger to a running program).
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:875)
</summary>
</member>
<member name="M:FSComp.SR.optsDCLONoDescription(System.String)">
<summary>
 The command-line option &apos;%s&apos; has been deprecated
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:917)
</summary>
</member>
<member name="M:FSComp.SR.optsDCLOHtmlDoc(System.String)">
<summary>
 The command-line option &apos;%s&apos; has been deprecated. HTML document generation is now part of the F# Power Pack, via the tool FsHtmlDoc.exe.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:919)
</summary>
</member>
<member name="M:FSComp.SR.optsDCLODeprecatedSuggestAlternative(System.String,System.String)">
<summary>
 The command-line option &apos;%s&apos; has been deprecated. Use &apos;%s&apos; instead.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:918)
</summary>
</member>
<member name="M:FSComp.SR.optsCrossoptimize">
<summary>
 Enable or disable cross-module optimizations
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:878)
</summary>
</member>
<member name="M:FSComp.SR.optsCopyright">
<summary>
 Freely distributed under the Apache 2.0 Open Source License
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:854)
</summary>
</member>
<member name="M:FSComp.SR.optsConsoleColors">
<summary>
 Output warning and error messages in color
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:920)
</summary>
</member>
<member name="M:FSComp.SR.optsCodepage">
<summary>
 Specify the codepage used to read source files
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:889)
</summary>
</member>
<member name="M:FSComp.SR.optsClirootDescription">
<summary>
 Use to override where the compiler looks for mscorlib.dll and framework components
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:905)
</summary>
</member>
<member name="M:FSComp.SR.optsClirootDeprecatedMsg">
<summary>
 The command-line option &apos;--cliroot&apos; has been deprecated. Use an explicit reference to a specific copy of mscorlib.dll instead.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:904)
</summary>
</member>
<member name="M:FSComp.SR.optsChecked">
<summary>
 Generate overflow checks
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:884)
</summary>
</member>
<member name="M:FSComp.SR.optsBuildWindows">
<summary>
 Build a Windows executable
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:857)
</summary>
</member>
<member name="M:FSComp.SR.optsBuildModule">
<summary>
 Build a module that can be added to another assembly
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:859)
</summary>
</member>
<member name="M:FSComp.SR.optsBuildLibrary">
<summary>
 Build a library (Short form: -a)
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:858)
</summary>
</member>
<member name="M:FSComp.SR.optsBuildConsole">
<summary>
 Build a console executable
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:856)
</summary>
</member>
<member name="M:FSComp.SR.optsBaseaddress">
<summary>
 Base address for the library to be built
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:893)
</summary>
</member>
<member name="M:FSComp.SR.optValueMarkedInlineHasUnexpectedValue">
<summary>
 A value marked as &apos;inline&apos; has an unexpected value
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1001)
</summary>
</member>
<member name="M:FSComp.SR.optValueMarkedInlineCouldNotBeInlined">
<summary>
 A value marked as &apos;inline&apos; could not be inlined
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1002)
</summary>
</member>
<member name="M:FSComp.SR.optValueMarkedInlineButWasNotBoundInTheOptEnv(System.String)">
<summary>
 The value &apos;%s&apos; was marked inline but was not bound in the optimization environment
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:999)
</summary>
</member>
<member name="M:FSComp.SR.optValueMarkedInlineButIncomplete(System.String)">
<summary>
 The value &apos;%s&apos; was marked inline but its implementation makes use of an internal or private function which is not sufficiently accessible
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:998)
</summary>
</member>
<member name="M:FSComp.SR.optRecursiveValValue(System.String)">
<summary>
 Recursive ValValue %s
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1004)
</summary>
</member>
<member name="M:FSComp.SR.optLocalValueNotFoundDuringOptimization(System.String)">
<summary>
 Local value %s not found during optimization
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1000)
</summary>
</member>
<member name="M:FSComp.SR.optFailedToInlineValue(System.String)">
<summary>
 Failed to inline the value &apos;%s&apos; marked &apos;inline&apos;, perhaps because a recursive value was marked &apos;inline&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1003)
</summary>
</member>
<member name="M:FSComp.SR.nrUnexpectedEmptyLongId">
<summary>
 Unexpected empty long identifier
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1019)
</summary>
</member>
<member name="M:FSComp.SR.nrTypeInstantiationNeededToDisambiguateTypesWithSameName(System.String,System.String)">
<summary>
 Multiple types exist called &apos;%s&apos;, taking different numbers of generic parameters. Provide a type instantiation to disambiguate the type resolution, e.g. &apos;%s&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1015)
</summary>
</member>
<member name="M:FSComp.SR.nrTypeInstantiationIsMissingAndCouldNotBeInferred(System.String,System.String)">
<summary>
 The instantiation of the generic type &apos;%s&apos; is missing and can&apos;t be inferred from the arguments or return type of this member. Consider providing a type instantiation when accessing this type, e.g. &apos;%s&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1016)
</summary>
</member>
<member name="M:FSComp.SR.nrTypeDoesNotContainSuchField(System.String,System.String)">
<summary>
 The type &apos;%s&apos; does not contain a field &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1020)
</summary>
</member>
<member name="M:FSComp.SR.nrNoConstructorsAvailableForType(System.String)">
<summary>
 No constructors are available for the type &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1023)
</summary>
</member>
<member name="M:FSComp.SR.nrIsNotConstructorOrLiteral">
<summary>
 This is not a constructor or literal, or a constructor is being used incorrectly
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1018)
</summary>
</member>
<member name="M:FSComp.SR.nrInvalidModuleExprType">
<summary>
 Invalid module/expression/type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1014)
</summary>
</member>
<member name="M:FSComp.SR.nrInvalidFieldLabel">
<summary>
 Invalid field label
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1021)
</summary>
</member>
<member name="M:FSComp.SR.nrInvalidExpression(System.String)">
<summary>
 Invalid expression &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1022)
</summary>
</member>
<member name="M:FSComp.SR.nrGlobalUsedOnlyAsFirstName">
<summary>
 &apos;global&apos; may only be used as the first name in a qualified path
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1017)
</summary>
</member>
<member name="M:FSComp.SR.noInvokeMethodsFound">
<summary>
 No Invoke methods found for delegate type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:969)
</summary>
</member>
<member name="M:FSComp.SR.nicePrintOtherOverloadsN(System.Int32)">
<summary>
 + %d overloads
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1305)
</summary>
</member>
<member name="M:FSComp.SR.nicePrintOtherOverloads1">
<summary>
 + 1 overload
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1304)
</summary>
</member>
<member name="M:FSComp.SR.moreThanOneInvokeMethodFound">
<summary>
 More than one Invoke method found for delegate type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:970)
</summary>
</member>
<member name="M:FSComp.SR.mlCompatMessage(System.String)">
<summary>
 This construct is for ML compatibility. %s. You can disable this warning by using &apos;--mlcompatibility&apos; or &apos;--nowarn:62&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1102)
</summary>
</member>
<member name="M:FSComp.SR.memberOperatorDefinitionWithNonTripleArgument(System.String,System.Int32)">
<summary>
 Infix operator member &apos;%s&apos; has %d initial argument(s). Expected a tuple of 3 arguments
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1317)
</summary>
</member>
<member name="M:FSComp.SR.memberOperatorDefinitionWithNonPairArgument(System.String,System.Int32)">
<summary>
 Infix operator member &apos;%s&apos; has %d initial argument(s). Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1067)
</summary>
</member>
<member name="M:FSComp.SR.memberOperatorDefinitionWithNoArguments(System.String)">
<summary>
 Infix operator member &apos;%s&apos; has no arguments. Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1066)
</summary>
</member>
<member name="M:FSComp.SR.memberOperatorDefinitionWithCurriedArguments(System.String)">
<summary>
 Infix operator member &apos;%s&apos; has extra curried arguments. Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1068)
</summary>
</member>
<member name="M:FSComp.SR.loadingDescription">
<summary>
 (loading description...)
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1313)
</summary>
</member>
<member name="M:FSComp.SR.lexhlpIdentifiersContainingAtSymbolReserved">
<summary>
 Identifiers containing &apos;@&apos; are reserved for use in F# code generation
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:980)
</summary>
</member>
<member name="M:FSComp.SR.lexhlpIdentifierReserved(System.String)">
<summary>
 The identifier &apos;%s&apos; is reserved for future use by F#
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:981)
</summary>
</member>
<member name="M:FSComp.SR.lexfltTokenIsOffsideOfContextStartedEarlier(System.String)">
<summary>
 Possible incorrect indentation: this token is offside of context started at position %s. Try indenting this token further or using standard formatting conventions.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1009)
</summary>
</member>
<member name="M:FSComp.SR.lexfltSeparatorTokensOfPatternMatchMisaligned">
<summary>
 The &apos;|&apos; tokens separating rules of this pattern match are misaligned by one column. Consider realigning your code or using further indentation.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1010)
</summary>
</member>
<member name="M:FSComp.SR.lexfltIncorrentIndentationOfIn">
<summary>
 The indentation of this &apos;in&apos; token is incorrect with respect to the corresponding &apos;let&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1008)
</summary>
</member>
<member name="M:FSComp.SR.lexWrongNestedHashEndif">
<summary>
 Syntax error. Wrong nested #endif, unexpected tokens before it.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1064)
</summary>
</member>
<member name="M:FSComp.SR.lexUnexpectedChar(System.String)">
<summary>
 Unexpected character &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1033)
</summary>
</member>
<member name="M:FSComp.SR.lexTokenReserved">
<summary>
 This token is reserved for future use
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1054)
</summary>
</member>
<member name="M:FSComp.SR.lexThisUnicodeOnlyInStringLiterals">
<summary>
 This Unicode encoding is only valid in string literals
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1053)
</summary>
</member>
<member name="M:FSComp.SR.lexTabsNotAllowed">
<summary>
 TABs are not allowed in F# code unless the #indent \&quot;off\&quot; option is used
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1055)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideThirtyTwoBitUnsigned">
<summary>
 This number is outside the allowable range for 32-bit unsigned integers
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1042)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideThirtyTwoBitSigned">
<summary>
 This number is outside the allowable range for 32-bit signed integers
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1041)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideSixtyFourBitUnsigned">
<summary>
 This number is outside the allowable range for 64-bit unsigned integers
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1044)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideSixtyFourBitSigned">
<summary>
 This number is outside the allowable range for 64-bit signed integers
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1043)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideSixteenBitUnsigned">
<summary>
 This number is outside the allowable range for 16-bit unsigned integers
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1040)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideSixteenBitSigned">
<summary>
 This number is outside the allowable range for 16-bit signed integers
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1039)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideNativeUnsigned">
<summary>
 This number is outside the allowable range for unsigned native integers
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1046)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideNativeSigned">
<summary>
 This number is outside the allowable range for signed native integers
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1045)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideIntegerRange">
<summary>
 This number is outside the allowable range for this integer type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1031)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideEightBitUnsigned">
<summary>
 This number is outside the allowable range for 8-bit unsigned integers
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1038)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideEightBitSignedHex">
<summary>
 This number is outside the allowable range for hexadecimal 8-bit signed integers
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1037)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideEightBitSigned">
<summary>
 This number is outside the allowable range for 8-bit signed integers
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1036)
</summary>
</member>
<member name="M:FSComp.SR.lexOusideThirtyTwoBitFloat">
<summary>
 This number is outside the allowable range for 32-bit floats
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1049)
</summary>
</member>
<member name="M:FSComp.SR.lexOusideDecimal">
<summary>
 This number is outside the allowable range for decimal literals
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1048)
</summary>
</member>
<member name="M:FSComp.SR.lexInvalidNumericLiteral">
<summary>
 This is not a valid numeric literal. Sample formats include 4, 0x4, 0b0100, 4L, 4UL, 4u, 4s, 4us, 4y, 4uy, 4.0, 4.0f, 4I.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1050)
</summary>
</member>
<member name="M:FSComp.SR.lexInvalidLineNumber(System.String)">
<summary>
 Invalid line number: &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1056)
</summary>
</member>
<member name="M:FSComp.SR.lexInvalidFloat">
<summary>
 Invalid floating point number
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1047)
</summary>
</member>
<member name="M:FSComp.SR.lexInvalidCharLiteral">
<summary>
 This is not a valid character literal
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1052)
</summary>
</member>
<member name="M:FSComp.SR.lexInvalidByteLiteral">
<summary>
 This is not a valid byte literal
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1051)
</summary>
</member>
<member name="M:FSComp.SR.lexIndentOffForML">
<summary>
 Consider using a file with extension &apos;.ml&apos; or &apos;.mli&apos; instead
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1109)
</summary>
</member>
<member name="M:FSComp.SR.lexIdentEndInMarkReserved(System.String)">
<summary>
 Identifiers followed by &apos;%s&apos; are reserved for future use
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1035)
</summary>
</member>
<member name="M:FSComp.SR.lexHashIfMustHaveIdent">
<summary>
 #if directive should be immediately followed by an identifier
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1063)
</summary>
</member>
<member name="M:FSComp.SR.lexHashIfMustBeFirst">
<summary>
 #if directive must appear as the first non-whitespace character on a line
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1057)
</summary>
</member>
<member name="M:FSComp.SR.lexHashEndingNoMatchingIf">
<summary>
 #endif has no matching #if
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1061)
</summary>
</member>
<member name="M:FSComp.SR.lexHashEndifRequiredForElse">
<summary>
 #endif required for #else
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1059)
</summary>
</member>
<member name="M:FSComp.SR.lexHashEndifMustBeFirst">
<summary>
 #endif directive must appear as the first non-whitespace character on a line
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1062)
</summary>
</member>
<member name="M:FSComp.SR.lexHashElseNoMatchingIf">
<summary>
 #else has no matching #if
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1058)
</summary>
</member>
<member name="M:FSComp.SR.lexHashElseMustBeFirst">
<summary>
 #else directive must appear as the first non-whitespace character on a line
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1060)
</summary>
</member>
<member name="M:FSComp.SR.lexExpectedSingleLineComment">
<summary>
 Expected single line comment or end of line
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1065)
</summary>
</member>
<member name="M:FSComp.SR.lexCharNotAllowedInOperatorNames(System.String)">
<summary>
 &apos;%s&apos; is not permitted as a character in operator names and is reserved for future use
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1032)
</summary>
</member>
<member name="M:FSComp.SR.lexByteArrayCannotEncode">
<summary>
 This byte array literal contains characters that do not encode as a single byte
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1034)
</summary>
</member>
<member name="M:FSComp.SR.invalidPlatformTargetForOldFramework">
<summary>
 The &apos;anycpu32bitpreferred&apos; platform flag may only be used with .NET Framework versions 4.5 and greater.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1302)
</summary>
</member>
<member name="M:FSComp.SR.invalidPlatformTarget">
<summary>
 The &apos;anycpu32bitpreferred&apos; platform can only be used with EXE targets. You must use &apos;anycpu&apos; instead.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1298)
</summary>
</member>
<member name="M:FSComp.SR.invalidNamespaceForProvidedType">
<summary>
 invalid namespace for provided type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1204)
</summary>
</member>
<member name="M:FSComp.SR.invalidFullNameForProvidedType">
<summary>
 invalid full name for provided type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1205)
</summary>
</member>
<member name="M:FSComp.SR.infosInvalidProvidedLiteralValue(System.String)">
<summary>
 Invalid provided literal value &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1297)
</summary>
</member>
<member name="M:FSComp.SR.impTypeRequiredUnavailable(System.String,System.String)">
<summary>
 The type &apos;%s&apos; is required here and is unavailable. You must add a reference to assembly &apos;%s&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:990)
</summary>
</member>
<member name="M:FSComp.SR.impReferencedTypeCouldNotBeFoundInAssembly(System.String,System.String)">
<summary>
 A reference to the type &apos;%s&apos; in assembly &apos;%s&apos; was found, but the type could not be found in that assembly
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:991)
</summary>
</member>
<member name="M:FSComp.SR.impReferenceToDllRequiredByAssembly(System.String,System.String,System.String)">
<summary>
 A reference to the DLL %s is required by assembly %s. The imported type %s is located in the first assembly and could not be resolved.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:993)
</summary>
</member>
<member name="M:FSComp.SR.impNotEnoughTypeParamsInScopeWhileImporting">
<summary>
 Internal error or badly formed metadata: not enough type parameters were in scope while importing
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:992)
</summary>
</member>
<member name="M:FSComp.SR.impInvalidNumberOfGenericArguments(System.String,System.Int32,System.Int32)">
<summary>
 Invalid number of generic arguments to type &apos;%s&apos; in provided type. Expected &apos;%d&apos; arguments, given &apos;%d&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1273)
</summary>
</member>
<member name="M:FSComp.SR.impInvalidMeasureArgument2(System.String)">
<summary>
 Invalid value unit-of-measure parameter &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1275)
</summary>
</member>
<member name="M:FSComp.SR.impInvalidMeasureArgument1(System.String,System.String)">
<summary>
 Invalid value &apos;%s&apos; for unit-of-measure parameter &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1274)
</summary>
</member>
<member name="M:FSComp.SR.impImportedAssemblyUsesNotPublicType(System.String)">
<summary>
 An imported assembly uses the type &apos;%s&apos; but that type is not public
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:994)
</summary>
</member>
<member name="M:FSComp.SR.ilxgenUnexpectedArgumentToMethodHandleOfDuringCodegen">
<summary>
 Invalid argument to &apos;methodhandleof&apos; during codegen
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1235)
</summary>
</member>
<member name="M:FSComp.SR.ilwriteMDBMemberMissing(System.String)">
<summary>
 MDB generation failed. Could not find compatible member %s
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1118)
</summary>
</member>
<member name="M:FSComp.SR.ilwriteMDBFileNameCannotBeChangedWarning">
<summary>
 The name of the MDB file must be &lt;assembly-file-name&gt;.mdb. The --pdb option will be ignored.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1117)
</summary>
</member>
<member name="M:FSComp.SR.ilwriteErrorCreatingPdb(System.String)">
<summary>
 Unexpected error creating debug information file &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1027)
</summary>
</member>
<member name="M:FSComp.SR.ilwriteErrorCreatingMdb">
<summary>
 Cannot generate MDB debug information. Failed to load the &apos;MonoSymbolWriter&apos; type from the &apos;Mono.CompilerServices.SymbolWriter.dll&apos; assembly.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1119)
</summary>
</member>
<member name="M:FSComp.SR.ilUnexpectedUnrealizedValue">
<summary>
 Compiler error: unexpected unrealized value
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:842)
</summary>
</member>
<member name="M:FSComp.SR.ilUnexpectedGetSetAnnotation">
<summary>
 Unexpected GetSet annotation on a property
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:845)
</summary>
</member>
<member name="M:FSComp.SR.ilUndefinedValue(System.String)">
<summary>
 Undefined value &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:829)
</summary>
</member>
<member name="M:FSComp.SR.ilTypeCannotBeUsedForLiteralField">
<summary>
 This type cannot be used for a literal field
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:844)
</summary>
</member>
<member name="M:FSComp.SR.ilStructLayoutAttributeCouldNotBeDecoded">
<summary>
 The StructLayout attribute could not be decoded
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:847)
</summary>
</member>
<member name="M:FSComp.SR.ilStaticMethodIsNotLambda(System.String)">
<summary>
 GenSetStorage: %s was represented as a static method but was not an appropriate lambda expression
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:840)
</summary>
</member>
<member name="M:FSComp.SR.ilSignatureForExternalFunctionContainsTypeParameters">
<summary>
 The signature for this external function contains type parameters. Constrain the argument and return types to indicate the types of the corresponding C function.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:837)
</summary>
</member>
<member name="M:FSComp.SR.ilReflectedDefinitionsCannotUseSliceOperator">
<summary>
 Reflected definitions cannot contain uses of the prefix splice operator &apos;%%&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:849)
</summary>
</member>
<member name="M:FSComp.SR.ilMutableVariablesCannotEscapeMethod">
<summary>
 Mutable variables cannot escape their method
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:841)
</summary>
</member>
<member name="M:FSComp.SR.ilMarshalAsAttributeCannotBeDecoded">
<summary>
 The MarshalAs attribute could not be decoded
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:836)
</summary>
</member>
<member name="M:FSComp.SR.ilMainModuleEmpty">
<summary>
 Main module of program is empty: nothing will happen when it is run
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:843)
</summary>
</member>
<member name="M:FSComp.SR.ilLiteralFieldsCannotBeSet">
<summary>
 Literal fields cannot be set
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:839)
</summary>
</member>
<member name="M:FSComp.SR.ilLabelNotFound(System.String)">
<summary>
 Label %s not found
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:830)
</summary>
</member>
<member name="M:FSComp.SR.ilIncorrectNumberOfTypeArguments">
<summary>
 Incorrect number of type arguments to local call
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:831)
</summary>
</member>
<member name="M:FSComp.SR.ilFieldOffsetAttributeCouldNotBeDecoded">
<summary>
 The FieldOffset attribute could not be decoded
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:846)
</summary>
</member>
<member name="M:FSComp.SR.ilFieldHasOffsetForSequentialLayout">
<summary>
 The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit)
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1112)
</summary>
</member>
<member name="M:FSComp.SR.ilFieldDoesNotHaveValidOffsetForStructureLayout(System.String,System.String)">
<summary>
 The type &apos;%s&apos; has been marked as having an Explicit layout, but the field &apos;%s&apos; has not been marked with the &apos;FieldOffset&apos; attribute
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1104)
</summary>
</member>
<member name="M:FSComp.SR.ilDynamicInvocationNotSupported(System.String)">
<summary>
 Dynamic invocation of %s is not supported
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:832)
</summary>
</member>
<member name="M:FSComp.SR.ilDllImportAttributeCouldNotBeDecoded">
<summary>
 The DllImport attribute could not be decoded
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:838)
</summary>
</member>
<member name="M:FSComp.SR.ilDefaultAugmentationAttributeCouldNotBeDecoded">
<summary>
 The DefaultAugmentation attribute could not be decoded
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:848)
</summary>
</member>
<member name="M:FSComp.SR.ilCustomMarshallersCannotBeUsedInFSharp">
<summary>
 Custom marshallers cannot be specified in F# code. Consider using a C# helper function.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:835)
</summary>
</member>
<member name="M:FSComp.SR.ilAddressOfValueHereIsInvalid(System.String)">
<summary>
 This operation involves taking the address of a value &apos;%s&apos; represented using a local variable or other special representation. This is invalid.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:834)
</summary>
</member>
<member name="M:FSComp.SR.ilAddressOfLiteralFieldIsInvalid">
<summary>
 Taking the address of a literal field is invalid
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:833)
</summary>
</member>
<member name="P:FSComp.SR.SwallowResourceText">
<summary>
 If set to true, then all error messages will just return the filled &apos;holes&apos; delimited by &apos;,,,&apos;s - this is for language-neutral testing (e.g. localization-invariant baselines).
</summary>
</member>
<member name="M:FSComp.SR.fscTwoResourceManifests">
<summary>
 Conflicting options specified: &apos;win32manifest&apos; and &apos;win32res&apos;. Only one of these can be used.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1144)
</summary>
</member>
<member name="M:FSComp.SR.fscTooManyErrors">
<summary>
 Exiting - too many errors
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1140)
</summary>
</member>
<member name="M:FSComp.SR.fscStaticLinkingNoProfileMismatches">
<summary>
 Static linking may not use assembly that targets different profile.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1163)
</summary>
</member>
<member name="M:FSComp.SR.fscStaticLinkingNoMixedDLL">
<summary>
 Static linking may not include a mixed managed/unmanaged DLL
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1148)
</summary>
</member>
<member name="M:FSComp.SR.fscStaticLinkingNoEXE">
<summary>
 Static linking may not include a .EXE
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1147)
</summary>
</member>
<member name="M:FSComp.SR.fscResxSourceFileDeprecated(System.String)">
<summary>
 Passing a .resx file (%s) as a source file to the compiler is deprecated. Use resgen.exe to transform the .resx file into a .resources file to pass as a --resource option. If you are using MSBuild, this can be done via an &lt;EmbeddedResource&gt; item in the .fsproj project file.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1162)
</summary>
</member>
<member name="M:FSComp.SR.fscRemotingError">
<summary>
 The resident compilation service was not used because a problem occured in communicating with the server.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1160)
</summary>
</member>
<member name="M:FSComp.SR.fscReferenceOnCommandLine(System.String)">
<summary>
 The assembly &apos;%s&apos; is listed on the command line. Assemblies should be referenced using a command line flag such as &apos;-r&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1159)
</summary>
</member>
<member name="M:FSComp.SR.fscQuotationLiteralsStaticLinking0">
<summary>
 Code in this assembly makes uses of quotation literals. Static linking may not include components that make use of quotation literals.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1146)
</summary>
</member>
<member name="M:FSComp.SR.fscQuotationLiteralsStaticLinking(System.String)">
<summary>
 The code in assembly &apos;%s&apos; makes uses of quotation literals. Static linking may not include components that make use of quotation literals.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1145)
</summary>
</member>
<member name="M:FSComp.SR.fscProblemWritingBinary(System.String,System.String)">
<summary>
 A problem occurred writing the binary &apos;%s&apos;: %s
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1153)
</summary>
</member>
<member name="M:FSComp.SR.fscNoImplementationFiles">
<summary>
 No implementation files specified
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1142)
</summary>
</member>
<member name="M:FSComp.SR.fscKeyNameWarning">
<summary>
 Option &apos;--keycontainer&apos; overrides attribute &apos;System.Reflection.AssemblyNameAttribute&apos; given in a source file or added module
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1158)
</summary>
</member>
<member name="M:FSComp.SR.fscKeyFileWarning">
<summary>
 Option &apos;--keyfile&apos; overrides attribute &apos;System.Reflection.AssemblyKeyFileAttribute&apos; given in a source file or added module
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1157)
</summary>
</member>
<member name="M:FSComp.SR.fscKeyFileCouldNotBeOpened(System.String)">
<summary>
 The key file &apos;%s&apos; could not be opened
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1152)
</summary>
</member>
<member name="M:FSComp.SR.fscIgnoringMixedWhenLinking(System.String)">
<summary>
 Ignoring mixed managed/unmanaged assembly &apos;%s&apos; during static linking
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1149)
</summary>
</member>
<member name="M:FSComp.SR.fscDelaySignWarning">
<summary>
 Option &apos;--delaysign&apos; overrides attribute &apos;System.Reflection.AssemblyDelaySignAttribute&apos; given in a source file or added module
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1156)
</summary>
</member>
<member name="M:FSComp.SR.fscBadAssemblyVersion(System.String)">
<summary>
 An AssemblyVersionAttribute specified version &apos;%s&apos;, but this value is invalid and has been ignored
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1143)
</summary>
</member>
<member name="M:FSComp.SR.fscAssumeStaticLinkContainsNoDependencies(System.String)">
<summary>
 Assembly &apos;%s&apos; was referenced transitively and the assembly could not be resolved automatically. Static linking will assume this DLL has no dependencies on the F# library or other statically linked DLLs. Consider adding an explicit reference to this DLL.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1150)
</summary>
</member>
<member name="M:FSComp.SR.fscAssemblyVersionAttributeIgnored">
<summary>
 The &apos;AssemblyVersionAttribute&apos; has been ignored because a version was given using a command line option
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1154)
</summary>
</member>
<member name="M:FSComp.SR.fscAssemblyNotFoundInDependencySet(System.String)">
<summary>
 Assembly &apos;%s&apos; not found in dependency set of target binary. Statically linked roots should be specified using an assembly name, without a DLL or EXE extension. If this assembly was referenced explicitly then it is possible the assembly was not actually required by the generated binary, in which case it should not be statically linked.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1151)
</summary>
</member>
<member name="M:FSComp.SR.fscAssemblyCultureAttributeError">
<summary>
 Error emitting &apos;System.Reflection.AssemblyCultureAttribute&apos; attribute -- &apos;Executables cannot be satellite assemblies, Culture should always be empty&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1155)
</summary>
</member>
<member name="M:FSComp.SR.forPrefixFlagSpacePlusSetTwice">
<summary>
 Prefix flag (&apos; &apos; or &apos;+&apos;) set twice
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:231)
</summary>
</member>
<member name="M:FSComp.SR.forPrecisionMissingAfterDot">
<summary>
 Precision missing after the &apos;.&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:236)
</summary>
</member>
<member name="M:FSComp.SR.forPositionalSpecifiersNotPermitted">
<summary>
 Positional specifiers are not permitted in format strings
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:228)
</summary>
</member>
<member name="M:FSComp.SR.forMissingFormatSpecifier">
<summary>
 Missing format specifier
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:229)
</summary>
</member>
<member name="M:FSComp.SR.forLIsUnnecessary">
<summary>
 The &apos;l&apos; or &apos;L&apos; in this format specifier is unnecessary. In F# code you can use %%d, %%x, %%o or %%u instead, which are overloaded to work with all basic integer types.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:239)
</summary>
</member>
<member name="M:FSComp.SR.forHashSpecifierIsInvalid">
<summary>
 The # formatting modifier is invalid in F#
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:232)
</summary>
</member>
<member name="M:FSComp.SR.forHIsUnnecessary">
<summary>
 The &apos;h&apos; or &apos;H&apos; in this format specifier is unnecessary. You can use %%d, %%x, %%o or %%u instead, which are overloaded to work with all basic integer types..
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:240)
</summary>
</member>
<member name="M:FSComp.SR.forFormatDoesntSupportPrecision(System.String)">
<summary>
 &apos;%s&apos; format does not support precision
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:237)
</summary>
</member>
<member name="M:FSComp.SR.forFlagSetTwice(System.String)">
<summary>
 &apos;%s&apos; flag set twice
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:230)
</summary>
</member>
<member name="M:FSComp.SR.forDoesNotSupportZeroFlag(System.String)">
<summary>
 &apos;%s&apos; format does not support &apos;0&apos; flag
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:235)
</summary>
</member>
<member name="M:FSComp.SR.forDoesNotSupportPrefixFlag(System.String,System.String)">
<summary>
 &apos;%s&apos; does not support prefix &apos;%s&apos; flag
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:241)
</summary>
</member>
<member name="M:FSComp.SR.forBadWidth">
<summary>
 Bad width in format specifier
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:234)
</summary>
</member>
<member name="M:FSComp.SR.forBadPrecision">
<summary>
 Bad precision in format specifier
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:233)
</summary>
</member>
<member name="M:FSComp.SR.forBadFormatSpecifierGeneral(System.String)">
<summary>
 Bad format specifier: &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:242)
</summary>
</member>
<member name="M:FSComp.SR.forBadFormatSpecifier">
<summary>
 Bad format specifier (after l or L): Expected ld,li,lo,lu,lx or lX. In F# code you can use %%d, %%x, %%o or %%u instead, which are overloaded to work with all basic integer types.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:238)
</summary>
</member>
<member name="M:FSComp.SR.fieldIsNotAccessible(System.String)">
<summary>
 The record, struct or class field &apos;%s&apos; is not accessible from this code location
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:966)
</summary>
</member>
<member name="M:FSComp.SR.experimentalConstruct">
<summary>
 This construct is experimental
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:968)
</summary>
</member>
<member name="M:FSComp.SR.eventHasNonStandardType(System.String,System.String,System.String)">
<summary>
 The event &apos;%s&apos; has a non-standard type. If this event is declared in another CLI language, you may need to access this event using the explicit %s and %s methods for the event. If this event is declared in F#, make the type of the event an instantiation of either &apos;IDelegateEvent&lt;_&gt;&apos; or &apos;IEvent&lt;_,_&gt;&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:961)
</summary>
</member>
<member name="M:FSComp.SR.etUnsupportedProvidedExpression(System.String)">
<summary>
 Unsupported expression &apos;%s&apos; from type provider. If you are the author of this type provider, consider adjusting it to provide a different provided expression.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1186)
</summary>
</member>
<member name="M:FSComp.SR.etUnsupportedMemberKind(System.String,System.String)">
<summary>
 Invalid member &apos;%s&apos; on provided type &apos;%s&apos;. Only properties, methods and constructors are allowed
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1178)
</summary>
</member>
<member name="M:FSComp.SR.etUnsupportedConstantType(System.String)">
<summary>
 Unsupported constant type &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1185)
</summary>
</member>
<member name="M:FSComp.SR.etUnknownStaticArgumentKind(System.String,System.String)">
<summary>
 Unknown static argument kind &apos;%s&apos; when resolving a reference to a provided type &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1203)
</summary>
</member>
<member name="M:FSComp.SR.etUnexpectedNullFromProvidedTypeMember(System.String,System.String)">
<summary>
 Unexpected &apos;null&apos; return value from provided type &apos;%s&apos; member &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1198)
</summary>
</member>
<member name="M:FSComp.SR.etUnexpectedExceptionFromProvidedTypeMember(System.String,System.String,System.String)">
<summary>
 Unexpected exception from provided type &apos;%s&apos; member &apos;%s&apos;: %s
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1184)
</summary>
</member>
<member name="M:FSComp.SR.etUnexpectedExceptionFromProvidedMemberMember(System.String,System.String,System.String,System.String)">
<summary>
 Unexpected exception from member &apos;%s&apos; of provided type &apos;%s&apos; member &apos;%s&apos;: %s
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1199)
</summary>
</member>
<member name="M:FSComp.SR.etTypeProviderNotApproved(System.String)">
<summary>
 Type provider assembly &apos;%s&apos; is not trusted and will not be loaded for security reasons. This may cause subsequent build errors. See the &apos;F# Tools&apos; section of Visual Studio options for more information.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1285)
</summary>
</member>
<member name="M:FSComp.SR.etTypeProviderConstructorException(System.String)">
<summary>
 The type provider constructor has thrown an exception: %s
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1208)
</summary>
</member>
<member name="M:FSComp.SR.etTooManyStaticParameters(System.Int32,System.Int32,System.Int32)">
<summary>
 Too many static parameters. Expected at most %d parameters, but got %d unnamed and %d named parameters.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1296)
</summary>
</member>
<member name="M:FSComp.SR.etStaticParameterRequiresAValue(System.String,System.String,System.String,System.String)">
<summary>
 The static parameter &apos;%s&apos; of the provided type &apos;%s&apos; requires a value. Static parameters to type providers may be optionally specified using named arguments, e.g. &apos;%s&lt;%s=...&gt;&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1227)
</summary>
</member>
<member name="M:FSComp.SR.etStaticParameterAlreadyHasValue(System.String)">
<summary>
 The static parameter &apos;%s&apos; has already been given a value
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1229)
</summary>
</member>
<member name="M:FSComp.SR.etProviderReturnedNull(System.String)">
<summary>
 The type provider returned &apos;null&apos;, which is not a valid return value from &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1207)
</summary>
</member>
<member name="M:FSComp.SR.etProviderHasWrongDesignerAssembly(System.String,System.String,System.String)">
<summary>
 Assembly attribute &apos;%s&apos; refers to a designer assembly &apos;%s&apos; which cannot be loaded or doesn&apos;t exist. %s
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1190)
</summary>
</member>
<member name="M:FSComp.SR.etProviderErrorWithContext(System.String,System.String,System.String,System.String)">
<summary>
 The type provider &apos;%s&apos; reported an error in the context of provided type &apos;%s&apos;, member &apos;%s&apos;. The error: %s
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1220)
</summary>
</member>
<member name="M:FSComp.SR.etProviderError(System.String,System.String)">
<summary>
 The type provider &apos;%s&apos; reported an error: %s
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1192)
</summary>
</member>
<member name="M:FSComp.SR.etProviderDoesNotHaveValidConstructor">
<summary>
 The type provider does not have a valid constructor. A constructor taking either no arguments or one argument of type &apos;TypeProviderConfig&apos; was expected.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1191)
</summary>
</member>
<member name="M:FSComp.SR.etProvidedTypeWithNullOrEmptyName(System.String)">
<summary>
 The &apos;%s&apos; of a provided type was null or empty.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1222)
</summary>
</member>
<member name="M:FSComp.SR.etProvidedTypeWithNameException(System.String,System.String)">
<summary>
 An exception occurred when accessing the &apos;%s&apos; of a provided type: %s
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1221)
</summary>
</member>
<member name="M:FSComp.SR.etProvidedTypeReferenceMissingArgument(System.String)">
<summary>
 A reference to a provided type was missing a value for the static parameter &apos;%s&apos;. You may need to recompile one or more referenced assemblies.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1236)
</summary>
</member>
<member name="M:FSComp.SR.etProvidedTypeReferenceInvalidText(System.String)">
<summary>
 A reference to a provided type had an invalid value &apos;%s&apos; for a static parameter. You may need to recompile one or more referenced assemblies.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1237)
</summary>
</member>
<member name="M:FSComp.SR.etProvidedTypeHasUnexpectedPath(System.String,System.String)">
<summary>
 Expected provided type with path &apos;%s&apos; but provided type has path &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1197)
</summary>
</member>
<member name="M:FSComp.SR.etProvidedTypeHasUnexpectedName(System.String,System.String)">
<summary>
 Expected provided type named &apos;%s&apos; but provided type has &apos;Name&apos; with value &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1187)
</summary>
</member>
<member name="M:FSComp.SR.etProvidedAppliedTypeHadWrongName(System.String,System.String,System.String)">
<summary>
 The type provider &apos;%s&apos; returned an invalid type from &apos;ApplyStaticArguments&apos;. A type with name &apos;%s&apos; was expected, but a type with name &apos;%s&apos; was returned.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1210)
</summary>
</member>
<member name="M:FSComp.SR.etPropertyNeedsCanWriteOrCanRead(System.String,System.String)">
<summary>
 Property &apos;%s&apos; on provided type &apos;%s&apos; is neither readable nor writable as it has CanRead=false and CanWrite=false
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1276)
</summary>
</member>
<member name="M:FSComp.SR.etPropertyHasSetterButNoCanWrite(System.String,System.String)">
<summary>
 Property &apos;%s&apos; on provided type &apos;%s&apos; has CanWrite=false but GetSetMethod() returned a method
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1182)
</summary>
</member>
<member name="M:FSComp.SR.etPropertyHasGetterButNoCanRead(System.String,System.String)">
<summary>
 Property &apos;%s&apos; on provided type &apos;%s&apos; has CanRead=false but GetGetMethod() returned a method
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1180)
</summary>
</member>
<member name="M:FSComp.SR.etPropertyCanWriteButHasNoSetter(System.String,System.String)">
<summary>
 Property &apos;%s&apos; on provided type &apos;%s&apos; has CanWrite=true but there was no value from GetSetMethod()
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1181)
</summary>
</member>
<member name="M:FSComp.SR.etPropertyCanReadButHasNoGetter(System.String,System.String)">
<summary>
 Property &apos;%s&apos; on provided type &apos;%s&apos; has CanRead=true but there was no value from GetGetMethod()
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1179)
</summary>
</member>
<member name="M:FSComp.SR.etOneOrMoreErrorsSeenDuringExtensionTypeSetting">
<summary>
 One or more errors seen during provided type setup
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1183)
</summary>
</member>
<member name="M:FSComp.SR.etNullProvidedExpression(System.String)">
<summary>
 Type provider &apos;%s&apos; returned null from GetInvokerExpression.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1209)
</summary>
</member>
<member name="M:FSComp.SR.etNullOrEmptyMemberName(System.String)">
<summary>
 The provided type &apos;%s&apos; returned a member with a null or empty member name
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1168)
</summary>
</member>
<member name="M:FSComp.SR.etNullMemberDeclaringTypeDifferentFromProvidedType(System.String,System.String,System.String)">
<summary>
 The provided type &apos;%s&apos; has member &apos;%s&apos; which has declaring type &apos;%s&apos;. Expected declaring type to be the same as provided type.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1171)
</summary>
</member>
<member name="M:FSComp.SR.etNullMemberDeclaringType(System.String,System.String)">
<summary>
 The provided type &apos;%s&apos; member info &apos;%s&apos; has null declaring type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1170)
</summary>
</member>
<member name="M:FSComp.SR.etNullMember(System.String)">
<summary>
 The provided type &apos;%s&apos; returned a null member
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1169)
</summary>
</member>
<member name="M:FSComp.SR.etNoStaticParameterWithName(System.String)">
<summary>
 No static parameter exists with name &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1228)
</summary>
</member>
<member name="M:FSComp.SR.etNestedProvidedTypesDoNotTakeStaticArgumentsOrGenericParameters">
<summary>
 Nested provided types do not take static arguments or generic parameters
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1200)
</summary>
</member>
<member name="M:FSComp.SR.etMustNotBeGeneric(System.String)">
<summary>
 Provided type &apos;%s&apos; has &apos;IsGenericType&apos; as true, but generic types are not supported.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1175)
</summary>
</member>
<member name="M:FSComp.SR.etMustNotBeAnArray(System.String)">
<summary>
 Provided type &apos;%s&apos; has &apos;IsArray&apos; as true, but array types are not supported.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1176)
</summary>
</member>
<member name="M:FSComp.SR.etMultipleStaticParameterWithName(System.String)">
<summary>
 Multiple static parameters exist with name &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1230)
</summary>
</member>
<member name="M:FSComp.SR.etMethodHasRequirements(System.String,System.String)">
<summary>
 Invalid member &apos;%s&apos; on provided type &apos;%s&apos;. Provided type members must be public, and not be generic, virtual, or abstract.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1177)
</summary>
</member>
<member name="M:FSComp.SR.etInvalidTypeProviderAssemblyName(System.String,System.String)">
<summary>
 Assembly &apos;%s&apos; hase TypeProviderAssembly attribute with invalid value &apos;%s&apos;. The value should be a valid assembly name
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1215)
</summary>
</member>
<member name="M:FSComp.SR.etInvalidStaticArgument(System.String)">
<summary>
 Invalid static argument to provided type. Expected an argument of kind &apos;%s&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1201)
</summary>
</member>
<member name="M:FSComp.SR.etIncorrectProvidedMethod(System.String,System.String,System.Int32,System.String)">
<summary>
 The type provider &apos;%s&apos; provided a method with a name &apos;%s&apos; and metadata token &apos;%d&apos;, which is not reported among its methods of its declaring type &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1194)
</summary>
</member>
<member name="M:FSComp.SR.etIncorrectProvidedConstructor(System.String,System.String)">
<summary>
 The type provider &apos;%s&apos; provided a constructor which is not reported among the constructors of its declaring type &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1195)
</summary>
</member>
<member name="M:FSComp.SR.etIncorrectParameterExpression(System.String,System.String)">
<summary>
 The type provider &apos;%s&apos; used an invalid parameter in the ParameterExpression: %s
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1193)
</summary>
</member>
<member name="M:FSComp.SR.etIllegalCharactersInTypeName(System.String,System.String)">
<summary>
 Character &apos;%s&apos; is not allowed in provided type name &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1223)
</summary>
</member>
<member name="M:FSComp.SR.etIllegalCharactersInNamespaceName(System.String,System.String)">
<summary>
 Character &apos;%s&apos; is not allowed in provided namespace name &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1167)
</summary>
</member>
<member name="M:FSComp.SR.etHostingAssemblyFoundWithoutHosts(System.String,System.String)">
<summary>
 Referenced assembly &apos;%s&apos; has assembly level attribute &apos;%s&apos; but no public type provider classes were found
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1172)
</summary>
</member>
<member name="M:FSComp.SR.etEventNoRemove(System.String,System.String)">
<summary>
 Event &apos;%s&apos; on provided type &apos;%s&apos; has no value from GetRemoveMethod()
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1189)
</summary>
</member>
<member name="M:FSComp.SR.etEventNoAdd(System.String,System.String)">
<summary>
 Event &apos;%s&apos; on provided type &apos;%s&apos; has no value from GetAddMethod()
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1188)
</summary>
</member>
<member name="M:FSComp.SR.etErrorApplyingStaticArgumentsToType">
<summary>
 An error occured applying the static arguments to a provided type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1202)
</summary>
</member>
<member name="M:FSComp.SR.etErasedTypeUsedInGeneration(System.String,System.String)">
<summary>
 The provider &apos;%s&apos; returned a non-generated type &apos;%s&apos; in the context of a set of generated types. Consider adjusting the type provider to only return generated types.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1300)
</summary>
</member>
<member name="M:FSComp.SR.etEmptyNamespaceOfTypeNotAllowed(System.String,System.String)">
<summary>
 Type &apos;%s&apos; from type provider &apos;%s&apos; has an empty namespace. Use &apos;null&apos; for the global namespace.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1173)
</summary>
</member>
<member name="M:FSComp.SR.etEmptyNamespaceNotAllowed(System.String)">
<summary>
 Empty namespace found from the type provider &apos;%s&apos;. Use &apos;null&apos; for the global namespace.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1174)
</summary>
</member>
<member name="M:FSComp.SR.etDirectReferenceToGeneratedTypeNotAllowed(System.String)">
<summary>
 A direct reference to the generated type &apos;%s&apos; is not permitted. Instead, use a type definition, e.g. &apos;type TypeAlias = &lt;path&gt;&apos;. This indicates that a type provider adds generated types to your assembly.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1196)
</summary>
</member>
<member name="M:FSComp.SR.etBadUnnamedStaticArgs">
<summary>
 Named static arguments must come after all unnamed static arguments
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1226)
</summary>
</member>
<member name="M:FSComp.SR.erasedTo">
<summary>
 Erased to
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1306)
</summary>
</member>
<member name="M:FSComp.SR.elSysEnvExitDidntExit">
<summary>
 System.Environment.Exit did not exit
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:246)
</summary>
</member>
<member name="M:FSComp.SR.elDeprecatedOperator">
<summary>
 The treatment of this operator is now handled directly by the F# compiler and its meaning cannot be redefined
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:247)
</summary>
</member>
<member name="M:FSComp.SR.docfileNoXmlSuffix">
<summary>
 The documentation file has no .xml suffix
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1141)
</summary>
</member>
<member name="M:FSComp.SR.descriptionUnavailable">
<summary>
 (description unavailable...)
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1314)
</summary>
</member>
<member name="M:FSComp.SR.delegatesNotAllowedToHaveCurriedSignatures">
<summary>
 Delegates are not allowed to have curried signatures
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:971)
</summary>
</member>
<member name="M:FSComp.SR.customOperationTextLikeZip(System.String)">
<summary>
 %s var in collection
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1242)
</summary>
</member>
<member name="M:FSComp.SR.customOperationTextLikeJoin(System.String,System.String,System.String)">
<summary>
 %s var in collection %s (outerKey = innerKey). Note that parentheses are required after &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1240)
</summary>
</member>
<member name="M:FSComp.SR.customOperationTextLikeGroupJoin(System.String,System.String,System.String)">
<summary>
 %s var in collection %s (outerKey = innerKey) into group. Note that parentheses are required after &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1241)
</summary>
</member>
<member name="M:FSComp.SR.csTypesDoNotSupportOperatorNullable(System.String,System.String)">
<summary>
 None of the types &apos;%s&apos; support the operator &apos;%s&apos;. Consider opening the module &apos;Microsoft.FSharp.Linq.NullableOperators&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:329)
</summary>
</member>
<member name="M:FSComp.SR.csTypesDoNotSupportOperator(System.String,System.String)">
<summary>
 None of the types &apos;%s&apos; support the operator &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:327)
</summary>
</member>
<member name="M:FSComp.SR.csTypeParameterCannotBeNullable">
<summary>
 This type parameter cannot be instantiated to &apos;Nullable&apos;. This is a restriction imposed in order to ensure the meaning of &apos;null&apos; in some CLI languages is not confusing when used in conjunction with &apos;Nullable&apos; values.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:346)
</summary>
</member>
<member name="M:FSComp.SR.csTypeNotCompatibleBecauseOfPrintf(System.String,System.String)">
<summary>
 The type &apos;%s&apos; is not compatible with any of the types %s, arising from the use of a printf-style format string
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:349)
</summary>
</member>
<member name="M:FSComp.SR.csTypeIsNotEnumType(System.String)">
<summary>
 The type &apos;%s&apos; is not a CLI enum type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:343)
</summary>
</member>
<member name="M:FSComp.SR.csTypeIsNotDelegateType(System.String)">
<summary>
 The type &apos;%s&apos; is not a CLI delegate type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:345)
</summary>
</member>
<member name="M:FSComp.SR.csTypeInstantiationLengthMismatch">
<summary>
 Type instantiation length mismatch
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:353)
</summary>
</member>
<member name="M:FSComp.SR.csTypeInferenceMaxDepth">
<summary>
 Type inference problem too complicated (maximum iteration depth reached). Consider adding further type annotations.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:322)
</summary>
</member>
<member name="M:FSComp.SR.csTypeHasNonStandardDelegateType(System.String)">
<summary>
 The type &apos;%s&apos; has a non-standard delegate type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:344)
</summary>
</member>
<member name="M:FSComp.SR.csTypeDoesNotSupportOperatorNullable(System.String,System.String)">
<summary>
 The type &apos;%s&apos; does not support the operator &apos;%s&apos;. Consider opening the module &apos;Microsoft.FSharp.Linq.NullableOperators&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:330)
</summary>
</member>
<member name="M:FSComp.SR.csTypeDoesNotSupportOperator(System.String,System.String)">
<summary>
 The type &apos;%s&apos; does not support the operator &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:328)
</summary>
</member>
<member name="M:FSComp.SR.csTypeDoesNotSupportEquality3(System.String)">
<summary>
 The type &apos;%s&apos; does not support the &apos;equality&apos; constraint because it is a record, union or struct with one or more structural element types which do not support the &apos;equality&apos; constraint. Either avoid the use of equality with this type, or add the &apos;StructuralEquality&apos; attribute to the type to determine which field type does not support equality
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:342)
</summary>
</member>
<member name="M:FSComp.SR.csTypeDoesNotSupportEquality2(System.String)">
<summary>
 The type &apos;%s&apos; does not support the &apos;equality&apos; constraint because it is a function type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:341)
</summary>
</member>
<member name="M:FSComp.SR.csTypeDoesNotSupportEquality1(System.String)">
<summary>
 The type &apos;%s&apos; does not support the &apos;equality&apos; constraint because it has the &apos;NoEquality&apos; attribute
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:340)
</summary>
</member>
<member name="M:FSComp.SR.csTypeDoesNotSupportConversion(System.String,System.String)">
<summary>
 The type &apos;%s&apos; does not support a conversion to the type &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:331)
</summary>
</member>
<member name="M:FSComp.SR.csTypeDoesNotSupportComparison3(System.String)">
<summary>
 The type &apos;%s&apos; does not support the &apos;comparison&apos; constraint because it is a record, union or struct with one or more structural element types which do not support the &apos;comparison&apos; constraint. Either avoid the use of comparison with this type, or add the &apos;StructuralComparison&apos; attribute to the type to determine which field type does not support comparison
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:339)
</summary>
</member>
<member name="M:FSComp.SR.csTypeDoesNotSupportComparison2(System.String)">
<summary>
 The type &apos;%s&apos; does not support the &apos;comparison&apos; constraint. For example, it does not support the &apos;System.IComparable&apos; interface
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:338)
</summary>
</member>
<member name="M:FSComp.SR.csTypeDoesNotSupportComparison1(System.String)">
<summary>
 The type &apos;%s&apos; does not support the &apos;comparison&apos; constraint because it has the &apos;NoComparison&apos; attribute
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:337)
</summary>
</member>
<member name="M:FSComp.SR.csTypeDoesNotHaveNull(System.String)">
<summary>
 The type &apos;%s&apos; does not have &apos;null&apos; as a proper value
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:335)
</summary>
</member>
<member name="M:FSComp.SR.csTypeCannotBeResolvedAtCompileTime(System.String)">
<summary>
 The declared type parameter &apos;%s&apos; cannot be used here since the type parameter cannot be resolved at compile time
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:320)
</summary>
</member>
<member name="M:FSComp.SR.csStructConstraintInconsistent">
<summary>
 The constraints &apos;struct&apos; and &apos;not struct&apos; are inconsistent
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:334)
</summary>
</member>
<member name="M:FSComp.SR.csSeeAvailableOverloads">
<summary>
 The available overloads are shown below (or in the Error List window).
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:383)
</summary>
</member>
<member name="M:FSComp.SR.csRequiredSignatureIs(System.String)">
<summary>
 The required signature is %s
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:365)
</summary>
</member>
<member name="M:FSComp.SR.csOptionalArgumentNotPermittedHere">
<summary>
 Optional arguments not permitted here
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:354)
</summary>
</member>
<member name="M:FSComp.SR.csNullableTypeDoesNotHaveNull(System.String)">
<summary>
 The type &apos;%s&apos; does not have &apos;null&apos; as a proper value. To create a null value for a Nullable type use &apos;System.Nullable()&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:336)
</summary>
</member>
<member name="M:FSComp.SR.csNoOverloadsFound(System.String)">
<summary>
 No overloads match for method &apos;%s&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:380)
</summary>
</member>
<member name="M:FSComp.SR.csNoMemberTakesTheseArguments3(System.String,System.String,System.Int32,System.String)">
<summary>
 No %s member or object constructor named &apos;%s&apos; takes %d arguments. The named argument &apos;%s&apos; doesn&apos;t correspond to any argument or settable return property for any overload.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:378)
</summary>
</member>
<member name="M:FSComp.SR.csNoMemberTakesTheseArguments2(System.String,System.String,System.Int32,System.Int32)">
<summary>
 No %s member or object constructor named &apos;%s&apos; takes %d arguments. Note the call to this member also provides %d named arguments.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:377)
</summary>
</member>
<member name="M:FSComp.SR.csNoMemberTakesTheseArguments(System.String,System.String,System.Int32)">
<summary>
 No %s member or object constructor named &apos;%s&apos; takes %d arguments
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:376)
</summary>
</member>
<member name="M:FSComp.SR.csMethodNotFound(System.String)">
<summary>
 Method or object constructor &apos;%s&apos; not found
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:379)
</summary>
</member>
<member name="M:FSComp.SR.csMethodIsOverloaded(System.String)">
<summary>
 A unique overload for method &apos;%s&apos; could not be determined based on type information prior to this program point. A type annotation may be needed.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:381)
</summary>
</member>
<member name="M:FSComp.SR.csMethodIsNotAnInstanceMethod(System.String)">
<summary>
 %s is not an instance method
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:363)
</summary>
</member>
<member name="M:FSComp.SR.csMethodIsNotAStaticMethod(System.String)">
<summary>
 %s is not a static method
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:362)
</summary>
</member>
<member name="M:FSComp.SR.csMethodFoundButIsStatic(System.String,System.String,System.String)">
<summary>
 The type &apos;%s&apos; has a method &apos;%s&apos; (full name &apos;%s&apos;), but the method is static
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:332)
</summary>
</member>
<member name="M:FSComp.SR.csMethodFoundButIsNotStatic(System.String,System.String,System.String)">
<summary>
 The type &apos;%s&apos; has a method &apos;%s&apos; (full name &apos;%s&apos;), but the method is not static
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:333)
</summary>
</member>
<member name="M:FSComp.SR.csMethodExpectsParams">
<summary>
 This method expects a CLI &apos;params&apos; parameter in this position. &apos;params&apos; is a way of passing a variable number of arguments to a method in languages such as C#. Consider passing an array for this argument
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:359)
</summary>
</member>
<member name="M:FSComp.SR.csMemberSignatureMismatchArityType(System.String,System.Int32,System.Int32,System.String)">
<summary>
 The member or object constructor &apos;%s&apos; takes %d type argument(s) but is here given %d. The required signature is &apos;%s&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:372)
</summary>
</member>
<member name="M:FSComp.SR.csMemberSignatureMismatchArityNamed(System.String,System.Int32,System.Int32,System.Int32,System.String)">
<summary>
 The member or object constructor &apos;%s&apos; requires %d argument(s) but is here given %d unnamed and %d named argument(s). The required signature is &apos;%s&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:370)
</summary>
</member>
<member name="M:FSComp.SR.csMemberSignatureMismatchArity(System.String,System.Int32,System.Int32,System.String)">
<summary>
 The member or object constructor &apos;%s&apos; takes %d argument(s) but is here given %d. The required signature is &apos;%s&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:371)
</summary>
</member>
<member name="M:FSComp.SR.csMemberSignatureMismatch4(System.String,System.Int32,System.String,System.String)">
<summary>
 The member or object constructor &apos;%s&apos; requires %d additional argument(s). The required signature is &apos;%s&apos;. Some names for missing arguments are %s.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:369)
</summary>
</member>
<member name="M:FSComp.SR.csMemberSignatureMismatch3(System.String,System.Int32,System.String,System.String)">
<summary>
 The member or object constructor &apos;%s&apos; requires %d argument(s). The required signature is &apos;%s&apos;. Some names for missing arguments are %s.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:368)
</summary>
</member>
<member name="M:FSComp.SR.csMemberSignatureMismatch2(System.String,System.Int32,System.String)">
<summary>
 The member or object constructor &apos;%s&apos; requires %d additional argument(s). The required signature is &apos;%s&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:367)
</summary>
</member>
<member name="M:FSComp.SR.csMemberSignatureMismatch(System.String,System.Int32,System.String)">
<summary>
 The member or object constructor &apos;%s&apos; requires %d argument(s). The required signature is &apos;%s&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:366)
</summary>
</member>
<member name="M:FSComp.SR.csMemberOverloadArityMismatch(System.String,System.Int32,System.Int32)">
<summary>
 The member or object constructor &apos;%s&apos; does not take %d argument(s). An overload was found taking %d arguments.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:375)
</summary>
</member>
<member name="M:FSComp.SR.csMemberNotAccessible(System.String,System.Int32,System.String,System.Int32)">
<summary>
 The member or object constructor &apos;%s&apos; taking %d arguments are not accessible from this code location. All accessible versions of method &apos;%s&apos; take %d arguments.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:373)
</summary>
</member>
<member name="M:FSComp.SR.csMemberIsNotStatic(System.String)">
<summary>
 %s is not a static member
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:355)
</summary>
</member>
<member name="M:FSComp.SR.csMemberIsNotInstance(System.String)">
<summary>
 %s is not an instance member
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:356)
</summary>
</member>
<member name="M:FSComp.SR.csMemberIsNotAccessible2(System.String,System.String)">
<summary>
 The member or object constructor &apos;%s&apos; is not %s. Private members may only be accessed from within the declaring type. Protected members may only be accessed from an extending type and cannot be accessed from inner lambda expressions.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:361)
</summary>
</member>
<member name="M:FSComp.SR.csMemberIsNotAccessible(System.String,System.String)">
<summary>
 The member or object constructor &apos;%s&apos; is not %s
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:360)
</summary>
</member>
<member name="M:FSComp.SR.csMemberHasNoArgumentOrReturnProperty(System.String,System.String,System.String)">
<summary>
 The member or object constructor &apos;%s&apos; has no argument or settable return property &apos;%s&apos;. %s.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:364)
</summary>
</member>
<member name="M:FSComp.SR.csIndexArgumentMismatch(System.Int32,System.Int32)">
<summary>
 This indexer expects %d arguments but is here given %d
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:324)
</summary>
</member>
<member name="M:FSComp.SR.csIncorrectGenericInstantiation(System.String,System.String,System.Int32)">
<summary>
 Incorrect generic instantiation. No %s member named &apos;%s&apos; takes %d generic arguments.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:374)
</summary>
</member>
<member name="M:FSComp.SR.csGenericConstructRequiresUnmanagedType(System.String)">
<summary>
 A generic construct requires that the type &apos;%s&apos; is an unmanaged type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:348)
</summary>
</member>
<member name="M:FSComp.SR.csGenericConstructRequiresStructType(System.String)">
<summary>
 A generic construct requires that the type &apos;%s&apos; is a CLI or F# struct type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:347)
</summary>
</member>
<member name="M:FSComp.SR.csGenericConstructRequiresReferenceSemantics(System.String)">
<summary>
 A generic construct requires that the type &apos;%s&apos; have reference semantics, but it does not, i.e. it is a struct
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:350)
</summary>
</member>
<member name="M:FSComp.SR.csGenericConstructRequiresPublicDefaultConstructor(System.String)">
<summary>
 A generic construct requires that the type &apos;%s&apos; have a public default constructor
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:352)
</summary>
</member>
<member name="M:FSComp.SR.csGenericConstructRequiresNonAbstract(System.String)">
<summary>
 A generic construct requires that the type &apos;%s&apos; be non-abstract
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:351)
</summary>
</member>
<member name="M:FSComp.SR.csExpectedArguments">
<summary>
 Expected arguments to an instance member
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:323)
</summary>
</member>
<member name="M:FSComp.SR.csExpectTypeWithOperatorButGivenTuple(System.String)">
<summary>
 Expecting a type supporting the operator &apos;%s&apos; but given a tuple type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:326)
</summary>
</member>
<member name="M:FSComp.SR.csExpectTypeWithOperatorButGivenFunction(System.String)">
<summary>
 Expecting a type supporting the operator &apos;%s&apos; but given a function type. You may be missing an argument to a function.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:325)
</summary>
</member>
<member name="M:FSComp.SR.csCodeLessGeneric">
<summary>
 This code is less generic than indicated by its annotations. A unit-of-measure specified using &apos;_&apos; has been determined to be &apos;1&apos;, i.e. dimensionless. Consider making the code generic, or removing the use of &apos;_&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:321)
</summary>
</member>
<member name="M:FSComp.SR.csCandidates(System.String)">
<summary>
 Candidates: %s
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:382)
</summary>
</member>
<member name="M:FSComp.SR.csArgumentTypesDoNotMatch">
<summary>
 The argument types don&apos;t match
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:358)
</summary>
</member>
<member name="M:FSComp.SR.csArgumentLengthMismatch">
<summary>
 Argument length mismatch
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:357)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantSetUnionFields">
<summary>
 Quotations cannot contain expressions that set union case fields
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:309)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantSetExceptionFields">
<summary>
 Quotations cannot contain expressions that set fields in exception values
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:310)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantRequireByref">
<summary>
 Quotations cannot contain expressions that require byref pointers
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:311)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantFetchUnionIndexes">
<summary>
 Quotations cannot contain expressions that fetch union case indexes
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:308)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainThisType">
<summary>
 Quotations cannot contain this kind of type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:316)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainThisPatternMatch">
<summary>
 Quotations cannot contain this kind of pattern match
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:314)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainThisConstant">
<summary>
 Quotations cannot contain this kind of constant
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:313)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainStaticFieldRef">
<summary>
 Quotations cannot contain expressions that fetch static fields
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:305)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainObjExprs">
<summary>
 Quotations cannot contain object expressions
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:303)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainInlineIL">
<summary>
 Quotations cannot contain inline assembly code or pattern matching on arrays
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:306)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainGenericFunctions">
<summary>
 Quotations cannot contain function definitions that are inferred or declared to be generic. Consider adding some type constraints to make this a valid quoted expression.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:302)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainGenericExprs">
<summary>
 Quotations cannot contain uses of generic expressions
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:301)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainDescendingForLoops">
<summary>
 Quotations cannot contain descending for loops
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:307)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainByrefTypes">
<summary>
 Quotations cannot contain byref types
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1308)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainArrayPatternMatching">
<summary>
 Quotations cannot contain array pattern matching
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:315)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainAddressOf">
<summary>
 Quotations cannot contain expressions that take the address of a field
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:304)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantCallTraitMembers">
<summary>
 Quotations cannot contain expressions that make member constraint calls, or uses of operators that implicitly resolve to a member constraint call
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:312)
</summary>
</member>
<member name="M:FSComp.SR.crefNoSetOfHole">
<summary>
 A quotation may not involve an assignment to or taking the address of a captured local variable
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1303)
</summary>
</member>
<member name="M:FSComp.SR.crefNoInnerGenericsInQuotations">
<summary>
 Inner generic functions are not permitted in quoted expressions. Consider adding some type constraints until this function is no longer generic.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1130)
</summary>
</member>
<member name="M:FSComp.SR.crefBoundVarUsedInSplice(System.String)">
<summary>
 The variable &apos;%s&apos; is bound in a quotation but is used as part of a spliced expression. This is not permitted since it may escape its scope.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:300)
</summary>
</member>
<member name="M:FSComp.SR.chkVariableUsedInInvalidWay(System.String)">
<summary>
 The variable &apos;%s&apos; is used in an invalid way
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:255)
</summary>
</member>
<member name="M:FSComp.SR.chkValueWithDefaultValueMustHaveDefaultValue">
<summary>
 The type of a field using the &apos;DefaultValue&apos; attribute must admit default initialization, i.e. have &apos;null&apos; as a proper value or be a struct type whose fields all admit default initialization. You can use &apos;DefaultValue(false)&apos; to disable this check
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:295)
</summary>
</member>
<member name="M:FSComp.SR.chkUnusedValue(System.String)">
<summary>
 The value &apos;%s&apos; is unused
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1079)
</summary>
</member>
<member name="M:FSComp.SR.chkUnusedThisVariable(System.String)">
<summary>
 The recursive object reference &apos;%s&apos; is unused. The presence of a recursive object reference adds runtime initialization checks to members in this and derived types. Consider removing this recursive object reference.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1080)
</summary>
</member>
<member name="M:FSComp.SR.chkUnionCaseDefaultAugmentation">
<summary>
 default augmentation of the union case
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:280)
</summary>
</member>
<member name="M:FSComp.SR.chkUnionCaseCompiledForm">
<summary>
 compiled form of the union case
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:279)
</summary>
</member>
<member name="M:FSComp.SR.chkTypeLessAccessibleThanType(System.String,System.String)">
<summary>
 The type &apos;%s&apos; is less accessible than the value, member or type &apos;%s&apos; it is used in
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:256)
</summary>
</member>
<member name="M:FSComp.SR.chkTyparMultipleClassConstraints">
<summary>
 A type variable has been constrained by multiple different class types. A type variable may only have one class constraint.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1315)
</summary>
</member>
<member name="M:FSComp.SR.chkSystemVoidOnlyInTypeof">
<summary>
 &apos;System.Void&apos; can only be used as &apos;typeof&lt;System.Void&gt;&apos; in F#
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:257)
</summary>
</member>
<member name="M:FSComp.SR.chkSplicingOnlyInQuotations">
<summary>
 Expression-splicing operators may only be used within quotations
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:260)
</summary>
</member>
<member name="M:FSComp.SR.chkReturnTypeNoByref">
<summary>
 A method return type would contain byrefs which is not permitted
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:272)
</summary>
</member>
<member name="M:FSComp.SR.chkReflectedDefCantSplice">
<summary>
 [&lt;ReflectedDefinition&gt;] terms cannot contain uses of the prefix splice operator &apos;%%&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:277)
</summary>
</member>
<member name="M:FSComp.SR.chkProtectedOrBaseCalled">
<summary>
 A protected member is called or &apos;base&apos; is being used. This is only allowed in the direct implementation of members since they could escape their object scope.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:251)
</summary>
</member>
<member name="M:FSComp.SR.chkPropertySameNameMethod(System.String)">
<summary>
 Name clash. The property &apos;%s&apos; has the same name as a method in this type.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:281)
</summary>
</member>
<member name="M:FSComp.SR.chkPropertySameNameIndexer(System.String)">
<summary>
 The property &apos;%s&apos; has the same name as another property in this type, but one takes indexer arguments and the other does not. You may be missing an indexer argument to one of your properties.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:283)
</summary>
</member>
<member name="M:FSComp.SR.chkObjCtorsCantUseExceptionHandling">
<summary>
 Object constructors cannot directly use try/with and try/finally prior to the initialization of the object. This includes constructs such as &apos;for x in ...&apos; that may elaborate to uses of these constructs. This is a limitation imposed by Common IL.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:266)
</summary>
</member>
<member name="M:FSComp.SR.chkNoReflectedDefinitionOnStructMember">
<summary>
 ReflectedDefinitionAttribute may not be applied to an instance member on a struct type, because the instance member takes an implicit &apos;this&apos; byref parameter
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1121)
</summary>
</member>
<member name="M:FSComp.SR.chkNoFirstClassSplicing">
<summary>
 First-class uses of the expression-splicing operator are not permitted
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:261)
</summary>
</member>
<member name="M:FSComp.SR.chkNoFirstClassRethrow">
<summary>
 First-class uses of the &apos;reraise&apos; function is not permitted
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:263)
</summary>
</member>
<member name="M:FSComp.SR.chkNoFirstClassAddressOf">
<summary>
 First-class uses of the address-of operators are not permitted
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:262)
</summary>
</member>
<member name="M:FSComp.SR.chkNoByrefsOfByrefs(System.String)">
<summary>
 Type &apos;%s&apos; is illegal because in byref&lt;T&gt;, T cannot contain byref types.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1284)
</summary>
</member>
<member name="M:FSComp.SR.chkNoByrefInTypeAbbrev">
<summary>
 The type abbreviation contains byrefs. This is not permitted by F#.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:296)
</summary>
</member>
<member name="M:FSComp.SR.chkNoByrefAtThisPoint(System.String)">
<summary>
 The byref typed value &apos;%s&apos; cannot be used at this point
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:264)
</summary>
</member>
<member name="M:FSComp.SR.chkNoByrefAsTopValue">
<summary>
 A byref typed value would be stored here. Top-level let-bound byref values are not permitted.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:276)
</summary>
</member>
<member name="M:FSComp.SR.chkNoAddressStaticFieldAtThisPoint(System.String)">
<summary>
 The address of the static field &apos;%s&apos; cannot be used at this point
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:268)
</summary>
</member>
<member name="M:FSComp.SR.chkNoAddressOfAtThisPoint(System.String)">
<summary>
 The address of the variable &apos;%s&apos; cannot be used at this point
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:267)
</summary>
</member>
<member name="M:FSComp.SR.chkNoAddressOfArrayElementAtThisPoint">
<summary>
 The address of an array element cannot be used at this point
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:270)
</summary>
</member>
<member name="M:FSComp.SR.chkNoAddressFieldAtThisPoint(System.String)">
<summary>
 The address of the field &apos;%s&apos; cannot be used at this point
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:269)
</summary>
</member>
<member name="M:FSComp.SR.chkMutableUsedInInvalidWay(System.String)">
<summary>
 The mutable variable &apos;%s&apos; is used in an invalid way. Mutable variables cannot be captured by closures. Consider eliminating this use of mutation or using a heap-allocated mutable reference cell via &apos;ref&apos; and &apos;!&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:253)
</summary>
</member>
<member name="M:FSComp.SR.chkMultipleGenericInterfaceInstantiations(System.String,System.String)">
<summary>
 This type implements or inherits the same interface at different generic instantiations &apos;%s&apos; and &apos;%s&apos;. This is not permitted in this version of F#.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:294)
</summary>
</member>
<member name="M:FSComp.SR.chkMemberUsedInInvalidWay(System.String,System.String,System.String)">
<summary>
 The member &apos;%s&apos; is used in an invalid way. A use of &apos;%s&apos; has been inferred prior to its definition at or near &apos;%s&apos;. This is an invalid forward reference.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:275)
</summary>
</member>
<member name="M:FSComp.SR.chkLimitationsOfBaseKeyword">
<summary>
 &apos;base&apos; values may only be used to make direct calls to the base implementations of overridden members
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:265)
</summary>
</member>
<member name="M:FSComp.SR.chkInvalidCustAttrVal">
<summary>
 Invalid custom attribute value (not a constant or literal)
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:273)
</summary>
</member>
<member name="M:FSComp.SR.chkGetterSetterDoNotMatchAbstract(System.String)">
<summary>
 The property &apos;%s&apos; has a getter and a setter that do not match. If one is abstract then the other must be as well.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:282)
</summary>
</member>
<member name="M:FSComp.SR.chkGetterAndSetterHaveSamePropertyType(System.String,System.String,System.String)">
<summary>
 A property&apos;s getter and setter must have the same type. Property &apos;%s&apos; has getter of type &apos;%s&apos; but setter of type &apos;%s&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1324)
</summary>
</member>
<member name="M:FSComp.SR.chkFirstClassFuncNoByref">
<summary>
 The type of a first-class function cannot contain byrefs
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:271)
</summary>
</member>
<member name="M:FSComp.SR.chkErrorUseOfByref">
<summary>
 A type instantiation involves a byref type. This is not permitted by the rules of Common IL.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:258)
</summary>
</member>
<member name="M:FSComp.SR.chkErrorContainsCallToRethrow">
<summary>
 Calls to &apos;reraise&apos; may only occur directly in a handler of a try-with
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:259)
</summary>
</member>
<member name="M:FSComp.SR.chkEntryPointUsage">
<summary>
 A function labeled with the &apos;EntryPointAttribute&apos; attribute must be the last declaration in the last file in the compilation sequence, and can only be used when compiling to a .exe
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:278)
</summary>
</member>
<member name="M:FSComp.SR.chkDuplicatePropertyWithSuffix(System.String)">
<summary>
 Duplicate property. The property &apos;%s&apos; has the same name and signature as another property in this type once tuples, functions, units of measure and/or provided types are erased.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:291)
</summary>
</member>
<member name="M:FSComp.SR.chkDuplicateProperty(System.String)">
<summary>
 Duplicate property. The property &apos;%s&apos; has the same name and signature as another property in this type.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:290)
</summary>
</member>
<member name="M:FSComp.SR.chkDuplicateMethodWithSuffix(System.String)">
<summary>
 Duplicate method. The method &apos;%s&apos; has the same name and signature as another method in this type once tuples, functions, units of measure and/or provided types are erased.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:287)
</summary>
</member>
<member name="M:FSComp.SR.chkDuplicateMethodInheritedTypeWithSuffix(System.String)">
<summary>
 Duplicate method. The abstract method &apos;%s&apos; has the same name and signature as an abstract method in an inherited type once tuples, functions, units of measure and/or provided types are erased.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:293)
</summary>
</member>
<member name="M:FSComp.SR.chkDuplicateMethodInheritedType(System.String)">
<summary>
 Duplicate method. The abstract method &apos;%s&apos; has the same name and signature as an abstract method in an inherited type.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:292)
</summary>
</member>
<member name="M:FSComp.SR.chkDuplicateMethodCurried(System.String)">
<summary>
 The method &apos;%s&apos; has curried arguments but has the same name as another method in this type. Methods with curried arguments cannot be overloaded. Consider using a method taking tupled arguments.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:288)
</summary>
</member>
<member name="M:FSComp.SR.chkDuplicateMethod(System.String)">
<summary>
 Duplicate method. The method &apos;%s&apos; has the same name and signature as another method in this type.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:286)
</summary>
</member>
<member name="M:FSComp.SR.chkCurriedMethodsCantHaveOutParams">
<summary>
 Methods with curried arguments cannot declare &apos;out&apos;, &apos;ParamArray&apos;, &apos;optional&apos; or &apos;byref&apos; arguments
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:289)
</summary>
</member>
<member name="M:FSComp.SR.chkCantStoreByrefValue">
<summary>
 A type would store a byref typed value. This is not permitted by Common IL.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:284)
</summary>
</member>
<member name="M:FSComp.SR.chkByrefUsedInInvalidWay(System.String)">
<summary>
 The byref-typed variable &apos;%s&apos; is used in an invalid way. Byrefs cannot be captured by closures or passed to inner functions.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:252)
</summary>
</member>
<member name="M:FSComp.SR.chkBaseUsedInInvalidWay">
<summary>
 The &apos;base&apos; keyword is used in an invalid way. Base calls cannot be used in closures. Consider using a private member to make base calls.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:254)
</summary>
</member>
<member name="M:FSComp.SR.chkAttrHasAllowMultiFalse(System.String)">
<summary>
 The attribute type &apos;%s&apos; has &apos;AllowMultiple=false&apos;. Multiple instances of this attribute cannot be attached to a single language element.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:274)
</summary>
</member>
<member name="M:FSComp.SR.cannotResolveNullableOperators(System.String)">
<summary>
 The operator &apos;%s&apos; cannot be resolved. Consider opening the module &apos;Microsoft.FSharp.Linq.NullableOperators&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1318)
</summary>
</member>
<member name="M:FSComp.SR.buildUnrecognizedOption(System.String)">
<summary>
 Unrecognized option: &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:60)
</summary>
</member>
<member name="M:FSComp.SR.buildUnknownFileSuffix(System.String)">
<summary>
 ParseInput: unknown file suffix for &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:41)
</summary>
</member>
<member name="M:FSComp.SR.buildUnexpectedTypeArgs(System.String,System.Int32)">
<summary>
 The non-generic type &apos;%s&apos; does not expect any type arguments, but here is given %d type argument(s)
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:17)
</summary>
</member>
<member name="M:FSComp.SR.buildUnexpectedFileNameCharacter(System.String,System.String)">
<summary>
 Filename &apos;%s&apos; contains invalid character &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1128)
</summary>
</member>
<member name="M:FSComp.SR.buildSignatureWithoutImplementation(System.String)">
<summary>
 The signature file &apos;%s&apos; does not have a corresponding implementation file. If an implementation file exists then check the &apos;module&apos; and &apos;namespace&apos; declarations in the signature and implementation files match.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:57)
</summary>
</member>
<member name="M:FSComp.SR.buildSignatureAlreadySpecified(System.String)">
<summary>
 A signature for the file or module &apos;%s&apos; has already been specified
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:54)
</summary>
</member>
<member name="M:FSComp.SR.buildSearchDirectoryNotFound(System.String)">
<summary>
 The search directory &apos;%s&apos; could not be found
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:27)
</summary>
</member>
<member name="M:FSComp.SR.buildRequiresCLI2(System.String)">
<summary>
 The file &apos;%s&apos; is a CLI 1.x version of mscorlib. F# requires CLI version 2.0 or greater.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:32)
</summary>
</member>
<member name="M:FSComp.SR.buildProductName(System.String)">
<summary>
 F# Compiler for F# 3.1 %s
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:21)
</summary>
</member>
<member name="M:FSComp.SR.buildProblemWithFilename(System.String,System.String)">
<summary>
 Problem with filename &apos;%s&apos;: %s
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:22)
</summary>
</member>
<member name="M:FSComp.SR.buildProblemReadingAssembly(System.String,System.String)">
<summary>
 Problem reading assembly &apos;%s&apos;: %s
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1311)
</summary>
</member>
<member name="M:FSComp.SR.buildPdbRequiresDebug">
<summary>
 The &apos;--pdb&apos; option requires the &apos;--debug&apos; option to be used
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:25)
</summary>
</member>
<member name="M:FSComp.SR.buildOptionRequiresParameter(System.String)">
<summary>
 Option requires parameter: %s
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:42)
</summary>
</member>
<member name="M:FSComp.SR.buildNoInputsSpecified">
<summary>
 No inputs specified
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:23)
</summary>
</member>
<member name="M:FSComp.SR.buildMultipleToplevelModules">
<summary>
 This file contains multiple declarations of the form &apos;module SomeNamespace.SomeModule&apos;. Only one declaration of this form is permitted in a file. Change your file to use an initial namespace declaration and/or use &apos;module ModuleName = ...&apos; to define your modules.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:40)
</summary>
</member>
<member name="M:FSComp.SR.buildMultipleReferencesNotAllowed(System.String)">
<summary>
 Multiple references to &apos;%s.dll&apos; are not permitted
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:31)
</summary>
</member>
<member name="M:FSComp.SR.buildMultiFileRequiresNamespaceOrModule">
<summary>
 Files in libraries or multiple-file applications must begin with a namespace or module declaration, e.g. &apos;namespace SomeNamespace.SubNamespace&apos; or &apos;module SomeNamespace.SomeModule&apos;. Only the last source file of an application may omit such a declaration.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:39)
</summary>
</member>
<member name="M:FSComp.SR.buildMscorlibAndReferencedAssemblyMismatch(System.String)">
<summary>
 The referenced or default base CLI library &apos;mscorlib&apos; is binary-incompatible with the referenced library &apos;%s&apos;. Consider recompiling the library or making an explicit reference to a version of this library that matches the CLI version you are using.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:34)
</summary>
</member>
<member name="M:FSComp.SR.buildMscorLibAndFSharpCoreMismatch(System.String)">
<summary>
 The referenced or default base CLI library &apos;mscorlib&apos; is binary-incompatible with the referenced F# core library &apos;%s&apos;. Consider recompiling the library or making an explicit reference to a version of this library that matches the CLI version you are using.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:36)
</summary>
</member>
<member name="M:FSComp.SR.buildMismatchOutputExtension">
<summary>
 The output name extension doesn&apos;t match the options used. If &apos;-a&apos; or &apos;--target:library&apos; is used the output file name must end with &apos;.dll&apos;, if &apos;--target:module&apos; is used the output extension must be &apos;.netmodule&apos;, otherwise &apos;.exe&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:24)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidWarningNumber(System.String)">
<summary>
 Invalid warning number &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:18)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidVersionString(System.String)">
<summary>
 Invalid version string &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:19)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidVersionFile(System.String)">
<summary>
 Invalid version file &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:20)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidSourceFileExtension(System.String)">
<summary>
 The file extension of &apos;%s&apos; is not recognized. Source files must have extension .fs, .fsi, .fsx, .fsscript, .ml or .mli.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:44)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidSearchDirectory(System.String)">
<summary>
 The search directory &apos;%s&apos; is invalid
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:26)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidPrivacy(System.String)">
<summary>
 Unrecognized privacy setting &apos;%s&apos; for managed resource, valid options are &apos;public&apos; and &apos;private&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:30)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidModuleOrNamespaceName">
<summary>
 Invalid module or namespace name
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:61)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidHashtimeDirective">
<summary>
 Invalid directive. Expected &apos;#time&apos;, &apos;#time \&quot;on\&quot;&apos; or &apos;#time \&quot;off\&quot;&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:52)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidHashrDirective">
<summary>
 Invalid directive. Expected &apos;#r \&quot;&lt;file-or-assembly&gt;\&quot;&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:50)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidHashloadDirective">
<summary>
 Invalid directive. Expected &apos;#load \&quot;&lt;file&gt;\&quot; ... \&quot;&lt;file&gt;\&quot;&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:51)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidHashIDirective">
<summary>
 Invalid directive. Expected &apos;#I \&quot;&lt;path&gt;\&quot;&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:49)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidFilename(System.String)">
<summary>
 &apos;%s&apos; is not a valid filename
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:28)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidAssemblyName(System.String)">
<summary>
 &apos;%s&apos; is not a valid assembly name
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:29)
</summary>
</member>
<member name="M:FSComp.SR.buildImplicitModuleIsNotLegalIdentifier(System.String,System.String)">
<summary>
 The declarations in this file will be placed in an implicit module &apos;%s&apos; based on the file name &apos;%s&apos;. However this is not a valid F# identifier, so the contents will not be accessible from other files. Consider renaming the file or adding a &apos;module&apos; or &apos;namespace&apos; declaration at the top of the file.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:38)
</summary>
</member>
<member name="M:FSComp.SR.buildImplementationAlreadyGivenDetail(System.String)">
<summary>
 An implementation of file or module &apos;%s&apos; has already been given. Compilation order is significant in F# because of type inference. You may need to adjust the order of your files to place the signature file before the implementation. In Visual Studio files are type-checked in the order they appear in the project file, which can be edited manually or adjusted using the solution explorer.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:55)
</summary>
</member>
<member name="M:FSComp.SR.buildImplementationAlreadyGiven(System.String)">
<summary>
 An implementation of the file or module &apos;%s&apos; has already been given
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:56)
</summary>
</member>
<member name="M:FSComp.SR.buildExplicitCoreLibRequiresNoFramework(System.String)">
<summary>
 When mscorlib.dll or FSharp.Core.dll is explicitly referenced the %s option must also be passed
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1123)
</summary>
</member>
<member name="M:FSComp.SR.buildExpectedSigdataFile">
<summary>
 FSharp.Core.sigdata not found alongside FSharp.Core
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1124)
</summary>
</member>
<member name="M:FSComp.SR.buildExpectedFileAlongSideFSharpCore(System.String)">
<summary>
 File &apos;%s&apos; not found alongside FSharp.Core
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1126)
</summary>
</member>
<member name="M:FSComp.SR.buildErrorOpeningBinaryFile(System.String,System.String)">
<summary>
 Error opening binary file &apos;%s&apos;: %s
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:47)
</summary>
</member>
<member name="M:FSComp.SR.buildDirectivesInModulesAreIgnored">
<summary>
 Directives inside modules are ignored
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:53)
</summary>
</member>
<member name="M:FSComp.SR.buildDifferentVersionMustRecompile(System.String)">
<summary>
 The F#-compiled DLL &apos;%s&apos; needs to be recompiled to be used with this version of F#
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:48)
</summary>
</member>
<member name="M:FSComp.SR.buildDidNotExpectSigdataResource">
<summary>
 Did not expect to find sigdata resource in FSharp.Core.dll
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1127)
</summary>
</member>
<member name="M:FSComp.SR.buildDidNotExpectOptDataResource">
<summary>
 Did not expect to find optdata resource in FSharp.Core.dll
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1125)
</summary>
</member>
<member name="M:FSComp.SR.buildCouldNotResolveAssemblyRequiredByFile(System.String,System.String)">
<summary>
 Could not resolve assembly &apos;%s&apos; required by &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:46)
</summary>
</member>
<member name="M:FSComp.SR.buildCouldNotResolveAssembly(System.String)">
<summary>
 Could not resolve assembly &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:45)
</summary>
</member>
<member name="M:FSComp.SR.buildCouldNotReadVersionInfoFromMscorlib">
<summary>
 Could not read version from mscorlib.dll
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:33)
</summary>
</member>
<member name="M:FSComp.SR.buildCouldNotFindSourceFile(System.String)">
<summary>
 Source file &apos;%s&apos; could not be found
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:43)
</summary>
</member>
<member name="M:FSComp.SR.buildCompilingExtensionIsForML">
<summary>
 The file extensions &apos;.ml&apos; and &apos;.mli&apos; are for ML compatibility
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1108)
</summary>
</member>
<member name="M:FSComp.SR.buildCannotReadAssembly(System.String)">
<summary>
 Unable to read assembly &apos;%s&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:35)
</summary>
</member>
<member name="M:FSComp.SR.buildAssemblyResolutionFailed">
<summary>
 Assembly resolution failure at or near this location
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:37)
</summary>
</member>
<member name="M:FSComp.SR.buildArgInvalidInt(System.String)">
<summary>
 &apos;%s&apos; is not a valid integer argument
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:58)
</summary>
</member>
<member name="M:FSComp.SR.buildArgInvalidFloat(System.String)">
<summary>
 &apos;%s&apos; is not a valid floating point argument
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:59)
</summary>
</member>
<member name="M:FSComp.SR.augTypeCantHaveRefEqAndStructAttrs">
<summary>
 A type cannot have both the &apos;ReferenceEquality&apos; and &apos;StructuralEquality&apos; or &apos;StructuralComparison&apos; attributes
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:217)
</summary>
</member>
<member name="M:FSComp.SR.augStructEqNeedsNoCompOrStructComp">
<summary>
 The &apos;StructuralEquality&apos; attribute must be used in conjunction with the &apos;NoComparison&apos; or &apos;StructuralComparison&apos; attributes
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:216)
</summary>
</member>
<member name="M:FSComp.SR.augStructCompNeedsStructEquality">
<summary>
 The &apos;StructuralComparison&apos; attribute must be used in conjunction with the &apos;StructuralEquality&apos; attribute
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:215)
</summary>
</member>
<member name="M:FSComp.SR.augRefEqCantHaveObjEquals">
<summary>
 A type with attribute &apos;ReferenceEquality&apos; cannot have an explicit implementation of &apos;Object.Equals(obj)&apos;, &apos;System.IEquatable&lt;_&gt;&apos; or &apos;System.Collections.IStructuralEquatable&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:219)
</summary>
</member>
<member name="M:FSComp.SR.augOnlyCertainTypesCanHaveAttrs">
<summary>
 Only record, union, exception and struct types may be augmented with the &apos;ReferenceEquality&apos;, &apos;StructuralEquality&apos; and &apos;StructuralComparison&apos; attributes
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:218)
</summary>
</member>
<member name="M:FSComp.SR.augNoRefEqualsOnStruct">
<summary>
 The &apos;ReferenceEquality&apos; attribute cannot be used on structs. Consider using the &apos;StructuralEquality&apos; attribute instead, or implement an override for &apos;System.Object.Equals(obj)&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:212)
</summary>
</member>
<member name="M:FSComp.SR.augNoEqualityNeedsNoComparison">
<summary>
 The &apos;NoEquality&apos; attribute must be used in conjunction with the &apos;NoComparison&apos; attribute
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:214)
</summary>
</member>
<member name="M:FSComp.SR.augNoEqNeedsNoObjEquals">
<summary>
 A type with attribute &apos;NoEquality&apos; should not usually have an explicit implementation of &apos;Object.Equals(obj)&apos;. Disable this warning if this is intentional for interoperability purposes
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:222)
</summary>
</member>
<member name="M:FSComp.SR.augNoCompCantImpIComp">
<summary>
 A type with attribute &apos;NoComparison&apos; should not usually have an explicit implementation of &apos;System.IComparable&apos;, &apos;System.IComparable&lt;_&gt;&apos; or &apos;System.Collections.IStructuralComparable&apos;. Disable this warning if this is intentional for interoperability purposes
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:223)
</summary>
</member>
<member name="M:FSComp.SR.augInvalidAttrs">
<summary>
 This type uses an invalid mix of the attributes &apos;NoEquality&apos;, &apos;ReferenceEquality&apos;, &apos;StructuralEquality&apos;, &apos;NoComparison&apos; and &apos;StructuralComparison&apos; attributes
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:213)
</summary>
</member>
<member name="M:FSComp.SR.augCustomEqNeedsObjEquals">
<summary>
 A type with attribute &apos;CustomEquality&apos; must have an explicit implementation of at least one of &apos;Object.Equals(obj)&apos;, &apos;System.IEquatable&lt;_&gt;&apos; or &apos;System.Collections.IStructuralEquatable&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:220)
</summary>
</member>
<member name="M:FSComp.SR.augCustomEqNeedsNoCompOrCustomComp">
<summary>
 The &apos;CustomEquality&apos; attribute must be used in conjunction with the &apos;NoComparison&apos; or &apos;CustomComparison&apos; attributes
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:224)
</summary>
</member>
<member name="M:FSComp.SR.augCustomCompareNeedsIComp">
<summary>
 A type with attribute &apos;CustomComparison&apos; must have an explicit implementation of at least one of &apos;System.IComparable&apos; or &apos;System.Collections.IStructuralComparable&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:221)
</summary>
</member>
<member name="M:FSComp.SR.astParseEmbeddedILTypeError">
<summary>
 Error while parsing embedded IL type
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:206)
</summary>
</member>
<member name="M:FSComp.SR.astParseEmbeddedILError">
<summary>
 Error while parsing embedded IL
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:205)
</summary>
</member>
<member name="M:FSComp.SR.astInvalidExprLeftHandOfAssignment">
<summary>
 Invalid expression on left of assignment
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:208)
</summary>
</member>
<member name="M:FSComp.SR.astDeprecatedIndexerNotation">
<summary>
 This indexer notation has been removed from the F# language
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:207)
</summary>
</member>
<member name="M:FSComp.SR.assemblyResolutionNetFramework">
<summary>
 .NET Framework
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:954)
</summary>
</member>
<member name="M:FSComp.SR.assemblyResolutionGAC">
<summary>
 Global Assembly Cache
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:955)
</summary>
</member>
<member name="M:FSComp.SR.assemblyResolutionFoundByAssemblyFoldersKey">
<summary>
 Found by AssemblyFolders registry key
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:952)
</summary>
</member>
<member name="M:FSComp.SR.assemblyResolutionFoundByAssemblyFoldersExKey">
<summary>
 Found by AssemblyFoldersEx registry key
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:953)
</summary>
</member>
<member name="M:FSComp.SR.activePatternIdentIsNotFunctionTyped(System.String)">
<summary>
 Active pattern &apos;%s&apos; is not a function
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1110)
</summary>
</member>
<member name="M:FSComp.SR.activePatternChoiceHasFreeTypars(System.String)">
<summary>
 Active pattern &apos;%s&apos; has a result type containing type variables that are not determined by the input. The common cause is a when a result case is not mentioned, e.g. &apos;let (|A|B|) (x:int) = A x&apos;. This can be fixed with a type constraint, e.g. &apos;let (|A|B|) (x:int) : Choice&lt;int,unit&gt; = A x&apos;
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:1111)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityVirtualsDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nOne is virtual and the other isn&apos;t
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:114)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityTypesDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe types differ
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:106)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityStaticsDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nOne is static and the other isn&apos;t
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:113)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityStaticButInstance(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe compiled representation of this method is as a static member but the signature indicates its compiled representation is as an instance member
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:119)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityParameterCountsDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe respective type parameter counts differ
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:105)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityOverridesDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nOne is marked as an override and the other isn&apos;t
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:117)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityOneIsTypeFunction(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nOne is a type function and the other is not. The signature requires explicit type parameters if they are present in the implementation.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:104)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityOneIsConstructor(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nOne is a constructor/property and the other is not
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:118)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityNamesDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe names differ
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:98)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityLiteralConstantValuesDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe literal constant values and/or attributes differ
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:103)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityInstanceButStatic(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe compiled representation of this method is as an instance member, but the signature indicates its compiled representation is as a static member
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:120)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityInlineFlagsDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe inline flags differ
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:102)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityGenericParametersDiffer(System.String,System.String,System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe number of generic parameters in the signature and implementation differ (the signature declares %s but the implementation declares %s
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:109)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityGenericParametersAreDifferentKinds(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe generic parameters in the signature and implementation have different kinds. Perhaps there is a missing [&lt;Measure&gt;] attribute.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:110)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityFinalsDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nOne is final and the other isn&apos;t
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:116)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityExtensionsDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nOne is an extension member and the other is not
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:107)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityDotNetNamesDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe CLI member names differ
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:112)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityDisplayNamesDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe display names differ
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:100)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityCompiledNamesDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe compiled names differ
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:99)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityAttributesDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe mutability attributes differ
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:97)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityArityNotInferred(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nAn arity was not inferred for this value
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:108)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityAritiesDiffer(System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe arities in the signature and implementation differ. The signature specifies that &apos;%s&apos; is function definition or lambda expression accepting at least %s argument(s), but the implementation is a computed function value. To declare that a computed function value is a permitted implementation simply parenthesize its type in the signature, e.g.\n\tval %s: int -&gt; (int -&gt; int)\ninstead of\n\tval %s: int -&gt; int -&gt; int.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:111)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityAccessibilityMore(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe accessibility specified in the signature is more than that specified in the implementation
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:101)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityAbstractsDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nOne is abstract and the other isn&apos;t
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:115)
</summary>
</member>
<member name="M:FSComp.SR.RunStartupValidation">
<summary>
 Call this method once to validate that all known resources are valid; throws if not
</summary>
</member>
<member name="M:FSComp.SR.ModuleContainsConstructorButTypesOfFieldsDiffer(System.String,System.String)">
<summary>
 The module contains the constructor\n    %s    \nbut its signature specifies\n    %s    \nThe types of the fields differ
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:155)
</summary>
</member>
<member name="M:FSComp.SR.ModuleContainsConstructorButNamesDiffer(System.String,System.String)">
<summary>
 The module contains the constructor\n    %s    \nbut its signature specifies\n    %s    \nThe names differ
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:153)
</summary>
</member>
<member name="M:FSComp.SR.ModuleContainsConstructorButDataFieldsDiffer(System.String,System.String)">
<summary>
 The module contains the constructor\n    %s    \nbut its signature specifies\n    %s    \nThe respective number of data fields differ
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:154)
</summary>
</member>
<member name="M:FSComp.SR.ModuleContainsConstructorButAccessibilityDiffers(System.String,System.String)">
<summary>
 The module contains the constructor\n    %s    \nbut its signature specifies\n    %s    \nthe accessibility specified in the signature is more than that specified in the implementation
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:156)
</summary>
</member>
<member name="M:FSComp.SR.InvalidRecursiveReferenceToAbstractSlot">
<summary>
 Invalid recursive reference to an abstract slot
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:960)
</summary>
</member>
<member name="M:FSComp.SR.FieldNotContainedTypesDiffer(System.String,System.String)">
<summary>
 The module contains the field\n    %s    \nbut its signature specifies\n    %s    \nThe types differ
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:162)
</summary>
</member>
<member name="M:FSComp.SR.FieldNotContainedStaticsDiffer(System.String,System.String)">
<summary>
 The module contains the field\n    %s    \nbut its signature specifies\n    %s    \nThe &apos;static&apos; modifiers differ
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:159)
</summary>
</member>
<member name="M:FSComp.SR.FieldNotContainedNamesDiffer(System.String,System.String)">
<summary>
 The module contains the field\n    %s    \nbut its signature specifies\n    %s    \nThe names differ
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:157)
</summary>
</member>
<member name="M:FSComp.SR.FieldNotContainedMutablesDiffer(System.String,System.String)">
<summary>
 The module contains the field\n    %s    \nbut its signature specifies\n    %s    \nThe &apos;mutable&apos; modifiers differ
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:160)
</summary>
</member>
<member name="M:FSComp.SR.FieldNotContainedLiteralsDiffer(System.String,System.String)">
<summary>
 The module contains the field\n    %s    \nbut its signature specifies\n    %s    \nThe &apos;literal&apos; modifiers differ
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:161)
</summary>
</member>
<member name="M:FSComp.SR.FieldNotContainedAccessibilitiesDiffer(System.String,System.String)">
<summary>
 The module contains the field\n    %s    \nbut its signature specifies\n    %s    \nthe accessibility specified in the signature is more than that specified in the implementation
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:158)
</summary>
</member>
<member name="M:FSComp.SR.ExceptionDefsNotCompatibleSignaturesDiffer(System.String,System.String)">
<summary>
 The exception definitions are not compatible because the exception abbreviations in the signature and implementation differ. The module contains the exception definition\n    %s    \nbut its signature specifies\n\t%s.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:181)
</summary>
</member>
<member name="M:FSComp.SR.ExceptionDefsNotCompatibleHiddenBySignature(System.String,System.String)">
<summary>
 The exception definitions are not compatible because a CLI exception mapping is being hidden by a signature. The exception mapping must be visible to other modules. The module contains the exception definition\n    %s    \nbut its signature specifies\n\t%s
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:178)
</summary>
</member>
<member name="M:FSComp.SR.ExceptionDefsNotCompatibleFieldOrderDiffers(System.String,System.String)">
<summary>
 The exception definitions are not compatible because the order of the fields is different in the signature and implementation. The module contains the exception definition\n    %s    \nbut its signature specifies\n\t%s.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:185)
</summary>
</member>
<member name="M:FSComp.SR.ExceptionDefsNotCompatibleFieldInSigButNotImpl(System.String,System.String,System.String)">
<summary>
 The exception definitions are not compatible because the field &apos;%s&apos; was required by the signature but was not specified by the implementation. The module contains the exception definition\n    %s    \nbut its signature specifies\n\t%s.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:183)
</summary>
</member>
<member name="M:FSComp.SR.ExceptionDefsNotCompatibleFieldInImplButNotSig(System.String,System.String,System.String)">
<summary>
 The exception definitions are not compatible because the field &apos;%s&apos; was present in the implementation but not in the signature. The module contains the exception definition\n    %s    \nbut its signature specifies\n\t%s.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:184)
</summary>
</member>
<member name="M:FSComp.SR.ExceptionDefsNotCompatibleExceptionDeclarationsDiffer(System.String,System.String)">
<summary>
 The exception definitions are not compatible because the exception declarations differ. The module contains the exception definition\n    %s    \nbut its signature specifies\n\t%s.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:182)
</summary>
</member>
<member name="M:FSComp.SR.ExceptionDefsNotCompatibleDotNetRepresentationsDiffer(System.String,System.String)">
<summary>
 The exception definitions are not compatible because the CLI representations differ. The module contains the exception definition\n    %s    \nbut its signature specifies\n\t%s
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:179)
</summary>
</member>
<member name="M:FSComp.SR.ExceptionDefsNotCompatibleAbbreviationHiddenBySignature(System.String,System.String)">
<summary>
 The exception definitions are not compatible because the exception abbreviation is being hidden by the signature. The abbreviation must be visible to other CLI languages. Consider making the abbreviation visible in the signature. The module contains the exception definition\n    %s    \nbut its signature specifies\n\t%s.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:180)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleTypesHaveDifferentBaseTypes(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the types have different base types
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:133)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleTypeIsHidden(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because a type representation is being hidden by a signature
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:139)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleTypeIsDifferentKind(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the types are of different kinds
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:140)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleSignatureSaysNull2(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the signature says this type may use nulls as an extra value but the implementation does not
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:128)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleSignatureSaysNull(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the signature says this type may use nulls as a representation but the implementation does not
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:127)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleSignatureIsAbstract(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the signature is an abstract class but the implementation is not. Consider adding the [&lt;AbstractClass&gt;] attribute to the implementation.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:132)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleSignatureDefinesButImplDoesNot(System.String,System.String,System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the signature defines the %s &apos;%s&apos; but the implementation does not (or does, but not in the same order)
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:135)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleSignatureDeclaresDiffer(System.String,System.String,System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the signature declares a %s while the implementation declares a %s
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:149)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleSigHasAbbreviation(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the signature has an abbreviation while the implementation does not
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:152)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleRepresentationsDiffer(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the representations differ
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:142)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleParameterCountsDiffer(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the respective type parameter counts differ
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:122)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleNumbersDiffer(System.String,System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the number of %ss differ
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:134)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleNamesDiffer(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the names differ
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:121)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleMissingInterface(System.String,System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the signature requires that the type supports the interface %s but the interface has not been implemented
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:124)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleImplementationSealed(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the implementation type is sealed but the signature implies it is not. Consider adding the [&lt;Sealed&gt;] attribute to the signature.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:129)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleImplementationSaysNull2(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the implementation says this type may use nulls as an extra value but the signature does not
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:126)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleImplementationSaysNull(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the implementation says this type may use nulls as a representation but the signature does not
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:125)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleImplementationIsNotSealed(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the implementation type is not sealed but signature implies it is. Consider adding the [&lt;Sealed&gt;] attribute to the implementation.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:130)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleImplementationIsAbstract(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the implementation is an abstract class but the signature is not. Consider adding the [&lt;AbstractClass&gt;] attribute to the signature.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:131)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleImplDefinesStruct(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the implementation defines a struct but the signature defines a type with a hidden representation
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:137)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleImplDefinesButSignatureDoesNot(System.String,System.String,System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the implementation defines the %s &apos;%s&apos; but the signature does not (or does, but not in the same order)
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:136)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleILDiffer(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the IL representations differ
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:141)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleFieldWasPresent(System.String,System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the field %s was present in the implementation but not in the signature
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:143)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleFieldRequiredButNotSpecified(System.String,System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the field %s was required by the signature but was not specified by the implementation
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:145)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleFieldOrderDiffer(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the order of the fields is different in the signature and implementation
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:144)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleFieldIsInImplButNotSig(System.String,System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the field &apos;%s&apos; was present in the implementation but not in the signature. Struct types must now reveal their fields in the signature for the type, though the fields may still be labelled &apos;private&apos; or &apos;internal&apos;.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:146)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleDotNetTypeRepresentationIsHidden(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because a CLI type representation is being hidden by a signature
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:138)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleAccessibilityDiffer(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the accessibility specified in the signature is more than that specified in the implementation
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:123)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInSig(System.String,System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the abstract member &apos;%s&apos; was present in the implementation but not in the signature
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:148)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInImpl(System.String,System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the abstract member &apos;%s&apos; was required by the signature but was not specified by the implementation
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:147)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleAbbreviationsDiffer(System.String,System.String,System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the abbreviations differ: %s versus %s
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:150)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleAbbreviationHiddenBySig(System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because an abbreviation is being hidden by a signature. The abbreviation must be visible to other CLI languages. Consider making the abbreviation visible in the signature.
 (Originally from C:\Code\fsharp\src\fsharp\FSComp.txt:151)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Internal.Utilities.QueueList`1.System-Collections-Generic-IEnumerable`1-GetEnumerator">
<summary>
 Note this operation is O(n) anyway, so executing ToFlatList() here is OK
</summary>
</member>
<member name="M:Internal.Utilities.QueueList`1.AppendOne(`0)">
<summary>
 Note this operation is O(1), unless a push happens, which is rare 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Internal.Utilities.QueueList`1">
<summary>
 Iterable functional collection with O(1) append-1 time. Useful for data structures where elements get added at the
 end but the collection must occadionally be iterated. Iteration is slower and may allocate because 
 a suffix of elements is stored in reverse order.

 The type doesn&apos;t support structural hashing or comparison.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.AgedLookup`2.TryPeekKeyValue(`0)">
<summary>
 Lookup the value without making it the most recent.
 Returns the original key value because the areSame function
 may have unified two different keys.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.AgedLookup`2.TryGetKeyValue(`0)">
<summary>
 Lookup a value and make it the most recent.
 Returns the original key value because the areSame function
 may have unified two different keys.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.AgedLookup`2.TryGet(`0)">
<summary>
 Lookup a value and make it the most recent. Return None if it wasn&apos;t there.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.AgedLookup`2.Remove(`0)">
<summary>
 Remove the given value from the collection.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.AgedLookup`2.Put(`0,`1)">
<summary>
 Add an element to the collection. Make it the most recent.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.AgedLookup`2.Clear">
<summary>
 Remove all elements.
</summary>
</member>
<member name="">

</member>
<member name="T:Internal.Utilities.Collections.AgedLookup`2">
<summary>
 Simple aging lookup table. When a member is accessed it&apos;s
 moved to the top of the list and when there are too many elements
 the least-recently-accessed element falls of the end.
</summary>
</member>
<member name="P:Internal.Utilities.Collections.HashMultiMap`2.Item(`0,`1)">
<summary>
 Lookup or set the given element in the table. Set replaces all existing bindings for a value with a single
 bindings. Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if the element is not found.
</summary>
</member>
<member name="P:Internal.Utilities.Collections.HashMultiMap`2.Item(`0)">
<summary>
 Lookup or set the given element in the table. Set replaces all existing bindings for a value with a single
 bindings. Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if the element is not found.
</summary>
</member>
<member name="P:Internal.Utilities.Collections.HashMultiMap`2.Count">
<summary>
 The total number of keys in the hash table
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.TryFind(`0)">
<summary>
 Lookup the given element in the table, returning the result as an Option
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.Replace(`0,`1)">
<summary>
 Replace the latest binding (if any) for the given element.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.Remove(`0)">
<summary>
 Remove the latest binding (if any) for the given element from the table
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.Iterate(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.Unit}})">
<summary>
Apply the given function to each binding in the hash table 
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.Fold``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.FSharpFunc{``0,``0}}},``0)">
<summary>
 Apply the given function to each element in the collection threading the accumulating parameter
 through the sequence of function applications
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.FindAll(`0)">
<summary>
 Find all bindings for the given element in the table, if any
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.Copy">
<summary>
 Make a shallow copy of the collection
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.ContainsKey(`0)">
<summary>
 Test if the collection contains any bindings for the given element
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.Clear">
<summary>
 Clear all elements from the collection
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.Add(`0,`1)">
<summary>
 Add a binding for the element to the table
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.#ctor(System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
<summary>
 Build a map that contains the bindings of the given IEnumerable
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
<summary>
 Create a new empty mutable HashMultiMap with an internal bucket array of the given approximate size
 and with the given key hash/equality functions
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
<summary>
 Create a new empty mutable HashMultiMap with the given key hash/equality functions
</summary>
</member>
<member name="T:Internal.Utilities.Collections.HashMultiMap`2">
<summary>
 Hash tables, by default based on F# structural &quot;hash&quot; and (=) functions. 
 The table may map a single key to multiple bindings.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.List.referenceDistinct``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Return each distinct item in the list using reference equality.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.List.groupByFirst``2(Microsoft.FSharp.Collections.FSharpList{System.Tuple{``0,``1}})">
<summary>
 Return a new list with one element for each unique &apos;TKey. Multiple &apos;TValues are flattened. The original order of the first instance of &apos;TKey is preserved.
</summary>
</member>
<member name="">

</member>
<member name="P:Internal.Utilities.Collections.MruCache`2.MostRecent">
<summary>
 Get the most recent item if there is one.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.MruCache`2.SetAlternate(`0,`1)">
<summary>
 Set the value for the given key. This value does not have to agree with computed value.           
</summary>
</member>
<member name="M:Internal.Utilities.Collections.MruCache`2.Remove(`0)">
<summary>
 Remove the given value from the mru cache.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.MruCache`2.GetAvailable(`0)">
<summary>
 Get the value for the given key or None if not already available
</summary>
</member>
<member name="M:Internal.Utilities.Collections.MruCache`2.Get(`0)">
<summary>
 Get the value for the given key. Compute if necessary.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.MruCache`2.Clear">
<summary>
 Clear out the cache.
</summary>
</member>
<member name="">

</member>
<member name="T:Internal.Utilities.Collections.MruCache`2">
<summary>
 Simple priority caching for a small number of key\value associations.
 This cache may age-out results that have been Set by the caller.
 Because of this, the caller must be able to tolerate values 
 that aren&apos;t what was originally passed to the Set function.         
</summary>
</member>
<member name="">

</member>
<member name="P:Internal.Utilities.Collections.Tagged.Map`3.Item(`0)">
<summary>
 Lookup an element in the map. Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if no binding
 exists in the map.
</summary>
</member>
<member name="P:Internal.Utilities.Collections.Tagged.Map`3.IsEmpty">
<summary>
 Return true if there are no bindings in the map.
</summary>
</member>
<member name="P:Internal.Utilities.Collections.Tagged.Map`3.Count">
<summary>
 The number of bindings in the map
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.TryFind(`0)">
<summary>
 Lookup an element in the map, returning a &lt;c&gt;Some&lt;/c&gt; value if the element is in the domain 
 of the map and &lt;c&gt;None&lt;/c&gt; if not.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.ToList">
<summary>
 The elements of the set as a list.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.ToArray">
<summary>
 The elements of the set as an array
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.Remove(`0)">
<summary>
 Remove an element from the domain of the map.  No exception is raised if the element is not present.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.Partition(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,System.Boolean}})">
<summary>
 Build two new maps, one containing the bindings for which the given predicate returns &apos;true&apos;,
 and the other the remaining bindings.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.MapRange``1(Microsoft.FSharp.Core.FSharpFunc{`1,``0})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to each of the elements of the collection.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.Map``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,``0}})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The index passed to the
 function indicates the index of element being transformed.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.Iterate(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.Unit}})">
<summary>
 Apply the given function to each binding in the dictionary
</summary>
</member>
<member name="">

</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.ForAll(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,System.Boolean}})">
<summary>
 Return true if the given predicate returns true for all of the
 bindings in the map. Always returns true if the map is empty.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.FoldSection``1(`0,`0,Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.FSharpFunc{``0,``0}}},``0)">
<summary>
 Given the start and end points of a key range,
 Fold over the bindings in the map that are in the range,
 and the end points are included if present (the range is considered a closed interval).
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.FoldAndMap``2(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{``1,``0}}}},``0)">
<summary>
 Fold over the bindings in the map.  
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.Fold``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.FSharpFunc{``0,``0}}},``0)">
<summary>
 Fold over the bindings in the map.  
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.First``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.FSharpOption{``0}}})">
<summary>
 Search the map looking for the first element where the given function returns a &lt;c&gt;Some&lt;/c&gt; value
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.Filter(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,System.Boolean}})">
<summary>
 Build a new map containing the bindings for which the given predicate returns &apos;true&apos;.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.Exists(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,System.Boolean}})">
<summary>
 Return true if the given predicate returns true for one of the
 bindings in the map. Always returns false if the map is empty.
</summary>
</member>
<member name="">

</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.Empty(`2)">
<summary>
 The empty map, and use the given comparer comparison function for all operations associated
 with any maps built from this map.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.Create(`2,System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}})">
<summary>
 Build a map that contains the bindings of the given IEnumerable
 and where comparison of elements is based on the given comparison function
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.ContainsKey(`0)">
<summary>
 Test is an element is in the domain of the map
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.Add(`0,`1)">
<summary>
 Return a new map with the binding added to the given map.
</summary>
</member>
<member name="T:Internal.Utilities.Collections.Tagged.Map`3">
<summary>
 Immutable maps.  Keys are ordered by construction function specified
 when creating empty maps or by F# structural comparison if no
 construction function is specified.

 &lt;performance&gt; 
   Maps based on structural comparison are  
   efficient for small keys. They are not a suitable choice if keys are recursive data structures 
   or require non-structural comparison semantics.
 &lt;/performance&gt;
 Immutable maps.  A constraint tag carries information about the class of key-comparers being used.  
</summary>
</member>
<member name="">

</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.op_Subtraction(Internal.Utilities.Collections.Tagged.Set{`0,`1},Internal.Utilities.Collections.Tagged.Set{`0,`1})">
<summary>
 Return a new set with the elements of the second set removed from the first.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.op_Addition(Internal.Utilities.Collections.Tagged.Set{`0,`1},Internal.Utilities.Collections.Tagged.Set{`0,`1})">
<summary>
 Compute the union of the two sets.
</summary>
</member>
<member name="P:Internal.Utilities.Collections.Tagged.Set`2.MinimumElement">
<summary>
 Returns the lowest element in the set according to the ordering being used for the set
</summary>
</member>
<member name="P:Internal.Utilities.Collections.Tagged.Set`2.MaximumElement">
<summary>
 Returns the highest element in the set according to the ordering being used for the set
</summary>
</member>
<member name="P:Internal.Utilities.Collections.Tagged.Set`2.IsEmpty">
<summary>
 A useful shortcut for Set.isEmpty.  See the Set module for further operations on sets.
</summary>
</member>
<member name="P:Internal.Utilities.Collections.Tagged.Set`2.Count">
<summary>
 Return the number of elements in the set
</summary>
</member>
<member name="P:Internal.Utilities.Collections.Tagged.Set`2.Choose">
<summary>
 The number of elements in the set
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Union(Internal.Utilities.Collections.Tagged.Set{`0,`1},Internal.Utilities.Collections.Tagged.Set{`0,`1})">
<summary>
 Compute the union of the two sets.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.ToList">
<summary>
 The elements of the set as a list.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.ToArray">
<summary>
 The elements of the set as an array.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Singleton(`1,`0)">
<summary>
 A singleton set based on the given comparison operator
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Remove(`0)">
<summary>
 A useful shortcut for Set.remove.  Note this operation produces a new set
 and does not mutate the original set.  The new set will share many storage
 nodes with the original.  See the Set module for further operations on sets.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Partition(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean})">
<summary>
 Build two new sets, one containing the elements for which the given predicate returns &apos;true&apos;,
 and the other the remaining elements.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Iterate(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.Unit})">
<summary>
 Apply the given function to each binding in the collection
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.IsSupersetOf(Internal.Utilities.Collections.Tagged.Set{`0,`1})">
<summary>
 Evaluates to &quot;true&quot; if all elements of the first set are in the second
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.IsSubsetOf(Internal.Utilities.Collections.Tagged.Set{`0,`1})">
<summary>
 Evaluates to &quot;true&quot; if all elements of the second set are in the first
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Intersection(Internal.Utilities.Collections.Tagged.Set{`0,`1},Internal.Utilities.Collections.Tagged.Set{`0,`1})">
<summary>
 Compute the intersection of the two sets.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.ForAll(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean})">
<summary>
 Test if all elements of the collection satisfy the given predicate.
 If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; and &lt;c&gt;j0...jN&lt;/c&gt; then 
 computes &lt;c&gt;p i0 &amp;&amp; ... &amp;&amp; p iN&lt;/c&gt;.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Fold``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``0)">
<summary>
 Apply the given accumulating function to all the elements of the set
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Filter(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean})">
<summary>
 Return a new collection containing only the elements of the collection
 for which the given predicate returns &quot;true&quot;
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Exists(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean})">
<summary>
 Test if any element of the collection satisfies the given predicate.
 If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; then computes 
 &lt;c&gt;p i0 or ... or p iN&lt;/c&gt;.
</summary>
</member>
<member name="">

</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Equality(Internal.Utilities.Collections.Tagged.Set{`0,`1},Internal.Utilities.Collections.Tagged.Set{`0,`1})">
<summary>
 Compares two sets and returns true if they are equal or false otherwise
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Empty(`1)">
<summary>
 The empty set based on the given comparer
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Difference(Internal.Utilities.Collections.Tagged.Set{`0,`1},Internal.Utilities.Collections.Tagged.Set{`0,`1})">
<summary>
 Return a new set with the elements of the second set removed from the first.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Create(`1,System.Collections.Generic.IEnumerable{`0})">
<summary>
 A set based on the given comparer containing the given initial elements
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Contains(`0)">
<summary>
 A useful shortcut for Set.contains.  See the Set module for further operations on sets.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Compare(Internal.Utilities.Collections.Tagged.Set{`0,`1},Internal.Utilities.Collections.Tagged.Set{`0,`1})">
<summary>
 Compares a and b and returns 1 if a &gt; b, -1 if b &lt; a and 0 if a = b        
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Add(`0)">
<summary>
 A useful shortcut for Set.add.  Note this operation prodcues a new set
 and does not mutate the original set.  The new set will share many storage
 nodes with the original.  See the Set module for further operations on sets.
</summary>
</member>
<member name="T:Internal.Utilities.Collections.Tagged.Set`2">
<summary>
 Immutable sets based on binary trees, default tag
 Immutable sets where a constraint tag carries information about the class of key-comparer being used.  
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Internal.Utilities.Debug.TraceInterop">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Internal.Utilities.FSharpEnvironment.tryFsharpiScript(System.String)">
<summary>
 Try to find the F# compiler location by looking at the &quot;fsharpi&quot; script installed by F# packages
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Internal.Utilities.FSharpEnvironment.DotNetBuildString">
<summary>
 The F# version reported in the banner
</summary>
</member>
<member name="M:Internal.Utilities.FSharpEnvironment.Option.ofString(System.String)">
<summary>
 Convert string into Option string where null and String.Empty result in None
</summary>
</member>
<member name="T:Internal.Utilities.FSharpEnvironment.Option">

</member>
<member name="T:Internal.Utilities.FSharpEnvironment">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Internal.Utilities.Filename.fileNameWithoutExtension(System.String)">
<summary>
 Get the filename without extenstion of the given path
</summary>
</member>
<member name="M:Internal.Utilities.Filename.fileNameOfPath(System.String)">
<summary>
 Get the filename of the given path
</summary>
</member>
<member name="M:Internal.Utilities.Filename.hasExtension(System.String)">
<summary>
 Return true if the filename has a &quot;.&quot; extension
</summary>
</member>
<member name="M:Internal.Utilities.Filename.directoryName(System.String)">
<summary>
 &quot;directoryName&quot; &quot; decomposes a filename into a directory name
</summary>
</member>
<member name="M:Internal.Utilities.Filename.chopExtension(System.String)">
<summary>
 &quot;chopExtension f&quot; removes the extension from the given
 filename. Raises ArgumentException if no extension is present.
</summary>
</member>
<member name="M:Internal.Utilities.Filename.checkSuffix(System.String,System.String)">
<summary>
 &quot;checkSuffix f s&quot; returns true if filename &quot;f&quot; ends in suffix &quot;s&quot;,
 e.g. checkSuffix &quot;abc.fs&quot; &quot;.fs&quot; returns true.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Internal.Utilities.Filename">
<summary>
 Some filename operations.    
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Internal.Utilities.FlatListModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Internal.Utilities.QueueListModule">

</member>
<member name="M:Internal.Utilities.ResizeArrayModule.unzip``2(System.Collections.Generic.List{System.Tuple{``0,``1}})">
<summary>
 Split an array of pairs into two arrays
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.zip``2(System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Combine the two arrays into an array of pairs. The two arrays must have equal lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is
 raised..
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.tryFindIndexi``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},System.Collections.Generic.List{``0})">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.tryFindIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.singleton``1(``0)">
<summary>
 Return an array containing the given element
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.scanBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},System.Collections.Generic.List{``0},``1)">
<summary>
 Like &lt;c&gt;foldBack&lt;/c&gt;, but return both the intermediary and final results
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.scan``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,System.Collections.Generic.List{``1})">
<summary>
 Like &lt;c&gt;fold&lt;/c&gt;, but return the intermediary and final results
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.mapi2``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to the corresponding elements of the two collections pairwise.  The two input
 arrays must have the same lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is
 raised.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.iteri2``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Apply the given function to pair of elements drawn from matching indices in two arrays,
 also passing the index of the elements. The two arrays must have the same lengths, 
 otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is raised.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.isEmpty``1(System.Collections.Generic.List{``0})">
<summary>
 Return true if the given array is empty, otherwise false
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.forall2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Test elements of the two arrays pairwise to see if all pairs of elements satisfy the given predicate.
 Raise ArgumentException if the arrays have different lengths.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.foldBack2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``2}}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1},``2)">
<summary>
 Apply a function to pairs of elements drawn from the two collections, right-to-left, 
 threading an accumulator argument through the computation.  The two input
 arrays must have the same lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is
 raised.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.fold2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``0}}},``0,System.Collections.Generic.List{``1},System.Collections.Generic.List{``2})">
<summary>
 Apply a function to pairs of elements drawn from the two collections, 
 left-to-right, threading an accumulator argument
 through the computation.  The two input
 arrays must have the same lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is
 raised.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.reduceBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Collections.Generic.List{``0})">
<summary>
 Apply a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; then 
 computes &lt;c&gt;f i0 (...(f iN-1 iN))&lt;/c&gt;. Raises ArgumentException if the array has size zero.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.reduce``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Collections.Generic.List{``0})">
<summary>
 Apply a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; 
 then computes &lt;c&gt;f (... (f i0 i1)...) iN&lt;/c&gt;. Raises ArgumentException if the array has size zero.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.findIndexi``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},System.Collections.Generic.List{``0})">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate. Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if 
 none of the elements satisfy the predicate.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.findIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate. Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if 
 none of the elements satisfy the predicate.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.exists2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Test elements of the two arrays pairwise to see if any pair of element satisfies the given predicate.
 Raise ArgumentException if the arrays have different lengths.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.toSeq``1(System.Collections.Generic.List{``0})">
<summary>
 Return a view of the array as an enumerable object
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.ofArray``1(``0[])">
<summary>
 Build a ResizeArray from the given elements
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.toArray``1(System.Collections.Generic.List{``0})">
<summary>
 Return a fixed-length array containing the elements of the input ResizeArray
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.sortBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.List{``0})">
<summary>
 Sort the elements using the key extractor and generic comparison on the keys
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.sort``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}},System.Collections.Generic.List{``0})">
<summary>
 Sort the elements using the given comparison function
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.rev``1(System.Collections.Generic.List{``0})">
<summary>
Return a new array with the elements in reverse order
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.tryPick``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.List{``0})">
<summary>
Apply the given function to successive elements, returning the first
result where function returns &quot;Some(x)&quot; for some x.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.tryFind``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
Return the first element for which the given function returns &lt;c&gt;true&lt;/c&gt;.
Return None if no such element exists.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.find``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
Return the first element for which the given function returns &lt;c&gt;true&lt;/c&gt;.
Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if no such element exists.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.choose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.List{``0})">
<summary>
Apply the given function to each element of the array. Return
the array comprised of the results &quot;x&quot; for each element where
the function returns Some(x)
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.partition``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
Split the collection into two collections, containing the 
elements for which the given predicate returns &lt;c&gt;true&lt;/c&gt; and &lt;c&gt;false&lt;/c&gt;
respectively 
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
Return a new collection containing only the elements of the collection
for which the given predicate returns &lt;c&gt;true&lt;/c&gt;
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.forall``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
 Test if all elements of the array satisfy the given predicate.
 If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; and &quot;j0...jN&quot;
 then computes &lt;c&gt;p i0 &amp;&amp; ... &amp;&amp; p iN&lt;/c&gt;.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.exists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
 Test if any element of the array satisfies the given predicate.
 If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; 
 then computes &lt;c&gt;p i0 or ... or p iN&lt;/c&gt;.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.mapi``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},System.Collections.Generic.List{``0})">
<summary>
Build a new array whose elements are the results of applying the given function
to each of the elements of the array. The integer index passed to the
function indicates the index of element being transformed.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.iteri``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},System.Collections.Generic.List{``0})">
<summary>
Apply the given function to each element of the array.  The integer passed to the
function indicates the index of element.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
Build a new collection whose elements are the results of applying the given function
to the corresponding elements of the two collections pairwise.  The two input
arrays must have the same lengths.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.iter2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
Apply the given function to two arrays simultaneously. The
two arrays must have the same lengths, otherwise an Invalid_argument exception is
raised.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.List{``0})">
<summary>
Build a new array whose elements are the results of applying the given function
to each of the elements of the array.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.iter``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},System.Collections.Generic.List{``0})">
<summary>
Apply the given function to each element of the array. 
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.foldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},System.Collections.Generic.List{``0},``1)">
<summary>
 Apply a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; then 
 computes &lt;c&gt;f i0 (...(f iN s))&lt;/c&gt;.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,System.Collections.Generic.List{``1})">
<summary>
 Apply a function to each element of the collection, threading an accumulator argument
 through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; 
 then computes &lt;c&gt;f (... (f s i0)...) iN&lt;/c&gt;
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.ofList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
Build an array from the given list
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.toList``1(System.Collections.Generic.List{``0})">
<summary>
Build a list from the given array
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.blit``1(System.Collections.Generic.List{``0},System.Int32,System.Collections.Generic.List{``0},System.Int32,System.Int32)">
<summary>
Read a range of elements from the first array and write them into the second.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.fill``1(System.Collections.Generic.List{``0},System.Int32,System.Int32,``0)">
<summary>
Fill a range of the collection with the given element
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.copy``1(System.Collections.Generic.List{``0})">
<summary>
Build a new array that contains the elements of the given array
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.sub``1(System.Collections.Generic.List{``0},System.Int32,System.Int32)">
<summary>
Build a new array that contains the given subrange specified by
starting index and length.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.concat``1(Microsoft.FSharp.Collections.FSharpList{System.Collections.Generic.List{``0}})">
<summary>
Build a new array that contains the elements of each of the given list of arrays
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.append``1(System.Collections.Generic.List{``0},System.Collections.Generic.List{``0})">
<summary>
Build a new array that contains the elements of the first array followed by the elements of the second array
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.init``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
<summary>
 Create an array by calling the given generator on each index.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.create``1(System.Int32,``0)">
<summary>
 Create an array whose elements are all initially the given value.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.set``1(System.Collections.Generic.List{``0},System.Int32,``0)">
<summary>
 Set the value of an element in the collection. You can also use the syntax &lt;c&gt;arr.[idx] &lt;- e&lt;/c&gt;.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.get``1(System.Collections.Generic.List{``0},System.Int32)">
<summary>
 Fetch an element from the collection.  You can also use the syntax &lt;c&gt;arr.[idx]&lt;/c&gt;.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.length``1(System.Collections.Generic.List{``0})">
<summary>
 Return the length of the collection.  You can also use property &lt;c&gt;arr.Length&lt;/c&gt;.
</summary>
</member>
<member name="T:Internal.Utilities.ResizeArrayModule">
<summary>
 Generic operations on the type System.Collections.Generic.List, which is called ResizeArray in the F# libraries.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Internal.Utilities.StructuredFormat.FormatOptions">
<summary>
 A record of options to control structural formatting.
 For F# Interactive properties matching those of this value can be accessed via the &apos;fsi&apos;
 value.
 
 Floating Point format given in the same format accepted by System.Double.ToString,
 e.g. f6 or g15.

 If ShowProperties is set the printing process will evaluate properties of the values being
 displayed.  This may cause additional computation.  

 The ShowIEnumerable is set the printing process will force the evalution of IEnumerable objects
 to a small, finite depth, as determined by the printing parameters.
 This may lead to additional computation being performed during printing.

 &lt;example&gt;
 From F# Interactive the default settings can be adjusted using, for example, 
 &lt;pre&gt;
   open Microsoft.FSharp.Compiler.Interactive.Settings;;
   setPrintWidth 120;;
 &lt;/pre&gt;
 &lt;/example&gt;
</summary>
</member>
<member name="P:Internal.Utilities.StructuredFormat.IEnvironment.MaxRows">
<summary>
 The maximum number of rows for which to generate layout for table-like 
 structures.  -1 if no maximum.
</summary>
</member>
<member name="P:Internal.Utilities.StructuredFormat.IEnvironment.MaxColumns">
<summary>
 The maximum number of elements for which to generate layout for 
 list-like structures, or columns in table-like 
 structures.  -1 if no maximum.
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.IEnvironment.GetLayout(System.Object)">
<summary>
 Return to the layout-generation 
 environment to layout any otherwise uninterpreted object
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Internal.Utilities.StructuredFormat.Layout">
<summary>
 Data representing structured layouts of terms.  The representation
 of this data type is only for the consumption of formatting engines.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Internal.Utilities.StructuredFormat.Joint">
<summary>
 Data representing structured layouts of terms.  
 Data representing joints in structured layouts of terms.  The representation
 of this data type is only for the consumption of formatting engines.
</summary>
</member>
<member name="">

</member>
<member name="M:Internal.Utilities.StructuredFormat.Display.layout_to_string(Internal.Utilities.StructuredFormat.FormatOptions,Internal.Utilities.StructuredFormat.Layout)">
<summary>
 Convert any value to a layout using the given formatting options.  The
 layout can then be processed using formatting display engines such as
 those in the LayoutOps module.  any_to_string and output_any are
 built using any_to_layout with default format options.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Internal.Utilities.StructuredFormat.Display.output_any``1(System.IO.TextWriter,``0)">
<summary>
 Ouput any value to a channel using the same set of formatting rules
 as any_to_string
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.Display.any_to_string``1(``0)">
<summary>
 Convert any value to a string using a standard formatter
 Data is typically formatted in a structured format, e.g.
 lists are formatted using the &quot;[1;2]&quot; notation.
 The details of the format are not specified and may change
 from version to version and according to the flags given
 to the F# compiler.  The format is intended to be human-readable,
 not machine readable.  If alternative generic formats are required
 you should develop your own formatter, using the code in the
 implementation of this file as a starting point.

 Data from other .NET languages is formatted using a virtual
 call to Object.ToString() on the boxed version of the input.
</summary>
</member>
<member name="T:Internal.Utilities.StructuredFormat.Display">

</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.unfoldL``2(Microsoft.FSharp.Core.FSharpFunc{``0,Internal.Utilities.StructuredFormat.Layout},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{System.Tuple{``0,``1}}},``1,System.Int32)">
<summary>
 For limitting layout of list-like sequences (lists,arrays,etc).
 unfold a list of items using (project and z) making layout list via itemL.
 If reach maxLength (before exhausting) then truncate.
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.tagAttrL(System.String,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,System.String}},Internal.Utilities.StructuredFormat.Layout)">
<summary>
 See tagL
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.listL``1(Microsoft.FSharp.Core.FSharpFunc{``0,Internal.Utilities.StructuredFormat.Layout},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Layout like an F# list.    
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.optionL``1(Microsoft.FSharp.Core.FSharpFunc{``0,Internal.Utilities.StructuredFormat.Layout},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Layout like an F# option.
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.aboveListL(Microsoft.FSharp.Collections.FSharpList{Internal.Utilities.StructuredFormat.Layout})">
<summary>
 Layout list vertically.    
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.aboveL(Internal.Utilities.StructuredFormat.Layout,Internal.Utilities.StructuredFormat.Layout)">
<summary>
 Layout two vertically.
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.tupleL(Microsoft.FSharp.Collections.FSharpList{Internal.Utilities.StructuredFormat.Layout})">
<summary>
 Form tuple of layouts.            
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.braceL(Internal.Utilities.StructuredFormat.Layout)">
<summary>
 Wrap braces around layout.        
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.squareBracketL(Internal.Utilities.StructuredFormat.Layout)">
<summary>
 Wrap square brackets around layout.    
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.bracketL(Internal.Utilities.StructuredFormat.Layout)">
<summary>
 Wrap round brackets around Layout.
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.sepListL(Internal.Utilities.StructuredFormat.Layout,Microsoft.FSharp.Collections.FSharpList{Internal.Utilities.StructuredFormat.Layout})">
<summary>
 Join layouts into a list separated using the given Layout.
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.semiListL(Microsoft.FSharp.Collections.FSharpList{Internal.Utilities.StructuredFormat.Layout})">
<summary>
 Join layouts into a semi-colon separated list.
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.spaceListL(Microsoft.FSharp.Collections.FSharpList{Internal.Utilities.StructuredFormat.Layout})">
<summary>
 Join layouts into a space separated list.    
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.commaListL(Microsoft.FSharp.Collections.FSharpList{Internal.Utilities.StructuredFormat.Layout})">
<summary>
 Join layouts into a comma separated list.
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.op_AtAtMinusMinus(Internal.Utilities.StructuredFormat.Layout,Internal.Utilities.StructuredFormat.Layout)">
<summary>
 Join broken with ident=2 
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.op_AtAtMinus(Internal.Utilities.StructuredFormat.Layout,Internal.Utilities.StructuredFormat.Layout)">
<summary>
 Join broken with ident=1 
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.op_AtAt(Internal.Utilities.StructuredFormat.Layout,Internal.Utilities.StructuredFormat.Layout)">
<summary>
 Join broken with ident=0
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.op_MinusMinusMinus(Internal.Utilities.StructuredFormat.Layout,Internal.Utilities.StructuredFormat.Layout)">
<summary>
 Join, possible break with indent=2 
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.op_MinusMinus(Internal.Utilities.StructuredFormat.Layout,Internal.Utilities.StructuredFormat.Layout)">
<summary>
 Join, possible break with indent=1
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.op_PlusPlus(Internal.Utilities.StructuredFormat.Layout,Internal.Utilities.StructuredFormat.Layout)">
<summary>
 Join, possible break with indent=0
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.op_HatHat(Internal.Utilities.StructuredFormat.Layout,Internal.Utilities.StructuredFormat.Layout)">
<summary>
 Join, unbreakable. 
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.leftL(System.String)">
<summary>
 An string which is left  parenthesis (no space on the right).
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.rightL(System.String)">
<summary>
 An string which is right parenthesis (no space on the left).
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.sepL(System.String)">
<summary>
 An string which requires no spaces either side.
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.wordL(System.String)">
<summary>
 An string leaf 
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.objL(System.Object)">
<summary>
 An uninterpreted leaf, to be interpreted into a string
 by the layout engine. This allows leaf layouts for numbers, strings and
 other atoms to be customized according to culture.
</summary>
</member>
<member name="M:Internal.Utilities.StructuredFormat.LayoutOps.isEmptyL(Internal.Utilities.StructuredFormat.Layout)">
<summary>
 Is it the empty layout?
</summary>
</member>
<member name="P:Internal.Utilities.StructuredFormat.LayoutOps.emptyL">
<summary>
 The empty layout
</summary>
</member>
<member name="T:Internal.Utilities.StructuredFormat.LayoutOps">
<summary>
 A layout is a sequence of strings which have been joined together.
 The strings are classified as words, separators and left and right parenthesis.
 This classification determines where spaces are inserted.
 A joint is either unbreakable, breakable or broken.
 If a joint is broken the RHS layout occurs on the next line with optional indentation.
 A layout can be squashed to for given width which forces breaks as required.
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.UnicodeTables.Interpret(System.Int32,Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">
<summary>
 Interpret tables for a unicode lexer generated by fslex. 
</summary>
</member>
<member name="">

</member>
<member name="T:Internal.Utilities.Text.Lexing.UnicodeTables">
<summary>
 The type of tables for an unicode lexer generated by fslex. 
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.StartPos(Internal.Utilities.Text.Lexing.Position)">
<summary>
 The start position for the lexeme
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.IsPastEndOfStream(System.Boolean)">
<summary>
 True if the refill of the buffer ever failed , or if explicitly set to true.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.EndPos(Internal.Utilities.Text.Lexing.Position)">
<summary>
 The end position for the lexeme
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.StartPos">
<summary>
 The start position for the lexeme
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.Lexeme">
<summary>
 The matched string 
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.IsPastEndOfStream">
<summary>
 True if the refill of the buffer ever failed , or if explicitly set to true.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.EndPos">
<summary>
 The end position for the lexeme
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.BufferLocalStore">
<summary>
 Dynamically typed, non-lexically scoped parameter table
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.LexBuffer`1.LexemeString(Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">
<summary>
 Fast helper to turn the matched characters into a string, avoiding an intermediate array
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.LexBuffer`1.FromFunction(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{`0[],System.Int32,System.Int32},System.Int32})">
<summary>
 Create a lex buffer that reads character or byte inputs by using the given function
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.LexBuffer`1.FromChars(System.Char[])">
<summary>
 Create a lex buffer suitable for Unicode lexing that reads characters from the given array
</summary>
</member>
<member name="T:Internal.Utilities.Text.Lexing.LexBuffer`1">
<summary>
 Input buffers consumed by lexers generated by &lt;c&gt;fslex.exe &lt;/c&gt;
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.Position.StartOfLineAbsoluteOffset">
<summary>
 Return absolute offset of the start of the line marked by the position
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.Position.OriginalLine">
<summary>
 The line number for the position in the input stream, assuming fresh positions have been updated 
 using for the new line
</summary>
</member>
<member name="">

</member>
<member name="P:Internal.Utilities.Text.Lexing.Position.Line">
<summary>
 The line number in the input stream, assuming fresh positions have been updated 
 for the new line by modifying the EndPos property of the LexBuffer.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.Position.FileIndex">
<summary>
 The file index for the file associated with the input stream, use fileOfFileIndex in range.fs to decode
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.Position.Empty">
<summary>
 Get an arbitrary position, with the empty string as filename, and  
</summary>
</member>
<member name="">

</member>
<member name="P:Internal.Utilities.Text.Lexing.Position.Column">
<summary>
 Return the column number marked by the position, i.e. the difference between the AbsoluteOffset and the StartOfLineAbsoluteOffset
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.Position.AbsoluteOffset">
<summary>
 The character number in the input stream
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.Position.ShiftColumnBy(System.Int32)">
<summary>
 Gives a position shifted by specified number of characters
</summary>
</member>
<member name="">

</member>
<member name="M:Internal.Utilities.Text.Lexing.Position.EndOfToken(System.Int32)">
<summary>
 Given a position at the start of a token of length n, return a position just beyond the end of the token
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.Position.ApplyLineDirective(System.Int32,System.Int32)">
<summary>
 Apply a #line directive
</summary>
</member>
<member name="T:Internal.Utilities.Text.Lexing.Position">
<summary>
 Position information stored for lexing tokens
</summary>
</member>
<member name="F:Internal.Utilities.Text.Parsing.Internal.Utilities.Text.Parsing.Tables`1.tagOfErrorTerminal">
<summary>
 The tag of the error terminal
</summary>
</member>
<member name="F:Internal.Utilities.Text.Parsing.Internal.Utilities.Text.Parsing.Tables`1.numTerminals">
<summary>
 The total number of terminals 
</summary>
</member>
<member name="F:Internal.Utilities.Text.Parsing.Internal.Utilities.Text.Parsing.Tables`1.parseError">
<summary>
 This function is used to hold the user specified &quot;parse_error&quot; or &quot;parse_error_rich&quot; functions
</summary>
</member>
<member name="F:Internal.Utilities.Text.Parsing.Internal.Utilities.Text.Parsing.Tables`1.productionToNonTerminalTable">
<summary>
 This table is logically part of the Goto table
</summary>
</member>
<member name="F:Internal.Utilities.Text.Parsing.Internal.Utilities.Text.Parsing.Tables`1.stateToProdIdxsTableRowOffsets">
<summary>
 The sparse table offsets for the productions active for each state
</summary>
</member>
<member name="F:Internal.Utilities.Text.Parsing.Internal.Utilities.Text.Parsing.Tables`1.stateToProdIdxsTableElements">
<summary>
 The sparse table for the productions active for each state
</summary>
</member>
<member name="F:Internal.Utilities.Text.Parsing.Internal.Utilities.Text.Parsing.Tables`1.sparseGotoTableRowOffsets">
<summary>
 The sparse goto table row offsets
</summary>
</member>
<member name="F:Internal.Utilities.Text.Parsing.Internal.Utilities.Text.Parsing.Tables`1.gotos">
<summary>
 The sparse goto table
</summary>
</member>
<member name="F:Internal.Utilities.Text.Parsing.Internal.Utilities.Text.Parsing.Tables`1.immediateActions">
<summary>
 The immediate action table
</summary>
</member>
<member name="F:Internal.Utilities.Text.Parsing.Internal.Utilities.Text.Parsing.Tables`1.reductionSymbolCounts">
<summary>
 The number of symbols for each reduction
</summary>
</member>
<member name="F:Internal.Utilities.Text.Parsing.Internal.Utilities.Text.Parsing.Tables`1.actionTableRowOffsets">
<summary>
 The sparse action table row offsets
</summary>
</member>
<member name="F:Internal.Utilities.Text.Parsing.Internal.Utilities.Text.Parsing.Tables`1.actionTableElements">
<summary>
 The sparse action table elements
</summary>
</member>
<member name="F:Internal.Utilities.Text.Parsing.Internal.Utilities.Text.Parsing.Tables`1.dataOfToken">
<summary>
 A function to compute the data carried by a token
</summary>
</member>
<member name="F:Internal.Utilities.Text.Parsing.Internal.Utilities.Text.Parsing.Tables`1.tagOfToken">
<summary>
 A function to compute the tag of a token
</summary>
</member>
<member name="F:Internal.Utilities.Text.Parsing.Internal.Utilities.Text.Parsing.Tables`1.endOfInputTag">
<summary>
 The token number indicating the end of input
</summary>
</member>
<member name="F:Internal.Utilities.Text.Parsing.Internal.Utilities.Text.Parsing.Tables`1.reductions">
<summary>
 The reduction table
</summary>
</member>
<member name="M:Internal.Utilities.Text.Parsing.Tables`1.Interpret(Microsoft.FSharp.Core.FSharpFunc{Internal.Utilities.Text.Lexing.LexBuffer{System.Char},`0},Internal.Utilities.Text.Lexing.LexBuffer{System.Char},System.Int32)">
<summary>
 Interpret the parser table taking input from the given lexer, using the given lex buffer, and the given start state.
 Returns an object indicating the final synthesized value for the parse.
</summary>
</member>
<member name="T:Internal.Utilities.Text.Parsing.Tables`1">
<summary>
 Tables generated by fsyacc
 The type of the tables contained in a file produced by the fsyacc.exe parser generator.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.ParseErrorContext`1.StateStack">
<summary>
 The stack of state indexes active at the parse error 
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.ParseErrorContext`1.ShiftTokens">
<summary>
 The token that would cause a shift at the parse error
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.ParseErrorContext`1.ReducibleProductions">
<summary>
 The stack of productions that would be reduced at the parse error 
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.ParseErrorContext`1.ReduceTokens">
<summary>
 The tokens that would cause a reduction at the parse error 
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.ParseErrorContext`1.ParseState">
<summary>
 The state active at the parse error 
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.ParseErrorContext`1.Message">
<summary>
 The message associated with the parse error
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.ParseErrorContext`1.CurrentToken">
<summary>
 The token that caused the parse error
</summary>
</member>
<member name="T:Internal.Utilities.Text.Parsing.ParseErrorContext`1">
<summary>
 The context provided when a parse error occurs
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.IParseState.ResultStartPosition">
<summary>
 Get the start of the range of positions matched by the production
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.IParseState.ResultRange">
<summary>
 Get the full range of positions matched by the production
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.IParseState.ResultEndPosition">
<summary>
 Get the end of the range of positions matched by the production
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.IParseState.LexBuffer">
<summary>
 Return the LexBuffer for this parser instance
</summary>
</member>
<member name="M:Internal.Utilities.Text.Parsing.IParseState.RaiseError``1">
<summary>
 Raise an error in this parse context
</summary>
</member>
<member name="M:Internal.Utilities.Text.Parsing.IParseState.InputStartPosition(System.Int32)">
<summary>
 Get the start position for the terminal or non-terminal at a given index matched by the production
</summary>
</member>
<member name="M:Internal.Utilities.Text.Parsing.IParseState.InputRange(System.Int32)">
<summary>
 Get the start and end position for the terminal or non-terminal at a given index matched by the production
</summary>
</member>
<member name="M:Internal.Utilities.Text.Parsing.IParseState.InputEndPosition(System.Int32)">
<summary>
 Get the end position for the terminal or non-terminal at a given index matched by the production
</summary>
</member>
<member name="M:Internal.Utilities.Text.Parsing.IParseState.GetInput(System.Int32)">
<summary>
 Get the value produced by the terminal or non-terminal at the given position
</summary>
</member>
<member name="">

</member>
<member name="T:Internal.Utilities.Text.Parsing.RecoverableParseError">
<summary>
 Indicates a parse error has occured and parse recovery is in progress
</summary>
</member>
<member name="">

</member>
<member name="T:Internal.Utilities.Text.Parsing.Accept">
<summary>
 Indicates an accept action has occured
</summary>
</member>
<member name="M:Internal.Utilities.Text.Parsing.ParseHelpers.parse_error(System.String)">
<summary>
 The default implementation of the parse_error function
</summary>
</member>
<member name="M:Internal.Utilities.Text.Parsing.ParseHelpers.parse_error_rich``1">
<summary>
 The default implementation of the parse_error_rich function
</summary>
</member>
<member name="T:Internal.Utilities.Text.Parsing.ParseHelpers">
<summary>
 Helpers used by generated parsers.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tainted`1.TypeProviderDesignation">
<summary>
 Test to report for the name of the type provider that produced the value
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tainted`1.TypeProviderAssemblyRef">
<summary>
 The ILScopeRef of the runtime assembly reference for type provider that produced the value
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tainted`1.TypeProvider">
<summary>
 A type provider that produced the value
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tainted`1.PUntaintNoFailure``1(Microsoft.FSharp.Core.FSharpFunc{`0,``0})">
<summary>
 Apply an operation and &apos;untaint&apos; the result. This can be used if the return type 
 is guaranteed not to be implemented by a type provider
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tainted`1.PUntaint``1(Microsoft.FSharp.Core.FSharpFunc{`0,``0},Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Apply an operation and &apos;untaint&apos; the result. The result must be marshalable. Any exception will be attributed to the type provider with an error located at the given range
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tainted`1.PApplyWithProvider``1(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{`0,Microsoft.FSharp.Core.CompilerServices.ITypeProvider},``0},Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Apply an operation. Any exception will be attributed to the type provider with an error located at the given range
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tainted`1.PApplyOption``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpOption{``0}},Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Apply an operation that returns an option. Unwrap option. Any exception will be attributed to the type provider with an error located at the given range
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tainted`1.PApplyNoFailure``1(Microsoft.FSharp.Core.FSharpFunc{`0,``0})">
<summary>
 Apply an operation. No exception may be raised by &apos;f&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tainted`1.PApplyArray``1(Microsoft.FSharp.Core.FSharpFunc{`0,``0[]},System.String,Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Apply an operation that returns an array. Unwrap array. Any exception will be attributed to the type provider with an error located at the given range.  String is method name of thing-returning-array, to diagnostically attribute if it is null
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tainted`1.PApply4``4(Microsoft.FSharp.Core.FSharpFunc{`0,System.Tuple{``0,``1,``2,``3}},Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Apply an operation. Any exception will be attributed to the type provider with an error located at the given range
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tainted`1.PApply3``3(Microsoft.FSharp.Core.FSharpFunc{`0,System.Tuple{``0,``1,``2}},Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Apply an operation. Any exception will be attributed to the type provider with an error located at the given range
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tainted`1.PApply2``2(Microsoft.FSharp.Core.FSharpFunc{`0,System.Tuple{``0,``1}},Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Apply an operation. Any exception will be attributed to the type provider with an error located at the given range
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tainted`1.PApply``1(Microsoft.FSharp.Core.FSharpFunc{`0,``0},Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Apply an operation. Any exception will be attributed to the type provider with an error located at the given range
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tainted`1.OfType``1">
<summary>
 Conditionally coerce the value
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tainted`1.CreateAll(Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Core.CompilerServices.ITypeProvider,Microsoft.FSharp.Compiler.AbstractIL.IL.ILScopeRef}})">
<summary>
 Create an initial tainted value
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tainted`1.Coerce``1(Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Assert that the value is of &apos;U and coerce the value.
 If corecion fails, the failuer will be blamed on a type provider
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tainted`1">
<summary>
 This struct wraps a value produced by a type provider to properly attribute any failures.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.TypeProviderError.WithContext(System.String,System.String)">
<summary>
 creates new instance of TypeProviderError with specified type\method names
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.TypeProviderError.MapText(Microsoft.FSharp.Core.FSharpFunc{System.String,System.Tuple{System.Int32,System.String}},System.String,Microsoft.FSharp.Compiler.Range.range)">
<summary>
 creates new instance of TypeProviderError based on current instance information(message)
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.TypeProviderError.Iter(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.TypeProviderError,Microsoft.FSharp.Core.Unit})">
<summary>
 provides uniform way to process aggregated errors
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.TypeProviderError.#ctor(System.Int32,System.String,Microsoft.FSharp.Compiler.Range.range,System.Collections.Generic.IEnumerable{System.String})">
<summary>
 creates new instance of TypeProviderError that represents collection of errors
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.TypeProviderError.#ctor(System.Tuple{System.Int32,System.String},System.String,Microsoft.FSharp.Compiler.Range.range)">
<summary>
 creates new instance of TypeProviderError that represents one error
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.TypeProviderError">
<summary>
 Stores and transports aggregated list of errors reported by the type provider
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Diagnostics">
<summary>
 Diagnostics from the AbsIL toolkit. You can reset the diagnostics 
 stream to point elsewhere, or turn it
 off altogether by setting it to &apos;None&apos;.  The logging channel initally
 points to stderr.  All functions call flush() automatically.

 REVIEW: review if we should just switch to System.Diagnostics
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Extensions.ILX.EraseIlxFuncs">
<summary>
 Internal use only.  Erase closures
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Extensions.ILX.EraseIlxUnions">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.Extensions.ILX.IlxSettings.ilxFsharpCoreLibScopeRef">
<summary>
 Scope references for FSharp.Core.dll
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Extensions.ILX.IlxSettings">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.AbstractIL.Extensions.ILX.Types.IlxUnionInfo.cudWhere">
<summary>
 Debug info for generated code for classunions 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.AbstractIL.Extensions.ILX.Types.IlxUnionInfo.cudHasHelpers">
<summary>
 Generate the helpers? 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.AbstractIL.Extensions.ILX.Types.IlxUnionInfo.cudHelpersAccess">
<summary>
 Are the representation helpers public? 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.AbstractIL.Extensions.ILX.Types.IlxUnionInfo.cudReprAccess">
<summary>
 Is the representation public? 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Extensions.ILX.Types.IlxInstr">
<summary>
 ILX extensions to the intruction set

</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Extensions.ILX.Types.IlxClosureApps">
<summary>
 IlxClosureApps - i.e. types being applied at a callsite
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.AbstractIL.Extensions.ILX.Types.IlxUnionField.LowerName">
<summary>
 The name used for the field in parameter or IL field position
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Extensions.ILX.Types">
<summary>
 ILX extensions to Abstract IL types and instructions F# 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILEnumInfo">
<summary>
 Decompose a type definition according to its kind.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILLocalsAllocator">
<summary>
 Helpers for codegen: scopes for allocating new temporary variables.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.ILGlobals.mkDebuggableAttributeV2(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
<summary>
 Some commonly used custom attibutes 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILGlobals">
<summary>
 A table of common references to items in primary assebly (System.Runtime or mscorlib).
 If you have already loaded a particular version of system runtime assembly you should reference items via an ILGlobals for that particular 
 version of system runtime assembly built using mkILGlobals. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.IPrimaryAssemblyTraits">
<summary>
 Represents the capabilities of target framework profile.
 Different profiles may omit some types or contain them in different assemblies
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.AbstractIL.IL.ILModuleDef.NativeResources">
<summary>
 e.g. win86 resources, as the exact contents of a .res or .obj file 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILModuleDef">
<summary>
 One module in the &quot;current&quot; assembly, either a main-module or
 an auxiliary module.  The main module will have a manifest.

 An assembly is built by joining together a &quot;main&quot; module plus 
 several auxiliary modules. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.AbstractIL.IL.ILAssemblyManifest.EntrypointElsewhere">
<summary>
 Records whether the entrypoint resides in another module. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.AbstractIL.IL.ILAssemblyManifest.ExportedTypes">
<summary>
 Records the types impemented by this asssembly in auxiliary 
 modules. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.AbstractIL.IL.ILAssemblyManifest.PublicKey">
<summary>
 This is the public key used to sign this 
 assembly (the signature itself is stored elsewhere: see the 
 binary format, and may not have been written if delay signing 
 is used).  (member Name, member PublicKey) forms the full 
 public name of the assembly.  
</summary>
</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.AbstractIL.IL.ILAssemblyManifest.AuxModuleHashAlgorithm">
<summary>
 This is ID of the algorithm used for the hashes of auxiliary 
 files in the assembly.   These hashes are stored in the 
 ILModuleRef.Hash fields of this assembly. These are not cryptographic 
 hashes: they are simple file hashes. The algorithm is normally 
 0x00008004 indicating the SHA1 hash algorithm.  
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILAssemblyManifest">
<summary>
 The main module of an assembly is a module plus some manifest information.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILResources">
<summary>
 Table of resources in a module
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILResource">
<summary>
 &quot;Manifest ILResources&quot; are chunks of resource data, being one of:
   - the data section of the current module (byte[] of resource given directly) 
  - in an external file in this assembly (offset given in the ILResourceLocation field) 
   - as a resources in another assembly of the same name.  
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.AbstractIL.IL.ILExportedTypeOrForwarder.Name">
<summary>
 [Namespace.]Name
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILExportedTypeOrForwarder">
<summary>
 these are only found in the ILExportedTypesAndForwarders table in the manifest 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILNestedExportedType">
<summary>
 &quot;Classes Elsewhere&quot; - classes in auxiliary modules.

 Manifests include declarations for all the classes in an 
 assembly, regardless of which module they are in.

 The &quot;.class extern&quot; construct describes so-called exported types -- 
 these are public classes defined in the auxiliary modules of this assembly,
 i.e. modules other than the manifest-carrying module. 
 
 For example, if you have a two-module 
 assembly (A.DLL and B.DLL), and the manifest resides in the A.DLL, 
 then in the manifest all the public classes declared in B.DLL should
 be defined as exported types, i.e., as &quot;.class extern&quot;. The public classes 
 defined in A.DLL should not be defined as &quot;.class extern&quot; -- they are 
 already available in the manifest-carrying module. The union of all 
 public classes defined in the manifest-carrying module and all 
 exported types defined there is the set of all classes exposed by 
 this assembly. Thus, by analysing the metadata of the manifest-carrying 
 module of an assembly, you can identify all the classes exposed by 
 this assembly, and where to find them.

 Nested classes found in external modules should also be located in 
 this table, suitably nested inside another &quot;ILExportedTypeOrForwarder&quot;
 definition.
 these are only found in the &quot;Nested&quot; field of ILExportedTypeOrForwarder objects 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeDef.HasSecurity">
<summary>
 Note: some classes are marked &quot;HasSecurity&quot; even if there are no permissions attached, e.g. if they use SuppressUnmanagedCodeSecurityAttribute 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeDef.IsComInterop">
<summary>
 Class or interface generated for COM interop 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeDef">
<summary>
 Type Definitions 

 As for methods there are several important constraints not encoded 
 in the type definition below, for example that the super class of
 an interface type is always None, or that enumerations always
 have a very specific form.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeDefs.AsListOfLazyTypeDefs">
<summary>
 Get some information about the type defs, but do not force the read of the type defs themselves
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeDefs.FindByName(System.String)">
<summary>
 Calls to [FindByName] will result in any laziness in the overall 
 set of ILTypeDefs being read in in addition 
 to the details for the type found, but the remaining individual 
 type definitions will not be read. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeDefs">
<summary>
 Tables of named type definitions.  The types and table may contain on-demand
 (lazy) computations, e.g. the actual reading of some aspects
 of a type definition may be delayed if the reader being used supports
 this.

 This is an abstract type equivalent to &quot;ILTypeDef list&quot; 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeDefKind">
<summary>
 A categorization of type definitions into &quot;kinds&quot;
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeDefAccess">
<summary>
 Type Access
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILDefaultPInvokeEncoding">
<summary>
 Default Unicode encoding for P/Invoke  within a type
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeInit">
<summary>
 Indicate the initialization semantics of a type
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeDefLayout">
<summary>
 Type Layout information
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILMethodImplDef">
<summary>
 Method Impls

 If there is an entry (pms --&amp;gt; ms) in this table, then method [ms] 
 is used to implement method [pms] for the purposes of this class 
 and its subclasses. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILPropertyDefs">
<summary>
 Table of those properties in a type definition.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILPropertyDef">
<summary>
 Property definitions
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILEventDefs">
<summary>
 Table of those events in a type definition.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILEventDef">
<summary>
 Event definitions
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILFieldDefs">
<summary>
 Tables of fields.  Logically equivalent to a list of fields but
 the table is kept in a form optimized for looking up fields by 
 name.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.AbstractIL.IL.ILFieldDef.Offset">
<summary>
 The explicit offset in bytes when explicit layout is used.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILFieldDef">
<summary>
 Field definitions
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILMethodDefs">
<summary>
 Tables of methods.  Logically equivalent to a list of methods but
 the table is kept in a form optimized for looking up methods by 
 name and arity.
 abstract type equivalent to [ILMethodDef list] 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.AbstractIL.IL.ILMethodDef.IsMustRun">
<summary>
 .NET 2.0 feature: SafeHandle finalizer must be run 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.AbstractIL.IL.ILMethodDef.IsUnmanagedExport">
<summary>
 The method is exported to unmanaged code using COM interop.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.AbstractIL.IL.ILMethodDef.HasSecurity">
<summary>
 Note: some methods are marked &quot;HasSecurity&quot; even if there are no permissions attached, e.g. if they use SuppressUnmanagedCodeSecurityAttribute 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.AbstractIL.IL.ILMethodDef.IsVirtual">
<summary>
 instance methods that are virtual or abstract or implement an interface slot.  The predicates (IsClassInitializer,IsConstructor,IsStatic,IsNonVirtualInstance,IsVirtual) form a complete, non-overlapping classification of this type
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.AbstractIL.IL.ILMethodDef.IsStatic">
<summary>
 static methods.  The predicates (IsClassInitializer,IsConstructor,IsStatic,IsNonVirtualInstance,IsVirtual) form a complete, non-overlapping classification of this type
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.AbstractIL.IL.ILMethodDef.IsNonVirtualInstance">
<summary>
 instance methods that are not virtual.  The predicates (IsClassInitializer,IsConstructor,IsStatic,IsNonVirtualInstance,IsVirtual) form a complete, non-overlapping classification of this type
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.AbstractIL.IL.ILMethodDef.IsConstructor">
<summary>
 .ctor methods.  The predicates (IsClassInitializer,IsConstructor,IsStatic,IsNonVirtualInstance,IsVirtual) form a complete, non-overlapping classification of this type
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.AbstractIL.IL.ILMethodDef.IsClassInitializer">
<summary>
 .cctor methods.  The predicates (IsClassInitializer,IsConstructor,IsStatic,IsNonVirtualInstance,IsVirtual) form a complete, non-overlapping classification of this type
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILMethodDef">
<summary>
 Method definitions.

 There are several different flavours of methods (constructors,
 abstract, virtual, static, instance, class constructors).  There
 is no perfect factorization of these as the combinations are not
 independent.  
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.AbstractIL.IL.ILGenericParameterDef.HasDefaultConstructorConstraint">
<summary>
 Indicates the type argument must have a public nullary constructor 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.AbstractIL.IL.ILGenericParameterDef.HasNotNullableValueTypeConstraint">
<summary>
 Indicates the type argument must be a value type, but not Nullable 
</summary>
</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.AbstractIL.IL.ILGenericParameterDef.HasReferenceTypeConstraint">
<summary>
 Indicates the type argument must be a reference type 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.AbstractIL.IL.ILGenericParameterDef.Variance">
<summary>
 Variance of type parameters, only applicable to generic parameters for generic interfaces and delegates 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.AbstractIL.IL.ILGenericParameterDef.Constraints">
<summary>
 At most one is the parent type, the others are interface types 
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILGenericParameterDef">
<summary>
 Generic parameters.  Formal generic parameter declarations
 may include the bounds, if any, on the generic parameter.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILOverridesSpec">
<summary>
 [OverridesSpec] - refer to a method declaration in a superclass 
 or superinterface. Used for overriding/method impls.  Includes
 a type for the parent for the same reason that a method specs
 includes the type of the enclosing type, i.e. the type
 gives the &quot;ILGenericArgs&quot; at which the parent type is being used.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.PInvokeCallingConvention">
<summary>
 PInvoke attributes.
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILPermissions">
<summary>
 Abstract type equivalent to ILPermission list - use helpers 
 below to construct/destruct these 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILSecurityAction">
<summary>
 Security ILPermissions
 
 Attached to various structures...
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILReturn">
<summary>
 Method return values
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.AbstractIL.IL.ILParameter.Marshal">
<summary>
 Marshalling map for parameters. COM Interop only. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILParameter">
<summary>
 Method parameters and return values
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILAttribute">
<summary>
 Custom attributes.  See &apos;decodeILAttribData&apos; for a helper to parse the byte[] 
 to ILAttribElem&apos;s as best as possible.  
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILAttributeNamedArg">
<summary>
 Named args: values and flags indicating if they are fields or properties 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILAttribElem.String">
<summary>
 Represents a custom attribute parameter of type &apos;string&apos;. These may be null, in which case they are encoded in a special
 way as indicated by Ecma-335 Partition II.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILMemberAccess">
<summary>
 Member Access
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.AbstractIL.IL.ILMethodBody.MaxStack">
<summary>
 strictly speakin should be a uint16 
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILMethodBody">
<summary>
 IL method bodies
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILLocal">
<summary>
 Local variables
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILNativeType">
<summary>
 Native Types, for marshalling to the native C interface.
 These are taken directly from the ILASM syntax, see ECMA Spec (Partition II, 7.4).  
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILFieldInit">
<summary>
 Field Init
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILExceptionBlock">
<summary>
   The &apos;seh&apos; specification can have several forms:

     FilterCatchBlock
       A multi-try-filter-catch block.  Execute the
       filters in order to determine which &apos;catch&apos; block to catch the
       exception with. There are two kinds of filters - one for 
       filtering exceptions by type and one by an instruction sequence. 
       Note that filter blocks can&apos;t contain any exception blocks. 

</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILCode">
<summary>
 ILCode
 
 The code for a method is made up of a &quot;code&quot; object.  Each &quot;code&quot;
 object gives the contents of the method in a &quot;semi-structured&quot; form, i.e.
   1. The structure implicit in the IL exception handling tables
      has been made explicit
   2. No relative offsets are used in the code: all branches and
      switch targets are made explicit as labels.
   3. All &quot;fallthroughs&quot; from one basic block to the next have
      been made explicit, by adding extra &quot;branch&quot; instructions to
      the end of basic blocks which simply fallthrough to another basic
      block.

 You can convert a straight-line sequence of instructions to structured
 code by using buildILCode and 
 Most of the interesting code is contained in BasicBlocks. If you&apos;re
 just interested in getting started with the format then begin
 by simply considering methods which do not contain any branch 
 instructions, or methods which do not contain any exception handling
 constructs.

 The above format has the great advantage that you can insert and 
 delete new code blocks without needing to fixup relative offsets
 or exception tables.  

 ILBasicBlock(bblock)
   See above

 GroupBlock(localDebugInfo, blocks)
   A set of blocks, with interior branching between the blocks.  For example
       B1:  ldarg 1
            br B2

       B2:  pop
            ret

   will be two basic blocks
       let b1 = ILBasicBlock(&quot;B1&quot;, [| I_ldarg(1); I_br(&quot;B2&quot;) |])
       let b2 = ILBasicBlock(&quot;B2&quot;, [| I_arith(AI_pop); I_ret |])
       GroupBlock([], [b1; b2])

   A GroupBlock can include a list of debug info records for locally 
   scoped local variables.  These indicate that within the given blocks
   the given local variables are used for the given Debug info 
   will only be recorded for local variables
   declared in these nodes, and the local variable will only appear live 
   in the debugger for the instructions covered by this node. So if you 
   omit or erase these nodes then no debug info will be emitted for local 
   variables.  If necessary you can have one outer ScopeBlock which specifies 
   the information for all the local variables 
  
   Not all the destination labels used within a group of blocks need
   be satisfied by that group alone.  For example, the interior &quot;try&quot; code
   of &quot;try&quot;-&quot;catch&quot; construct may be:
       B1:  ldarg 1
            br B2

       B2:  pop
            leave B3

   Again there will be two basic blocks grouped together:
       let b1 = ILBasicBlock(&quot;B1&quot;, [| I_ldarg(1); I_br(&quot;B2&quot;) |])
       let b2 = ILBasicBlock(&quot;B2&quot;, [| I_arith(AI_pop); I_leave(&quot;B3&quot;) |])
       GroupBlock([], [b1; b2])
   Here the code must be embedded in a method where &quot;B3&quot; is a label 
   somewhere in the method.

 RestrictBlock(labels,code) 
   This block hides labels, i.e. the given set of labels represent
   wiring which is purely internal to the given code block, and may not
   be used as the target of a branch by any blocks which this block
   is placed alongside.

   For example, if a method is made up of:
       B1:  ldarg 1
            br B2

       B2:  ret

   then the label &quot;B2&quot; is internal.  The overall code will
   be two basic blocks grouped together, surrounded by a RestrictBlock.
   The label &quot;B1&quot; is then the only remaining visible entry to the method
   and execution will begin at that label.

       let b1 = ILBasicBlock(&quot;B1&quot;, [| I_ldarg(1); I_br(&quot;B2&quot;) |])
       let b2 = ILBasicBlock(&quot;B2&quot;, [| I_arith(AI_pop); I_leave(&quot;B3&quot;) |])
       let gb1 = GroupBlock([], [b1; b2])
       RestrictBlock([&quot;B2&quot;], gb1)

   RestrictBlock is necessary to build well-formed code.  

 TryBlock(trycode,seh)

   A try-catch, try-finally or try-fault block.  
   If an exception is raised while executing
   an instruction in &apos;trycode&apos; then the exception handler given by
   &apos;seh&apos; is executed.

 Well-formedness conditions for code:

   Well-formed code includes nodes which explicitly &quot;hide&quot; interior labels.
   For example, the code object for a method may have only one entry
   label which is not hidden, and this label will be the label where 
   execution begins.  

   Both filter and catch blocks must have one 
   and only one entry.  These entry labels are not visible 
   outside the filter and catch blocks. Filter has no 
   exits (it always uses endfilter), catch may have exits. 
   The &quot;try&quot; block can have multiple entries, i.e. you can branch 
   into a try from outside.  They can have multiple exits, each of 
   which will be a &quot;leave&quot;.

</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILDebugMapping">
<summary>
 Indicates that a particular local variable has a particular source 
 language name within a GroupBlock. This does not effect local 
 variable numbering, which is global over the whole method. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILBasicBlock">
<summary>
 A list of instructions ending in an unconditionally
 branching instruction. A basic block has a label which must be unique
 within the method it is located in.  Only the first instruction of
 a basic block can be the target of a branch.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILInstr">
<summary>
 The instruction set.                                                     

 In general we don&apos;t categorize instructions, as different 
 instruction groups are relevant for different types of operations. 
 However we do collect the branch and compare instructions together 
 because they all take an address, and the ILArithInstr ones because 
 none of them take any direct arguments. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILCodeLabel">
<summary>
 ILCode labels.  In structured code each code label
 refers to a basic block somewhere in the code of the method.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILFieldSpec">
<summary>
 Field specs.  The data given for a ldfld, stfld etc. instruction.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILMethodSpec">
<summary>
 The information at the callsite of a method
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILFieldRef">
<summary>
 Formal identities of fields.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILMethodRef">
<summary>
 Formal identities of methods.  Method refs refer to methods on 
 named types.  In general you should work with ILMethodSpec objects
 rather than MethodRef objects, because ILMethodSpec objects carry
 information about how generic methods are instantiated.  MethodRef
 objects are only used at a few places in the Abstract IL syntax
 and if analyzing or generating IL you will be unlikely to come across
 these.
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILGenericArgs">
<summary>
 Actual generic parameters are  always types.  
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILType.Modified">
<summary>
 Custom modifiers. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILType.TypeVar">
<summary>
 Reference a generic arg. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILType.FunctionPointer">
<summary>
 ILCode pointers. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILType.Byref">
<summary>
 Managed pointers.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILType.Ptr">
<summary>
 Unmanaged pointers.  Nb. the type is used by tools and for binding only, not by the verifier.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILType.Boxed">
<summary>
 Reference types.  Also may be used for parents of members even if for members in value types. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILType.Value">
<summary>
 Unboxed types, including builtin types.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILType.Array">
<summary>
 Array types 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILType.Void">
<summary>
 Used only in return and pointer types.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.AbstractIL.IL.ILType.TypeSpec">
<summary>
 True if modifier is &quot;required&quot; 
 The class of the custom modifier. 
 The type being modified. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeSpec.TypeRef">
<summary>
 Which type is being referred to?
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeSpec.GenericArgs">
<summary>
 The type instantiation if the type is generic, otherwise empty
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeSpec">
<summary>
 Type specs and types.  

 These are the types that appear syntactically in .NET binaries.  

 Generic type definitions must be combined with
 an instantiation to form a type.  Throughout this file, 
 a &quot;ref&quot; refers to something that is uninstantiated, and
 a &quot;spec&quot; to a ref that is combined with the relevant instantiations.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeRef.Scope">
<summary>
 Where is the type, i.e. is it in this module, in another module in this assembly or in another assembly? 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeRef.Name">
<summary>
 The name of the type. This also contains the namespace if Enclosing is empty 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeRef.FullName">
<summary>
 The name of the type in the assembly using the &apos;.&apos; notation for nested types
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeRef.Enclosing">
<summary>
 The list of enclosing type names for a nested type. If non-nil then the first of these also contains the namespace.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeRef.BasicQualifiedName">
<summary>
 The name of the type in the assembly using the &apos;+&apos; notation for nested types
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeRef.Create(Microsoft.FSharp.Compiler.AbstractIL.IL.ILScopeRef,Microsoft.FSharp.Collections.FSharpList{System.String},System.String)">
<summary>
 Create a ILTypeRef
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeRef">
<summary>
 Type refs, i.e. references to types in some .NET assembly
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.AbstractIL.IL.ILArrayShape.SingleDimensional">
<summary>
 Bounds for a single dimensional, zero based array 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILArrayBound">
<summary>
 Array shapes. For most purposes, including verification, the
 rank is the only thing that matters.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILThisConvention.Static">
<summary>
 no &apos;this&apos; pointer is passed
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILThisConvention.InstanceExplicit">
<summary>
 accepts an explicit &apos;this&apos; pointer 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILThisConvention.Instance">
<summary>
 accepts an implicit &apos;this&apos; pointer 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILScopeRef.Assembly">
<summary>
 A reference to a type in another assembly
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILScopeRef.Module">
<summary>
 A reference to a type in a module in the same assembly
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILScopeRef.Local">
<summary>
 A reference to the type in the current module
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.AbstractIL.IL.ILAssemblyRef.Retargetable">
<summary>
 CLI says this indicates if the assembly can be retargeted (at runtime) to be from a different publisher. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.AbstractIL.IL.ILAssemblyRef.QualifiedName">
<summary>
 The fully qualified name of the assembly reference, e.g. mscorlib, Version=1.0.3705 etc.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.IlxExtensionInstr">
<summary>
 Represents an extension to the algebra of instructions
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.IlxExtensionTypeKind">
<summary>
 Represents an extension to the algebra of type kinds
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.IlxExtensionType">
<summary>
 Extensibility: ignore these unless you are generating ILX
 structures directly.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILSourceDocument">
<summary>
 Debug info.  Values of type &quot;source&quot; can be attached at sequence 
 points and some other locations. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILList`1">
<summary>
 The type used to store relatively small lists in the Abstract IL data structures, i.e. for ILTypes, ILGenericArgs, ILParameters and ILLocals.
 See comments in il.fs for why we&apos;ve isolated this representation and the possible future choices we might use here.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.computeILRefs(Microsoft.FSharp.Compiler.AbstractIL.IL.ILModuleDef)">
<summary>
 Find the full set of assemblies referenced by a module 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.parseILVersion(System.String)">
<summary>
 Get a version number from a CLR version string, e.g. 1.0.3705.0
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.sha1HashBytes(System.Byte[])">
<summary>
 Get a public key token from a public key.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.isILObjectTy(Microsoft.FSharp.Compiler.AbstractIL.IL.ILGlobals,Microsoft.FSharp.Compiler.AbstractIL.IL.ILType)">
<summary>
 Discriminating different important built-in types
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.mkInitializeArrayMethSpec(Microsoft.FSharp.Compiler.AbstractIL.IL.ILGlobals)">
<summary>
 Some commonly used methods 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.AbstractIL.IL.ecmaPublicKey">
<summary>
 This is a &apos;vendor neutral&apos; way of referencing mscorlib. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.instILType(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.AbstractIL.IL.ILType},Microsoft.FSharp.Compiler.AbstractIL.IL.ILType)">
<summary>
 Instantiate type variables that occur within types and other items. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.instILTypeAux(System.Int32,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.AbstractIL.IL.ILType},Microsoft.FSharp.Compiler.AbstractIL.IL.ILType)">
<summary>
 Instantiate type variables that occur within types and other items. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.buildILCode(System.String,Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Int32},Microsoft.FSharp.Compiler.AbstractIL.IL.ILInstr[],Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.AbstractIL.IL.ILExceptionSpec},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.AbstractIL.IL.ILLocalSpec})">
<summary>
 buildILCode: Build code from a sequence of instructions.
 
 e.g. &quot;buildILCode meth resolver instrs exns locals&quot;
 
 This makes the basic block structure of code from more primitive
 information, i.e. an array of instructions.
   [meth]: for debugging and should give the name of the method.
   [resolver]: should return the instruction indexes referred to 
               by code-label strings in the instruction stream.
   [instrs]: the instructions themselves, perhaps with attributes giving 
             debugging information
   [exns]: the table of exception-handling specifications
           for the method.  These are again given with respect to labels which will
           be mapped to pc&apos;s by [resolver].  
   [locals]: the table of specifications of when local variables are live and
           should appear in the debug info.
 
 If the input code is well-formed, the function will returns the 
 chop up the instruction sequence into basic blocks as required for
 the exception handlers and then return the tree-structured code
 corresponding to the instruction stream.
 A new set of code labels will be used throughout the resulting code.
 
 The input can be badly formed in many ways: exception handlers might
 overlap, or scopes of local variables may overlap badly with 
 exception handlers.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.rescopeILFieldRef(Microsoft.FSharp.Compiler.AbstractIL.IL.ILScopeRef,Microsoft.FSharp.Compiler.AbstractIL.IL.ILFieldRef)">
<summary>
 Rescoping. The first argument tells the function how to reference the original scope from 
 the new scope. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.rescopeILMethodRef(Microsoft.FSharp.Compiler.AbstractIL.IL.ILScopeRef,Microsoft.FSharp.Compiler.AbstractIL.IL.ILMethodRef)">
<summary>
 Rescoping. The first argument tells the function how to reference the original scope from 
 the new scope. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.rescopeILType(Microsoft.FSharp.Compiler.AbstractIL.IL.ILScopeRef,Microsoft.FSharp.Compiler.AbstractIL.IL.ILType)">
<summary>
 Rescoping. The first argument tells the function how to reference the original scope from 
 the new scope. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.rescopeILTypeSpec(Microsoft.FSharp.Compiler.AbstractIL.IL.ILScopeRef,Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeSpec)">
<summary>
 Rescoping. The first argument tells the function how to reference the original scope from 
 the new scope. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.rescopeILScopeRef(Microsoft.FSharp.Compiler.AbstractIL.IL.ILScopeRef,Microsoft.FSharp.Compiler.AbstractIL.IL.ILScopeRef)">
<summary>
 Rescoping. The first argument tells the function how to reference the original scope from 
 the new scope. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.mkRefForNestedILTypeDef(Microsoft.FSharp.Compiler.AbstractIL.IL.ILScopeRef,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeDef},Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeDef)">
<summary>
 Generate references to existing type definitions, method definitions
 etc.  Useful for generating references, e.g. to a  class we&apos;re processing
 Also used to reference type definitions that we&apos;ve generated.  [ILScopeRef] 
 is normally ILScopeRef.Local, unless we&apos;ve generated the ILTypeDef in
 an auxiliary module or are generating multiple assemblies at 
 once.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.mkILSimpleModule(System.String,System.String,System.Boolean,System.Tuple{System.Int32,System.Int32},System.Boolean,Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeDefs,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.String},System.Int32,Microsoft.FSharp.Compiler.AbstractIL.IL.ILExportedTypesAndForwarders,System.String)">
<summary>
 Making modules
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.mkILTypeDefsLazy(System.Lazy{Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Collections.FSharpList{System.String},System.String,Microsoft.FSharp.Compiler.AbstractIL.IL.ILAttributes,System.Lazy{Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeDef}}}})">
<summary>
 Create table of types which is loaded/computed on-demand, and whose individual 
 elements are also loaded/computed on-demand. Any call to tdefs.AsList will 
 result in the laziness being forced.  Operations can examine the
 custom attributes and name of each type in order to decide whether
 to proceed with examining the other details of the type.
 
 Note that individual type definitions may contain further delays 
 in their method, field and other tables. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.mkILCustomAttrs(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.AbstractIL.IL.ILAttribute})">
<summary>
 Making tables of custom attributes, etc.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.mkILTypeForGlobalFunctions(Microsoft.FSharp.Compiler.AbstractIL.IL.ILScopeRef)">
<summary>
 The toplevel &quot;class&quot; for a module or assembly.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.mkCtorMethSpecForDelegate(Microsoft.FSharp.Compiler.AbstractIL.IL.ILGlobals,Microsoft.FSharp.Compiler.AbstractIL.IL.ILType,System.Boolean)">
<summary>
 Given a delegate type definition which lies in a particular scope, 
 make a reference to its constructor
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.mkILStorageCtor(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Compiler.AbstractIL.IL.ILSourceMarker},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.AbstractIL.IL.ILInstr},Microsoft.FSharp.Compiler.AbstractIL.IL.ILType,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,Microsoft.FSharp.Compiler.AbstractIL.IL.ILType}},Microsoft.FSharp.Compiler.AbstractIL.IL.ILMemberAccess)">
<summary>
 Derived functions for making some simple constructors
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.prependInstrsToClassCtor(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.AbstractIL.IL.ILInstr},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Compiler.AbstractIL.IL.ILSourceMarker},Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeDef)">
<summary>
 Injecting initialization code into a class.
 Add some code to the end of the .cctor for a type.  Create a .cctor
 if one doesn&apos;t exist already.
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.prependInstrsToCode(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.AbstractIL.IL.ILInstr},Microsoft.FSharp.Compiler.AbstractIL.IL.ILCode)">
<summary>
 Injecting code into existing code blocks.  A branch will
 be added from the given instructions to the (unique) entry of
 the code, and the first instruction will be the new entry
 of the method.  The instructions should be non-branching.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.mkRawDataValueTypeDef(Microsoft.FSharp.Compiler.AbstractIL.IL.ILGlobals,System.String,System.Int32,System.UInt16)">
<summary>
 Make a type definition for a value type used to point to raw data.
 These are useful when generating array initialization code 
 according to the 
   ldtoken    field valuetype &apos;&lt;PrivateImplementationDetails&gt;&apos;/&apos;$$struct0x6000127-1&apos; &apos;&lt;PrivateImplementationDetails&gt;&apos;::&apos;$$method0x6000127-1&apos;
   call       void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(class System.Array,valuetype System.RuntimeFieldHandle)
 idiom.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.mkILGenericClass(System.String,Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeDefAccess,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.AbstractIL.IL.ILGenericParameterDef},Microsoft.FSharp.Compiler.AbstractIL.IL.ILType,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.AbstractIL.IL.ILType},Microsoft.FSharp.Compiler.AbstractIL.IL.ILMethodDefs,Microsoft.FSharp.Compiler.AbstractIL.IL.ILFieldDefs,Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeDefs,Microsoft.FSharp.Compiler.AbstractIL.IL.ILPropertyDefs,Microsoft.FSharp.Compiler.AbstractIL.IL.ILEventDefs,Microsoft.FSharp.Compiler.AbstractIL.IL.ILAttributes,Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeInit)">
<summary>
 Make a type definition
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.mkILInstanceField(System.String,Microsoft.FSharp.Compiler.AbstractIL.IL.ILType,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Compiler.AbstractIL.IL.ILFieldInit},Microsoft.FSharp.Compiler.AbstractIL.IL.ILMemberAccess)">
<summary>
 Make field definitions
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.mkILMethodBody(System.Boolean,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.AbstractIL.IL.ILLocal},System.Int32,Microsoft.FSharp.Compiler.AbstractIL.IL.ILCode,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Compiler.AbstractIL.IL.ILSourceMarker})">
<summary>
 Make method definitions
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.AbstractIL.IL.mkILEmptyGenericParams">
<summary>
 Make a formal generic parameters
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.mkILParam(Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Compiler.AbstractIL.IL.ILType)">
<summary>
 Derived functions for making return, parameter and local variable
 objects for use in method definitions.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.mkNormalCall(Microsoft.FSharp.Compiler.AbstractIL.IL.ILMethodSpec)">
<summary>
 Derived functions for making some common patterns of instructions
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.mkBasicBlock(Microsoft.FSharp.Compiler.AbstractIL.IL.ILBasicBlock)">
<summary>
 Some more primitive helpers 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.mkNonBranchingInstrs(System.Int32,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.AbstractIL.IL.ILInstr})">
<summary>
 Make a basic block. The final instruction must be control flow 
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.mkNonBranchingInstrsThen(System.Int32,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.AbstractIL.IL.ILInstr},Microsoft.FSharp.Compiler.AbstractIL.IL.ILInstr)">
<summary>
 Make some code that is a straight line sequence of instructions, then do 
 some control flow.  The first code label is the entry label of the generated code. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.nonBranchingInstrsToCode(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.AbstractIL.IL.ILInstr})">
<summary>
 Make some code that is a straight line sequence of instructions. 
 The function will add a &quot;return&quot; if the last instruction is not an exiting instruction 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.checkILCode(Microsoft.FSharp.Compiler.AbstractIL.IL.ILCode)">
<summary>
 Making code.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.mkILCustomAttribMethRef(Microsoft.FSharp.Compiler.AbstractIL.IL.ILGlobals,Microsoft.FSharp.Compiler.AbstractIL.IL.ILMethodSpec,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.AbstractIL.IL.ILAttribElem},Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,Microsoft.FSharp.Compiler.AbstractIL.IL.ILType,System.Boolean,Microsoft.FSharp.Compiler.AbstractIL.IL.ILAttribElem}})">
<summary>
 Make custom attributes 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.mkILFormalBoxedTy(Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeRef,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.AbstractIL.IL.ILGenericParameterDef})">
<summary>
 Make generalized verions of possibly-generic types,
 e.g. Given the ILTypeDef for List, return the type &quot;List&lt;T&gt;&quot;.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.mkILFieldRef(Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeRef,System.String,Microsoft.FSharp.Compiler.AbstractIL.IL.ILType)">
<summary>
 Construct references to fields 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.mkILCtorMethSpecForTy(Microsoft.FSharp.Compiler.AbstractIL.IL.ILType,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.AbstractIL.IL.ILType})">
<summary>
 Construct references to constructors 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.mkILNonGenericStaticMethSpecInTy(Microsoft.FSharp.Compiler.AbstractIL.IL.ILType,System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.AbstractIL.IL.ILType},Microsoft.FSharp.Compiler.AbstractIL.IL.ILType)">
<summary>
 Construct references to static, non-generic methods 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.mkILStaticMethSpecInTy(Microsoft.FSharp.Compiler.AbstractIL.IL.ILType,System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.AbstractIL.IL.ILType},Microsoft.FSharp.Compiler.AbstractIL.IL.ILType,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.AbstractIL.IL.ILType})">
<summary>
 Construct references to static methods 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.mkILNonGenericInstanceMethSpecInTy(Microsoft.FSharp.Compiler.AbstractIL.IL.ILType,System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.AbstractIL.IL.ILType},Microsoft.FSharp.Compiler.AbstractIL.IL.ILType)">
<summary>
 Construct references to instance methods 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.mkILInstanceMethSpecInTy(Microsoft.FSharp.Compiler.AbstractIL.IL.ILType,System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.AbstractIL.IL.ILType},Microsoft.FSharp.Compiler.AbstractIL.IL.ILType,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.AbstractIL.IL.ILType})">
<summary>
 Construct references to instance methods 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.mkILNonGenericMethSpecInTy(Microsoft.FSharp.Compiler.AbstractIL.IL.ILType,Microsoft.FSharp.Compiler.AbstractIL.IL.ILCallingConv,System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.AbstractIL.IL.ILType},Microsoft.FSharp.Compiler.AbstractIL.IL.ILType)">
<summary>
 Construct references to methods on a given type 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.mkILMethRefRaw(Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeRef,Microsoft.FSharp.Compiler.AbstractIL.IL.ILCallingConv,System.String,System.Int32,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.AbstractIL.IL.ILType},Microsoft.FSharp.Compiler.AbstractIL.IL.ILType)">
<summary>
 Make method references and specs
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.mkILTy(Microsoft.FSharp.Compiler.AbstractIL.IL.ILBoxity,Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeSpec)">
<summary>
 Make types
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.mkILNonGenericTySpec(Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeRef)">
<summary>
 Make type specs
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.mkILNestedTyRef(Microsoft.FSharp.Compiler.AbstractIL.IL.ILScopeRef,Microsoft.FSharp.Collections.FSharpList{System.String},System.String)">
<summary>
 Make type refs
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.mkSimpleAssRef(System.String)">
<summary>
 Generate simple references to assemblies and modules
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.decodeILAttribData(Microsoft.FSharp.Compiler.AbstractIL.IL.ILGlobals,Microsoft.FSharp.Compiler.AbstractIL.IL.ILAttribute,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Compiler.AbstractIL.IL.ILScopeRef})">
<summary>
 Note: not all custom attribute data can be decoded without binding types.  In particular 
 enums must be bound in order to discover the size of the underlying integer. 
 The following assumes enums have size int32. 
 It also does not completely decode System.Type attributes 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.destTypeDefsWithGlobalFunctionsFirst(Microsoft.FSharp.Compiler.AbstractIL.IL.ILGlobals,Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeDefs)">
<summary>
 When writing a binary the fake &quot;toplevel&quot; type definition (called &lt;Module&gt;)
 must come first. This function puts it first, and creates it in the returned list as an empty typedef if it 
 doesn&apos;t already exist.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.mkILGlobals(Microsoft.FSharp.Compiler.AbstractIL.IL.IPrimaryAssemblyTraits,Microsoft.FSharp.Core.FSharpOption{System.String},System.Boolean)">
<summary>
 Build the table of commonly used references given a ILScopeRef for system runtime assembly. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.splitTypeNameRight(System.String)">
<summary>
 splitTypeNameRight is like splitILTypeName except the 
 namespace is kept as a whole string, rather than split at dots.
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.splitILTypeName(System.String)">
<summary>
 The splitILTypeName utility helps you split a string representing
 a type name into the leading namespace elements (if any), the
 names of any nested types and the type name itself.  This function
 memoizes and interns the splitting of the namespace portion of
 the type name. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.IL.resolveILMethodRef(Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeDef,Microsoft.FSharp.Compiler.AbstractIL.IL.ILMethodRef)">
<summary>
 Find the method definition corresponding to the given property or 
 event operation. These are always in the same class as the property 
 or event. This is useful especially if your code is not using the Ilbind 
 API to bind references. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL.ILListModule">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.IL">
<summary>
 The &quot;unlinked&quot; view of .NET metadata and code.  Central to 
  to Abstract IL library
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.ILAsciiWriter">
<summary>
 Printer for the abstract syntax.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.ILBinaryReader.OpenILModuleReaderFromBytes(System.String,System.Byte[],Microsoft.FSharp.Compiler.AbstractIL.ILBinaryReader.ILReaderOptions)">
<summary>
 Open a binary reader based on the given bytes. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.ILBinaryReader.OpenILModuleReaderAfterReadingAllBytes(System.String,Microsoft.FSharp.Compiler.AbstractIL.ILBinaryReader.ILReaderOptions)">
<summary>
 Open a binary reader, except first copy the entire contents of the binary into 
 memory, close the file and ensure any subsequent reads happen from the in-memory store. 
 PDB files may not be read with this option. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.ILBinaryReader">
<summary>
 Binary reader.  Read a .NET binary and concert it to Abstract IL data
 structures.
 
 Notes:
   - The metadata in the loaded modules will be relative to 
     those modules, e.g. ILScopeRef.Local will mean &quot;local to 
     that module&quot;.  You must use [rescopeILType] etc. if you want to include 
     (i.e. copy) the metadata into your own module. 

   - PDB (debug info) reading/folding:
     The PDB reader is invoked if you give a PDB path 
     This indicates if you want to search for PDB files and have the 
     reader fold them in.  You cannot currently name the pdb file 
     directly - you can only name the path.  Giving &quot;None&quot; says 
     &quot;do not read the PDB file even if one exists&quot; 
 
     The debug info appears primarily as I_seqpoint annotations in 
     the instruction streams.  Unfortunately the PDB information does
     not, for example, tell you how to map back from a class definition
     to a source code line number - you will need to explicitly search
     for a sequence point in the code for one of the methods of the 
     class.  That is not particularly satisfactory, and it may be
     a good idea to build a small library which extracts the information
     you need.  
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.ILBinaryWriter.WriteILBinary(System.String,Microsoft.FSharp.Compiler.AbstractIL.ILBinaryWriter.options,Microsoft.FSharp.Compiler.AbstractIL.IL.ILModuleDef,System.Boolean)">
<summary>
 Write a binary to the file system. Extra configuration parameters can also be specified. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.ILBinaryWriter">
<summary>
 The IL Binary writer 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.ILRuntimeWriter.emEnv">
<summary>
 The (local) emitter env (state). Some of these fields are effectively global accumulators
 and could be placed as hash tables in the global environment.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.ILRuntimeWriter.cenv">
<summary>
 The global environment
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.ILRuntimeWriter.emitInstrTail(System.Reflection.Emit.ILGenerator,Microsoft.FSharp.Compiler.AbstractIL.IL.ILTailcall,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Emit the tail. prefix if necessary
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.ILRuntimeWriter.emitInstrAlign(System.Reflection.Emit.ILGenerator,Microsoft.FSharp.Compiler.AbstractIL.IL.ILAlignment)">
<summary>
 Emit the align. prefix
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.ILRuntimeWriter.emitInstrVolatile(System.Reflection.Emit.ILGenerator,Microsoft.FSharp.Compiler.AbstractIL.IL.ILVolatility)">
<summary>
 Emit the volatile. prefix
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.ILRuntimeWriter.emitInstrCompare(Microsoft.FSharp.Compiler.AbstractIL.ILRuntimeWriter.emEnv,System.Reflection.Emit.ILGenerator,Microsoft.FSharp.Compiler.AbstractIL.IL.ILComparisonInstr,System.Int32)">
<summary>
Emit comparison instructions
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.ILRuntimeWriter.convCreatedType(Microsoft.FSharp.Compiler.AbstractIL.ILRuntimeWriter.cenv,Microsoft.FSharp.Compiler.AbstractIL.ILRuntimeWriter.emEnv,Microsoft.FSharp.Compiler.AbstractIL.IL.ILType)">
<summary>
 Uses the .CreateType() for emitted type (if available)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.ILRuntimeWriter.convType(Microsoft.FSharp.Compiler.AbstractIL.ILRuntimeWriter.cenv,Microsoft.FSharp.Compiler.AbstractIL.ILRuntimeWriter.emEnv,Microsoft.FSharp.Compiler.AbstractIL.IL.ILType)">
<summary>
 Uses TypeBuilder/TypeBuilderInstantiation for emitted types
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.ILRuntimeWriter.getTRefType(Microsoft.FSharp.Compiler.AbstractIL.ILRuntimeWriter.cenv,Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeRef)">
<summary>
 Convert an Abstract IL type reference to Reflection.Emit System.Type value
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.ILRuntimeWriter.Zmap">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.ILRuntimeWriter">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.ByteBuffer">
<summary>
 Imperative buffers and streams of byte[]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Zmap`2">
<summary>
 Maps with a specific comparison function
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Zset`1">
<summary>
 Sets with a specific comparison function
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.AsciiConstants">
<summary>
 Various constants and utilities used when parsing the ILASM format for IL
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.AsciiLexer">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.AsciiParser.SigArg">
<summary>
 vararg sentinels
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.Internal.AsciiParser.prodIdxToNonTerminal(System.Int32)">
<summary>
 This function maps production indexes returned in syntax errors to strings representing the non terminal that would be produced by that production
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.AsciiParser">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.BinaryConstants.TableNames">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.BinaryConstants">
<summary>
 Internal use only.  Code and constants shared between binary reader/writer.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.Internal.Bytes.blit(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)">
<summary>
 each int will be 0 &lt;= x &lt;= 255 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.Internal.Bytes.ofInt32Array(System.Int32[])">
<summary>
 each int must be 0 &lt;= x &lt;= 255 
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.Internal.Bytes.get(System.Byte[],System.Int32)">
<summary>
 returned int will be 0 &lt;= x &lt;= 255
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Bytes">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.LayeredMultiMap`2">
<summary>
 Immutable map collection, with explicit flattening to a backing dictionary 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.LazyWithContext`2.findOriginalException">
<summary>
 A helper to ensure we rethrow the &quot;original&quot; exception
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.LazyWithContext`2.funcOrException">
<summary>
 This field holds either the function to run or a LazyWithContextFailure object recording the exception raised 
 from running the function. It is null if the thunk has been evaluated successfully.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.LazyWithContext`2.value">
<summary>
 This field holds the result of a successful computation. It&apos;s initial value is Unchecked.defaultof
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.LazyWithContext`2">
<summary>
 Just like &quot;Lazy&quot; but EVERY forcer must provide an instance of &quot;ctxt&quot;, e.g. to help track errors
 on forcing back to at least one sensible user location
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.Eventually`1">
<summary>
 Computations that can cooperatively yield by returning a continuation

    - Any yield of a NotYetDone should typically be &quot;abandonable&quot; without adverse consequences. No resource release
      will be called when the computation is abandoned.

    - Computations suspend via a NotYetDone may use local state (mutables), where these are
      captured by the NotYetDone closure. Computations do not need to be restartable.

    - The key thing is that you can take an Eventually value and run it with 
      Eventually.repeatedlyProgressUntilDoneOrTimeShareOver
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.getHole``1(Microsoft.FSharp.Core.FSharpRef{Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
 Get an initialization hole 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.Shim.FileSystem.SafeGetFullPath(System.String)">
<summary>
 Take in a filename with an absolute path, and return the same filename
 but canonicalized with respect to extra path separators (e.g. C:\\\\foo.txt) 
 and &apos;..&apos; portions
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.Shim">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.MultiMapModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.NameMultiMapModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.NameMapModule.subfold2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``3,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``2}}}},Microsoft.FSharp.Collections.FSharpMap{``0,``3},Microsoft.FSharp.Collections.FSharpMap{``0,``1},``2)">
<summary>
 For every entry in m2 find an entry in m1 and fold 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.NameMapModule.union``2(Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{``0},``1},System.Collections.Generic.IEnumerable{Microsoft.FSharp.Collections.FSharpMap{System.String,``0}})">
<summary>
 Union entries by identical key, using the provided function to union sets of values
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.NameMapModule.layerAdditive``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Collections.FSharpList{``0}}},Microsoft.FSharp.Collections.FSharpMap{``2,``1},Microsoft.FSharp.Collections.FSharpMap{``2,Microsoft.FSharp.Collections.FSharpList{``0}})">
<summary>
 Not a very useful function - only called in one place - should be changed 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.NameMapModule">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.Tables">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.EventuallyModule.repeatedlyProgressUntilDoneOrTimeShareOver``1(System.Int64,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.Eventually{``0}},Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.Eventually{``0}},Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.Eventually{``0})">
<summary>
 Keep running the computation bit by bit until a time limit is reached.
 The runner gets called each time the computation is restarted
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.EventuallyModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.FlatList">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.Map">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.ListSet">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.Lazy">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.HashsetModule">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.Dictionary">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.String">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.List.FrontAndBack">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.List">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.Option">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.Array">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.Order">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Library">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Support.PdbDocument">
<summary>
 PDB reader and associated types
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Support.PEFileType">
<summary>
 Unmanaged resource file linker - for native resources (not managed ones).
 The function may be called twice, once with a zero-RVA and
 arbitrary buffer, and once with the real buffer.  The size of the
 required buffer is returned.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.Internal.Support.getDebugFileName(System.String)">
<summary>
 Takes the output file name and returns debug file name.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.Support">
<summary>
 Functions associated with writing binaries which 
 vary between supported implementations of the CLI Common Language 
 Runtime, e.g. between the SSCLI, Mono and the Microsoft CLR.

 The implementation of the functions can be found in ilsupp-*.fs
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.ZmapModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Internal.ZsetModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.Morphs.morphILTypeRefsInILModuleMemoized(Microsoft.FSharp.Compiler.AbstractIL.IL.ILGlobals,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeRef,Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeRef},Microsoft.FSharp.Compiler.AbstractIL.IL.ILModuleDef)">
<summary>
 Morph all type references throughout an entire module.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.Morphs.morphILTypeDefsInILModule(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeDefs,Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeDefs},Microsoft.FSharp.Compiler.AbstractIL.IL.ILModuleDef)">
<summary>
 Morph all tables of ILTypeDefs in &quot;ILModuleDef&quot;
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.Morphs.morphILTypeDefs(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeDef,Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeDef},Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeDefs)">
<summary>
 nb. does not do nested tdefs
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.AbstractIL.Morphs.morphILScopeRefsInILTypeRef(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.AbstractIL.IL.ILScopeRef,Microsoft.FSharp.Compiler.AbstractIL.IL.ILScopeRef},Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeRef)">
<summary>
 Morph each scope reference inside a type signature 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.AbstractIL.Morphs">
<summary>
 A set of &quot;IL rewrites&quot; (&quot;morphs&quot;).  These map each sub-construct
 of particular ILTypeDefs.  The morphing functions are passed
 some details about the context in which the item being
 morphed occurs, e.g. the module being morphed itself, the
 ILTypeDef (possibly nested) where the item occurs, 
 the ILMethodDef (if any) where the item occurs. etc.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.StableNiceNameGenerator">
<summary>
 Generates compiler-generated names marked up with a source code location, but if given the same unique value then
 return precisely the same name. Each name generated also includes the StartLine number of the range passed in
 at the point of first generation.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.NiceNameGenerator">
<summary>
 Generates compiler-generated names. Each name generated also includes the StartLine number of the range passed in
 at the point of first generation.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.LexerWhitespaceContinuation">
<summary>
 The parser defines a number of tokens for whitespace and
 comments eliminated by the lexer.  These carry a specification of
 a continuation for the lexer for continued processing after we&apos;ve dealt with
 the whitespace.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.LexerEndlineContinuation">
<summary>
 Specifies how the &apos;endline&apos; function in the lexer should continue after
 it reaches end of line or eof. The options are to continue with &apos;token&apos; function
 or to continue with &apos;skip&apos; function.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynReturnInfo">
<summary>
 The syntactic elements associated with the &quot;return&quot; of a function or method. Some of this is
 mostly dummy information to make the return element look like an argument,
 the important thing is that (a) you can give a return type for the function or method, and 
 (b) you can associate .NET attributes to return of a function or method and these get stored in .NET metadata.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.QualifiedNameOfFile">
<summary>
 ImplFile(modname,isScript,qualName,hashDirectives,modules,isLastCompiland)
 QualifiedNameOfFile acts to fully-qualify module specifications and implementations, 
 most importantly the ones that simply contribute fragments to a namespace (i.e. the ParsedSigFileFragment.NamespaceFragment case) 
 There may be multiple such fragments in a single assembly.  There may thus also 
 be multiple matching pairs of these in an assembly, all contributing types to the same 
 namespace. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynModuleOrNamespace">
<summary>
 SynModuleOrNamespace(lid,isModule,decls,xmlDoc,attribs,SynAccess,m)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynMemberDefn.AutoProperty">
<summary>
 SynMemberDefn.AutoProperty (attribs,isStatic,id,tyOpt,propKind,memberFlags,xmlDoc,access,synExpr,mGetSet,mWholeAutoProp).
 
 F# syntax: &apos;member val X = expr&apos;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynMemberDefn.NestedType">
<summary>
 A feature that is not implemented
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynMemberDefn.LetBindings">
<summary>
 LetBindings(bindingList, isStatic, isRecursive, wholeRange)

 localDefns 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynMemberDefn.ImplicitInherit">
<summary>
 inherit &lt;typ&gt;(args...) as base 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynMemberDefn.ImplicitCtor">
<summary>
 implicit ctor args as a defn line, &apos;as&apos; specification 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExceptionDefn">
<summary>
 &apos;exception E = ... with ...&apos;
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExceptionRepr">
<summary>
 &apos;exception E = ... &apos;
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynValTyparDecls">
<summary>
 The names and other metadata for the type parameters for a member or function
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynArgInfo">
<summary>
 The argument names and other metadata for a parameter for a member or function
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynValInfo.SynValInfo">
<summary>
 SynValInfo(curriedArgInfos, returnInfo)
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynValInfo">
<summary>
 The argument names and other metadata for a member or function
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynComponentInfo">
<summary>
 The untyped, unchecked syntax tree associated with the name of a type definition or module
 in signature or implementation. 

 THis includes the name, attributes, type parameters, constraints, documentation and accessibility 
 for a type definition or module. For modules, entries such as the type parameters are
 always empty.
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynField">
<summary>
 The untyped, unchecked syntax tree for a field declaration in a record or class
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeDefnSig.TypeDefnSig">
<summary>
 The information for a type definition in a signature
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeDefnSig">
<summary>
 The untyped, unchecked syntax tree for a type definition in a signature
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeDefnSigRepr.Simple">
<summary>
 Indicates the right right-hand-side is a record, union or other simple type. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeDefnSigRepr.ObjectModel">
<summary>
 Indicates the right right-hand-side is a class, struct, interface or other object-model type
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeDefnSigRepr">
<summary>
 The untyped, unchecked syntax tree for the right-hand-side of a type definition in a signature.
 Note: in practice, using a discriminated union to make a distinction between 
 &quot;simple&quot; types and &quot;object oriented&quot; types is not particularly useful.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynUnionCaseType.UnionCaseFullType">
<summary>
 Full type spec given by &apos;UnionCase : ty1 * tyN -&gt; rty&apos;. Only used in FSharp.Core, otherwise a warning.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynUnionCaseType.UnionCaseFields">
<summary>
 Normal style declaration 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynUnionCaseType">
<summary>
 The untyped, unchecked syntax tree for the right-hand-side of union definition, excluding members,
 in either a signature or implementation.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynUnionCase.UnionCase">
<summary>
 The untyped, unchecked syntax tree for one case in a union definition.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynEnumCase.EnumCase">
<summary>
 The untyped, unchecked syntax tree for one case in an enum definition.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeDefnSimpleRepr.None">
<summary>
 An abstract definition , &quot;type X&quot;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeDefnSimpleRepr.TypeAbbrev">
<summary>
 A type abbreviation, &quot;type X = A.B.C&quot;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeDefnSimpleRepr.LibraryOnlyILAssembly">
<summary>
 A type defined by using an IL assembly representation. Only used in FSharp.Core.
 
 F# syntax: &quot;type X = (# &quot;...&quot;#)
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeDefnSimpleRepr.General">
<summary>
 An object oriented type definition. This is not a parse-tree form, but represents the core
 type representation which the type checker splits out from the &quot;ObjectModel&quot; cases of type definitions.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeDefnSimpleRepr.Record">
<summary>
 A record type definition, type X = { A : int; B : int }
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeDefnSimpleRepr.Enum">
<summary>
 An enum type definition, type X = A = 1 | B = 2
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeDefnSimpleRepr.Union">
<summary>
 A union type definition, type X = A | B
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeDefnSimpleRepr">
<summary>
 The untyped, unchecked syntax tree for the core of a simple type definition, in either signature
 or implementation. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynMemberSig">
<summary>
 The untyped, unchecked syntax tree for a member signature, used in signature files, abstract member declarations
 and member constraints.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.MemberKind.PropertyGetSet">
<summary>
 An artifical member kind used prior to the point where a get/set property is split into two distinct members.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.MemberKind">
<summary>
 Note the member kind is actually computed partially by a syntax tree transformation in tc.fs
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Ast.SynAttribute.AppliesToGetterAndSetter">
<summary>
 Is this attribute being applied to a property getter or setter?
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Ast.SynAttribute.Target">
<summary>
 Target specifier, e.g. &quot;assembly&quot;,&quot;module&quot;,etc.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynPat.FromParseError">
<summary>
 A pattern arising from a parse error
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynPat.InstanceMember">
<summary>
 Used internally in the type checker
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynPat.DeprecatedCharRange">
<summary>
 Deprecated character ranges
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynPat.QuoteExpr">
 <@ expr @>, used for active pattern arguments
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynPat.IsInst">
<summary>
 &apos;:? type &apos;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynPat.OptionalVal">
<summary>
 &apos;?id&apos; -- for optional argument names
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynPat.Null">
<summary>
 &apos;null&apos;
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynSimplePats">
<summary>
 Represents a simple set of variable bindings a, (a,b) or (a:Type,b:Type) at a lambda,
 function definition or other binding point, after the elimination of pattern matching
 from the construct, e.g. after changing a &quot;function pat1 -&gt; rule1 | ...&quot; to a 
 &quot;fun v -&gt; match v with ...&quot;
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynSimplePatAlternativeIdInfo.Decided">
<summary>
 We have decided to use an alternative name in tha pattern and related expression 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynSimplePatAlternativeIdInfo.Undecided">
<summary>
 We have not decided to use an alternative name in tha pattern and related expression 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynSimplePat.Id">
<summary>
 Id (ident, altNameRefCell, isCompilerGenerated, isThisVar, isOptArg, range)

 Indicates a simple pattern variable.

   altNameRefCell 
     Normally &apos;None&apos; except for some compiler-generated variables in desugaring pattern matching. 
     Pattern processing sets this reference for hidden variable introduced by desugaring pattern matching in arguments.
     The info indicates an alternative (compiler generated) identifier to be used because the name of the identifier is already bound.
     See Product Studio FSharp 1.0, bug 6389.

   isCompilerGenerated : true if a compiler generated name 
   isThisVar: true if &apos;this&apos; variable in member  
   isOptArg: true if a &apos;?&apos; is in front of the name
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.DiscardAfterMissingQualificationAfterDot">
<summary>
 Inserted for error recovery when there is &quot;expr.&quot; and missing tokens or error recovery after the dot
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.FromParseError">
<summary>
 Inserted for error recovery
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.ArbitraryAfterError">
<summary>
 Inserted for error recovery
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.LibraryOnlyUnionCaseFieldSet">
<summary>
 Only used in FSharp.Core
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.LibraryOnlyUnionCaseFieldGet">
<summary>
 Only used in FSharp.Core
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.LibraryOnlyStaticOptimization">
<summary>
 Only used in FSharp.Core
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.LibraryOnlyILAssembly">
<summary>
 Only used in FSharp.Core
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.DoBang">
<summary>
 F# syntax: do! expr 
 Computation expressions only
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.LetOrUseBang">
<summary>
 SynExpr.LetOrUseBang(spBind, isUse, isFromSource, pat, rhsExpr, bodyExpr, mWholeExpr).

 F# syntax: let! pat = expr in expr
 F# syntax: use! pat = expr in expr
 Computation expressions only
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.YieldOrReturnFrom">
<summary>
 F# syntax: yield! expr 
 F# syntax: return! expr 
 Computation expressions only
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.YieldOrReturn">
<summary>
 F# syntax: yield expr 
 F# syntax: return expr 
 Computation expressions only
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.ImplicitZero">
<summary>
 F# syntax: &lt;implicit&gt;
 Computation expressions only, implied by final &quot;do&quot; or &quot;do!&quot;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.JoinIn">
<summary>
 F# syntax: ... in ... 
 Computation expressions only, based on JOIN_IN token from lex filter
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.TraitCall">
<summary>
 F# syntax: ((typar1 or ... or typarN): (member-dig) expr)
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.AddressOf">
<summary>
 F# syntax: &amp;expr, &amp;&amp;expr
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.Null">
<summary>
 F# syntax: null
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.InferredDowncast">
<summary>
 F# syntax: downcast expr
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.InferredUpcast">
<summary>
 F# syntax: upcast expr
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.Downcast">
<summary>
 F# syntax: expr :?&gt; type 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.Upcast">
<summary>
 F# syntax: expr :&gt; type 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.TypeTest">
<summary>
 F# syntax: expr :? type
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.DotNamedIndexedPropertySet">
<summary>
 F# syntax: expr.Items(e1) &lt;- e2 , rarely used named-property-setter notation, e.g. (stringExpr).Chars(3) &lt;- &apos;a&apos;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.NamedIndexedPropertySet">
<summary>
 F# syntax: Type.Items(e1) &lt;- e2 , rarely used named-property-setter notation, e.g. Foo.Bar.Chars(3) &lt;- &apos;a&apos;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.DotIndexedSet">
<summary>
 DotIndexedSet (objectExpr, indexExprs, valueExpr, rangeOfLeftOfSet, rangeOfDot, rangeOfWholeExpr)

 F# syntax: expr.[expr,...,expr] &lt;- expr
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.DotIndexedGet">
<summary>
 F# syntax: expr.[expr,...,expr] 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.DotSet">
<summary>
 F# syntax: expr.ident...ident &lt;- expr
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.DotGet">
<summary>
 DotGet(expr, rangeOfDot, lid, wholeRange)

 F# syntax: expr.ident.ident
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.LongIdentSet">
<summary>
 F# syntax: ident.ident...ident &lt;- expr
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.LongIdent">
<summary>
 F# syntax: ident.ident...ident
 LongIdent(isOptional, longIdent, altNameRefCell, m)
   isOptional: true if preceded by a &apos;?&apos; for an optional named parameter 
   altNameRefCell: Normally &apos;None&apos; except for some compiler-generated variables in desugaring pattern matching. See SynSimplePat.Id
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.Ident">
<summary>
 F# syntax: ident
 Optimized representation, = SynExpr.LongIdent(false,[id],id.idRange) 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.IfThenElse">
<summary>
  IfThenElse(exprGuard,exprThen,optionalExprElse,spIfToThen,isFromErrorRecovery,mIfToThen,mIfToEndOfLastBranch)

 F# syntax: if expr then expr
 F# syntax: if expr then expr else expr
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.Sequential">
<summary>
 Seq(seqPoint, isTrueSeq, e1, e2, m)
  isTrueSeq: false indicates &quot;let v = a in b; v&quot; 

 F# syntax: expr; expr
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.Lazy">
<summary>
 F# syntax: lazy expr
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.TryFinally">
<summary>
 F# syntax: try expr finally expr
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.TryWith">
<summary>
 F# syntax: try expr with pat -&gt; expr
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.LetOrUse">
<summary>
 LetOrUse(isRecursive, isUse, bindings, body, wholeRange)

 F# syntax: let pat = expr in expr 
 F# syntax: let f pat1 .. patN = expr in expr 
 F# syntax: let rec f pat1 .. patN = expr in expr 
 F# syntax: use pat = expr in expr 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.TypeApp">
<summary>
 TypeApp(expr, mLessThan, types, mCommas, mGreaterThan, mTypeArgs, mWholeExpr) 
     &quot;mCommas&quot; are the ranges for interstitial commas, these only matter for parsing/design-time tooling, the typechecker may munge/discard them

 F# syntax: expr&lt;type1,...,typeN&gt;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.App">
<summary>
 App(exprAtomicFlag, isInfix, funcExpr, argExpr, m)
  - exprAtomicFlag: indicates if the applciation is syntactically atomic, e.g. f.[1] is atomic, but &apos;f x&apos; is not
  - isInfix is true for the first app of an infix operator, e.g. 1+2 becomes App(App(+,1),2), where the inner node is marked isInfix 
      (or more generally, for higher operator fixities, if App(x,y) is such that y comes before x in the source code, then the node is marked isInfix=true)

 F# syntax: f x
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.Assert">
<summary>
 F# syntax: assert expr 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.Do">
<summary>
 F# syntax: do expr 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.Match">
<summary>
 F# syntax: match expr with pat1 -&gt; expr | ... | patN -&gt; exprN
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.MatchLambda">
<summary>
 F# syntax: function pat1 -&gt; expr | ... | patN -&gt; exprN
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.Lambda">
<summary>
 First bool indicates if lambda originates from a method. Patterns here are always &quot;simple&quot; 
 Second bool indicates if this is a &quot;later&quot; part of an iterated sequence of lambdas

 F# syntax: fun pat -&gt; expr
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.CompExpr">
<summary>
 CompExpr(isArrayOrList, isNotNakedRefCell, expr)

 F# syntax: { expr }
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.ArrayOrListOfSeqExpr">
<summary>
 F# syntax: [ expr ], [| expr |]
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.ForEach">
<summary>
 SynExpr.ForEach (spBind, seqExprOnly, isFromSource, pat, enumExpr, bodyExpr, mWholeExpr).

 F# syntax: &apos;for ... in ... do ...&apos;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.For">
<summary>
 F# syntax: &apos;for i = ... to ... do ...&apos;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.While">
<summary>
 F# syntax: &apos;while ... do ...&apos;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.ObjExpr">
<summary>
 SynExpr.ObjExpr(objTy,argOpt,binds,extraImpls,mNewExpr,mWholeExpr)

 F# syntax: { new ... with ... }
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.New">
<summary>
 F# syntax: new C(...)
 The flag is true if known to be &apos;family&apos; (&apos;protected&apos;) scope 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.Record">
<summary>
 F# syntax: { f1=e1; ...; fn=en }
 SynExpr.Record((baseType, baseCtorArgs, mBaseCtor, sepAfterBase, mInherits), (copyExpr, sepAfterCopyExpr), (recordFieldName, fieldValue, sepAfterField), mWholeExpr)
 inherit includes location of separator (for tooling) 
 copyOpt contains range of the following WITH part (for tooling)
 every field includes range of separator after the field (for tooling)
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.ArrayOrList">
<summary>
 F# syntax: [ e1; ...; en ], [| e1; ...; en |]
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.Tuple">
<summary>
 F# syntax: e1, ..., eN
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.Typed">
<summary>
 F# syntax: expr : type
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.Const">
<summary>
 F# syntax: 1, 1.3, () etc.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.Quote">
<summary>
 F# syntax: &lt;@ expr @&gt;, &lt;@@ expr @@&gt;
 
 Quote(operator,isRaw,quotedSynExpr,isFromQueryExpression,m)
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynExpr.Paren">
<summary>
 F# syntax: (expr)

 Paren(expr, leftParenRange, rightParenRange, wholeRangeIncludingParentheses)

 Parenthesized expressions. Kept in AST to distinguish A.M((x,y)) 
 from A.M(x,y), among other things.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Ast.SynExpr.RangeSansAnyExtraDot">
<summary>
 range ignoring any (parse error) extra trailing dots
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Ast.SynExpr.RangeOfFirstPortion">
<summary>
 Attempt to get the range of the first token or initial portion only - this is extremely ad-hoc, just a cheap way to improve a certain &apos;query custom operation&apos; error range
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Ast.SynExpr.Range">
<summary>
 Get the syntactic range of source code covered by this construct.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynType.StaticConstantNamed">
<summary>
 F# syntax : ident=1 etc., used in static parameters to type providers
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynType.StaticConstantExpr">
<summary>
 F# syntax : const expr, used in static parameters to type providers
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynType.StaticConstant">
<summary>
 F# syntax : 1, &quot;abc&quot; etc, used in parameters to type providers
 For the dimensionless units i.e. 1 , and static parameters to provided types
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynType.MeasurePower">
<summary>
 F# syntax : for units of measure e.g. m^3 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynType.MeasureDivide">
<summary>
 F# syntax : for units of measure e.g. m / s 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynType.HashConstraint">
<summary>
 F# syntax : #type
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynType.WithGlobalConstraints">
<summary>
 F# syntax : typ with constraints
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynType.Anon">
<summary>
 F# syntax : _
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynType.Var">
<summary>
 F# syntax : &apos;Var
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynType.Fun">
<summary>
 F# syntax : type -&gt; type
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynType.Array">
<summary>
 F# syntax : type[]
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynType.Tuple">
<summary>
 F# syntax : type * ... * type
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynType.LongIdentApp">
<summary>
 LongIdentApp(typeName, longId, LESSm, tyArgs, commasm, GREATERm, wholem)

 F# syntax : type.A.B.C&lt;type, ..., type&gt;
   commasm: ranges for interstitial commas, these only matter for parsing/design-time tooling, the typechecker may munge/discard them
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynType.App">
<summary>
 App(typeName, LESSm, typeArgs, commasm, GREATERm, isPostfix, m)

 F# syntax : type&lt;type, ..., type&gt; or type type or (type,...,type) type
   isPostfix: indicates a postfix type application e.g. &quot;int list&quot; or &quot;(int,string) dict&quot;
   commasm: ranges for interstitial commas, these only matter for parsing/design-time tooling, the typechecker may munge/discard them
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynType.LongIdent">
<summary>
 F# syntax : A.B.C
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Ast.SynType.Range">
<summary>
 Get the syntactic range of source code covered by this construct.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynType">
<summary>
 The unchecked abstract syntax tree of F# types 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeConstraint.WhereTyparIsDelegate">
<summary>
 F# syntax is &apos;typar : delegate&lt;&apos;Args,unit&gt;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeConstraint.WhereTyparIsEnum">
<summary>
 F# syntax is &apos;typar : enum&lt;&apos;UnderlyingType&gt;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeConstraint.WhereTyparSupportsMember">
<summary>
 F# syntax is ^T : (static member MemberName : ^T * int -&gt; ^T) 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeConstraint.WhereTyparSubtypeOfType">
<summary>
 F# syntax is &apos;typar :&gt; type
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeConstraint.WhereTyparDefaultsToType">
<summary>
 F# syntax is default ^T : type
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeConstraint.WhereTyparIsEquatable">
<summary>
 F# syntax is &apos;typar : equality
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeConstraint.WhereTyparIsComparable">
<summary>
 F# syntax is &apos;typar : comparison 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeConstraint.WhereTyparSupportsNull">
<summary>
 F# syntax is &apos;typar : null
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeConstraint.WhereTyparIsUnmanaged">
<summary>
 F# syntax is &apos;typar : unmanaged
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeConstraint.WhereTyparIsReferenceType">
<summary>
 F# syntax : is &apos;typar : not struct
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeConstraint.WhereTyparIsValueType">
<summary>
 F# syntax : is &apos;typar : struct
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTypeConstraint">
<summary>
 The unchecked abstract syntax tree of F# type constraints
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynTyparDecl">
<summary>
 Represents the explicit declaration of a type parameter
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynBindingKind.DoBinding">
<summary>
 A &apos;do&apos; binding in a module. Must have type &apos;unit&apos;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynBindingKind.NormalBinding">
<summary>
 A normal &apos;let&apos; binding in a module
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynBindingKind.StandaloneExpression">
<summary>
 A standalone expression in a module
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynBindingKind">
<summary>
 The kind associated with a binding - &quot;let&quot;, &quot;do&quot; or a standalone expression
</summary>
</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Ast.ExprAtomicFlag.Atomic">
<summary>
 Says that the expression is an atomic expression, i.e. is of a form that has no whitespace unless 
 enclosed in parantheses, e.g. 1, &quot;3&quot;, ident, ident.[expr] and (expr). If an atomic expression has
 type T, then the largest expression ending at the same range as the atomic expression also has type T.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.RecordFieldName">
<summary>
 stores pair: record field name + (true if given record field name is syntactically correct and can be used in name resolution)
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.BlockSeparator">
<summary>
 denotes location of the separator block + optional position of the semicolon (used for tooling support)
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SeqExprOnly">
<summary>
 Indicates if a for loop is &apos;for x in e1 -&gt; e2&apos;, only valid in sequence expressions
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynMeasure">
<summary>
 The unchecked abstract syntax tree of F# unit of measure annotaitons. 
 This should probably be merged with the represenation of SynType.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.Measure">
<summary>
 Old comment: &quot;we never iterate, so the const here is not another SynConst.Measure&quot;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.UInt16s">
<summary>
 Used internally in the typechecker once an array of unit16 contants 
 is detected, to allow more efficient processing of large arrays of uint16 constants. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.Bytes">
<summary>
 F# syntax: verbatim or regular byte string, e.g. &quot;abc&quot;B.

 Also used internally in the typechecker once an array of unit16 contants 
 is detected, to allow more efficient processing of large arrays of uint16 constants. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.String">
<summary>
 F# syntax: verbatim or regular string, e.g. &quot;abc&quot;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.UserNum">
<summary>
 UserNum(value, suffix)

 F# syntax: 1Q, 1Z, 1R, 1N, 1G
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.Decimal">
<summary>
 F# syntax: 23.4M
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.Char">
<summary>
 F# syntax: &apos;a&apos;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.Double">
<summary>
 F# syntax: 1.30, 1.40e10 etc.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.Single">
<summary>
 F# syntax: 1.30f, 1.40e10f etc.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.UIntPtr">
<summary>
 F# syntax: 13un
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.IntPtr">
<summary>
 F# syntax: 13n
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.UInt64">
<summary>
 F# syntax: 13UL
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.Int64">
<summary>
 F# syntax: 13L
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.UInt32">
<summary>
 F# syntax: 13u, 0x4000u, 0o0777u
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.Int32">
<summary>
 F# syntax: 13, 0x4000, 0o0777
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.UInt16">
<summary>
 F# syntax: 13us, 0x4000us, 0o0777us, 0b0111101us
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.Int16">
<summary>
 F# syntax: 13s, 0x4000s, 0o0777s, 0b0111101s
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.Byte">
<summary>
 F# syntax: 13uy, 0x40uy, 0oFFuy, 0b0111101uy
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.SByte">
<summary>
 F# syntax: 13y, 0xFFy, 0o077y, 0b0111101y
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.Bool">
<summary>
 F# syntax: true, false
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst.Unit">
<summary>
 F# syntax: ()
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynConst">
<summary>
 The unchecked abstract syntax tree of constants in F# types and expressions.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.LongIdentWithDots.LongIdentWithDots">
<summary>
 LongIdentWithDots(lid, dotms)   
 Typically dotms.Length = lid.Length-1, but they may be same if (incomplete) code ends in a dot, e.g. &quot;Foo.Bar.&quot;
 The dots mostly matter for parsing, and are typically ignored by the typechecker, but 
 if dotms.Length = lid.Length, then the parser must have reported an error, so the typechecker is allowed
 more freedom about typechecking these expressions.
 LongIdent can be empty list - it is used to denote that name of some AST element is absent (i.e. empty type name in inherit)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.XmlDocCollector">
<summary>
 Used to collect XML documentation during lexing and parsing.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.rhs(Internal.Utilities.Text.Parsing.IParseState,System.Int32)">
<summary>
 Get the range corresponding to one of the r.h.s. symbols of a grammar rule while it is being reduced
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.rhs2(Internal.Utilities.Text.Parsing.IParseState,System.Int32,System.Int32)">
<summary>
 Get the range covering two of the r.h.s. symbols of a grammar rule while it is being reduced
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.lhs(Internal.Utilities.Text.Parsing.IParseState)">
<summary>
 Get the range corresponding to the result of a grammar rule while it is being reduced
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.mkSynRange(Internal.Utilities.Text.Lexing.Position,Internal.Utilities.Text.Lexing.Position)">
<summary>
 Get an F# compiler range from a lexer range
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.posOfLexPosition(Internal.Utilities.Text.Lexing.Position)">
<summary>
 Get an F# compiler position from a lexer position
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.ParseAssemblyCodeType(System.String,Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Helper for parsing the inline IL fragments. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.ParseAssemblyCodeInstructions(System.String,Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Helper for parsing the inline IL fragments. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.PushCurriedPatternsToExpr(Microsoft.FSharp.Compiler.Ast.SynArgNameGenerator,Microsoft.FSharp.Compiler.Range.range,System.Boolean,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Ast.SynPat},Microsoft.FSharp.Compiler.Ast.SynExpr)">
<summary>
 &quot;fun (UnionCase x) (UnionCase y) -&gt; body&quot; 
       ==&gt; 
   &quot;fun tmp1 tmp2 -&gt; 
        let (UnionCase x) = tmp1 in 
        let (UnionCase y) = tmp2 in 
        body&quot; 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.SimplePatOfPat(Microsoft.FSharp.Compiler.Ast.SynArgNameGenerator,Microsoft.FSharp.Compiler.Ast.SynPat)">
<summary>
 Push non-simple parts of a patten match over onto the r.h.s. of a lambda.
 Return a simple pattern and a function to build a match on the r.h.s. if the pattern is complex
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.|SynPatForNullaryArgs|_|(Microsoft.FSharp.Compiler.Ast.SynPat)">
<summary>
 Recognize the &apos;()&apos; in &apos;new()&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.|SynPatForConstructorDecl|_|(Microsoft.FSharp.Compiler.Ast.SynPat)">
<summary>
 Extract the argument for patterns corresponding to the declaration of &apos;new ... = ...&apos;
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.IsControlFlowExpression(Microsoft.FSharp.Compiler.Ast.SynExpr)">
<summary>
 This affects placement of sequence points
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.|LongOrSingleIdent|_|(Microsoft.FSharp.Compiler.Ast.SynExpr)">
<summary>
 Match a long identifier, including the case for single identifiers which gets a more optimized node in the syntax tree.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Ast.FsiDynamicModulePrefix">
<summary>
 The prefix of the names used for the fake namespace path added to all dynamic code entries in FSI.EXE
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SyntaxError">
<summary>
 The error raised by the parse_error_rich function, which is called by the parser engine
 when a syntax error occurs. The first object is the ParseErrorContext which contains a dump of
 information about the grammar at the point where the error occured, e.g. what tokens
 are valid to shift next at that point in the grammar. This information is processed in build.fs.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.LexbufLocalXmlDocStore.GrabXmlDocBeforeMarker(Internal.Utilities.Text.Lexing.LexBuffer{System.Char},Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Called from the parser each time we parse a construct that marks the end of an XML doc comment range,
 e.g. a &apos;type&apos; declaration. The markerRange is the range of the keyword that delimits the construct.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.LexbufLocalXmlDocStore.SaveXmlDocLine(Internal.Utilities.Text.Lexing.LexBuffer{System.Char},System.String,Microsoft.FSharp.Compiler.Range.pos)">
<summary>
 Called from the lexer to save a single line of XML doc comment.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.LexbufLocalXmlDocStore">
<summary>
 XmlDoc F# lexer/parser state, held in the BufferLocalStore for the lexer.
 This is the only use of the lexer BufferLocalStore in the codebase.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.SynInfo.InferSynValData(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Compiler.Ast.MemberFlags},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Compiler.Ast.SynPat},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Compiler.Ast.SynReturnInfo},Microsoft.FSharp.Compiler.Ast.SynExpr)">
<summary>
 Infer the syntactic information for a &apos;let&apos; or &apos;member&apos; definition, based on the argument pattern,
 any declared return information (e.g. .NET attributes on the return element), and the r.h.s. expression
 in the case of &apos;let&apos; definitions.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.SynInfo.InferLambdaArgs(Microsoft.FSharp.Compiler.Ast.SynExpr)">
<summary>
 For &apos;let&apos; definitions, we infer syntactic argument information from the r.h.s. of a definition, if it
 is an immediate &apos;fun ... -&gt; ...&apos; or &apos;function ...&apos; expression. This is noted in the F# language specification.
 This does not apply to member definitions.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.SynInfo.AdjustMemberArgs``1(Microsoft.FSharp.Compiler.Ast.MemberKind,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{``0}})">
<summary>
 Transform a property declared using &apos;[static] member P = expr&apos; to a method taking a &quot;unit&quot; argument.
 This is similar to IncorporateEmptyTupledArgForPropertyGetter, but applies to member definitions
 rather than member signatures.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.SynInfo.AdjustArgsForUnitElimination(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Ast.SynArgInfo}})">
<summary>
 Make sure only a solitary unit argument has unit elimination
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.SynInfo.InferSynArgInfoFromPat(Microsoft.FSharp.Compiler.Ast.SynPat)">
<summary>
 Infer the syntactic argument info for one or more arguments a pattern.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.SynInfo.InferSynArgInfoFromSimplePats(Microsoft.FSharp.Compiler.Ast.SynSimplePats)">
<summary>
 Infer the syntactic argument info for one or more arguments one or more simple patterns.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.SynInfo.InferSynArgInfoFromSimplePat(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Ast.SynAttribute},Microsoft.FSharp.Compiler.Ast.SynSimplePat)">
<summary>
 Infer the syntactic argument info for a single argument from a simple pattern.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.SynInfo.AttribsOfArgData(Microsoft.FSharp.Compiler.Ast.SynArgInfo)">
<summary>
 Get the argument attributes from the syntactic information for an argument.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.SynInfo.AritiesOfArgs(Microsoft.FSharp.Compiler.Ast.SynValInfo)">
<summary>
 Get the argument counts for each curried argument group. Used in some adhoc places in tc.fs.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.SynInfo.IncorporateSetterArg(Microsoft.FSharp.Compiler.Ast.SynValInfo)">
<summary>
 Add a parameter entry to the syntactic value information to represent the value argument for a property setter. This is 
 used for the implicit value argument in property setter signature specifications.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.SynInfo.IncorporateSelfArg(Microsoft.FSharp.Compiler.Ast.SynValInfo)">
<summary>
 Add a parameter entry to the syntactic value information to represent the &apos;this&apos; argument. This is 
 used for the implicit &apos;this&apos; argument in member signature specifications.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.SynInfo.IncorporateEmptyTupledArgForPropertyGetter(Microsoft.FSharp.Compiler.Ast.SynValInfo)">
<summary>
 Add a parameter entry to the syntactic value information to represent the &apos;()&apos; argument to a property getter. This is 
 used for the implicit &apos;()&apos; argument in property getter signature specifications.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.SynInfo.HasOptionalArgs(Microsoft.FSharp.Compiler.Ast.SynValInfo)">
<summary>
 Check if there are any optional arguments in the syntactic argument information. Used when adjusting the
 types of optional arguments for function and member signatures.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.SynInfo.IsOptionalArg(Microsoft.FSharp.Compiler.Ast.SynArgInfo)">
<summary>
 Check if one particular argument is an optional argument. Used when adjusting the
 types of optional arguments for function and member signatures.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ast.SynInfo.HasNoArgs(Microsoft.FSharp.Compiler.Ast.SynValInfo)">
<summary>
 Determine if a syntactic information represents a member without arguments (which is implicitly a property getter)
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Ast.SynInfo.selfMetadata">
<summary>
 The &apos;argument&apos; information for the &apos;this&apos;/&apos;self&apos; parameter in the cases where it is not given explicitly
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Ast.SynInfo.unnamedRetVal">
<summary>
 The &apos;argument&apos; information for a return value where no attributes are given for the return value (the normal case)
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Ast.SynInfo.unitArgData">
<summary>
 The argument information for a &apos;()&apos; argument
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Ast.SynInfo.unnamedTopArg">
<summary>
 The argument information for a curried argument without a name
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Ast.SynInfo.unnamedTopArg1">
<summary>
 The argument information for an argument without a name
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.SynInfo">
<summary>
 Operations related to the syntactic analysis of arguments of value, function and member definitions and signatures.

 Function and member definitions have strongly syntactically constrained arities.  We infer
 the arity from the syntax.

 For example, we record the arity for: 
 StaticProperty --&gt; [1]               -- for unit arg
 this.InstanceProperty --&gt; [1;1]        -- for unit arg
 StaticMethod(args) --&gt; map InferSynArgInfoFromSimplePat args
 this.InstanceMethod() --&gt; 1 :: map InferSynArgInfoFromSimplePat args
 this.InstanceProperty with get(argpat) --&gt; 1 :: [InferSynArgInfoFromSimplePat argpat]
 StaticProperty with get(argpat) --&gt; [InferSynArgInfoFromSimplePat argpat]
 this.InstanceProperty with get() --&gt; 1 :: [InferSynArgInfoFromSimplePat argpat]
 StaticProperty with get() --&gt; [InferSynArgInfoFromSimplePat argpat]
 
 this.InstanceProperty with set(argpat)(v) --&gt; 1 :: [InferSynArgInfoFromSimplePat argpat; 1]
 StaticProperty with set(argpat)(v) --&gt; [InferSynArgInfoFromSimplePat argpat; 1]
 this.InstanceProperty with set(v) --&gt; 1 :: [1]
 StaticProperty with set(v) --&gt; [1] 
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.CustomOperations">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast.FSharpLib">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ast">

</member>
<member name="M:Microsoft.FSharp.Compiler.Augment.TypeDefinitelyHasEquality(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 This predicate can be used once type inference is complete, before then it is an approximation
 that doesn&apos;t assert any new constraints
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Augment">
<summary>
 Generate the hash/compare functions we add to user-defined types by default.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Build.LoadClosure.RootWarnings">
<summary>
 *Parse* warnings seen while parsing root of closure
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Build.LoadClosure.RootErrors">
<summary>
 *Parse* errors seen while parsing root of closure
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Build.LoadClosure.NoWarns">
<summary>
 The #nowarns
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Build.LoadClosure.Inputs">
<summary>
 The list of all sources in the closure with inputs when available
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Build.LoadClosure.UnresolvedReferences">
<summary>
 The list of references that were not resolved during load closure. These may still be extension references.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Build.LoadClosure.References">
<summary>
 The resolved references along with the ranges of the #r positions in each file.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Build.LoadClosure.SourceFiles">
<summary>
 The source files along with the ranges of the #load positions in each file.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Build.TcImports.TryResolveAssemblyReference(Microsoft.FSharp.Compiler.Build.AssemblyReference,Microsoft.FSharp.Compiler.Build.ResolveAssemblyReferenceMode)">
<summary>
 Try to resolve a referenced assembly based on TcConfig settings.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Build.TcImports.TryFindProviderGeneratedAssemblyByName(System.String)">
<summary>
 Try to find a provider-generated assembly
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Build.TcImports.TryFindExistingFullyQualifiedPathFromAssemblyRef(Microsoft.FSharp.Compiler.AbstractIL.IL.ILAssemblyRef)">
<summary>
 Try to find the given assembly reference.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Build.TcImports.ResolveAssemblyReference(Microsoft.FSharp.Compiler.Build.AssemblyReference,Microsoft.FSharp.Compiler.Build.ResolveAssemblyReferenceMode)">
<summary>
 Resolve a referenced assembly and report an error if the resolution fails.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Build.TcImports.ReportUnresolvedAssemblyReferences(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Build.UnresolvedAssemblyReference})">
<summary>
 Report unresolved references that also weren&apos;t consumed by any type providers.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Build.TcImports.GetCcusExcludingBase">
<summary>
 This excludes any framework imports (which may be shared between multiple builds)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Build.TcConfig.light">
<summary>
 Set if the user has explicitly turned indentation-aware syntax on/off
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Build.TcConfig.isInteractive">
<summary>
 If true, indicates all type checking and code generation is in the context of fsi.exe
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Build.TcConfig.ResolveSourceFile(Microsoft.FSharp.Compiler.Range.range,System.String,System.String)">
<summary>
 File system query based on TcConfig settings
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Build.TcConfig.MakePathAbsolute(System.String)">
<summary>
 File system query based on TcConfig settings
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Build.TcConfig.GetAvailableLoadedSources">
<summary>
 Get the loaded sources that exist and issue a warning for the ones that don&apos;t
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Build.TcConfigBuilder.isInteractive">
<summary>
 If true, indicates all type checking and code generation is in the context of fsi.exe
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Build.TcConfigBuilder.loadedSources">
<summary>
 Sources added into the build with #load
</summary>
</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Build.TcConfigBuilder.light">
<summary>
 Set if the user has explicitly turned indentation-aware syntax on/off
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Build.AssemblyResolution.sysdir">
<summary>
 Whether or not this is an installed system assembly (for example, System.dll)
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Build.AssemblyResolution.redist">
<summary>
 Name of the redist, if any, that the assembly was found in.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Build.AssemblyResolution.fusionName">
<summary>
 The qualified name of the assembly
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Build.AssemblyResolution.resolvedFrom">
<summary>
 Search path used to find this spot.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Build.AssemblyResolution.resolvedPath">
<summary>
 Path to the resolvedFile
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Build.AssemblyResolution.originalReference">
<summary>
 The original reference to the assembly.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Build.CompilerOptionBlock">
<summary>
 CompilerOption(name, argumentDescriptionString, actionSpec, exceptionOpt, helpTextOpt
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Build.OptionSpec">
<summary>
 The spec value describes the action of the argument,
 and whether it expects a following parameter.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Build.lightSyntaxDefaultExtensions">
<summary>
 File suffixes where #light is the default
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Build.scriptSuffixes">
<summary>
 Script file suffixes
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Build.implSuffixes">
<summary>
 Implementation file suffixes
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Build.sigSuffixes">
<summary>
 Signature file suffixes
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Build">
<summary>
 Loading initial context, reporting errors etc.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.ConstraintSolver.TcValF">
<summary>
 function type that denotes captured tcVal used in constraint solver
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.ConstraintSolver">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Detuple.GlobalUsageAnalysis.Results.IterationIsAtTopLevel">
<summary>
 top of expr toplevel? (true) 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Detuple.GlobalUsageAnalysis.Results.TopLevelBindings">
<summary>
 val not defined under lambdas 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Detuple.GlobalUsageAnalysis.Results.RecursiveBindings">
<summary>
 v -&gt; recursive? * v list   -- the others in the mutual binding 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Detuple.GlobalUsageAnalysis.Results.DecisionTreeBindings">
<summary>
 bound in a decision tree? 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Detuple.GlobalUsageAnalysis.Results.Defns">
<summary>
 v -&gt; binding repr 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Detuple.GlobalUsageAnalysis.Results.Uses">
<summary>
 v -&gt; context / APP inst args 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Detuple.GlobalUsageAnalysis.Results">
<summary>
 Results is &quot;expr information&quot;.
 This could extend to be a full graph view of the expr.
 Later could support &quot;safe&quot; change operations, and optimisations could be in terms of those.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Detuple.GlobalUsageAnalysis">

</member>
<member name="T:Microsoft.FSharp.Compiler.Detuple">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.DiagnosticMessage">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Driver.DelayAndForwardErrorLogger">
<summary>
 This error logger delays the messages it recieves. At the end, call ForwardDelayedErrorsAndWarnings
 to send the held messages.     
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Driver.ILResource.get_Bytes(Microsoft.FSharp.Compiler.AbstractIL.IL.ILResource)">
<summary>
 Read the bytes from a resource local to an assembly
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Driver.AdjustForScriptCompile(Microsoft.FSharp.Compiler.Build.TcConfigBuilder,Microsoft.FSharp.Collections.FSharpList{System.String},Microsoft.FSharp.Compiler.Lexhelp.LexResourceManager)">
<summary>
 Check for .fsx and, if present, compute the load closure for of #loaded files.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Driver.ErrorLoggerThatQuitsAfterMaxErrors(Microsoft.FSharp.Compiler.Build.TcConfigBuilder,Microsoft.FSharp.Compiler.ErrorLogger.Exiter)">
<summary>
 Create an error logger that counts and prints errors
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Driver.FileWriter">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Driver.StaticLinker">
<summary>
 OPTIONAL STATIC LINKING OF ALL DLLs THAT DEPEND ON THE F# LIBRARY
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Driver.MainModuleBuilder">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Driver.AttributeHelpers.TryFindStringAttribute(Microsoft.FSharp.Compiler.Env.TcGlobals,System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Attrib})">
<summary>
 Try to find an attribute that takes a string argument
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Driver.AttributeHelpers">
<summary>
 Helpers for finding attributes
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Driver.ManifestResourceFormat">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Driver.VersionResourceFormat">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Driver.ResFileFormat">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Driver.BinaryGenerationUtilities">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Driver.XmlDocWriter">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Driver.InterfaceFileWriter">

</member>
<member name="T:Microsoft.FSharp.Compiler.Driver">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Env.TcGlobals.memoize_file">
<summary>
 Memoization table to help minimize the number of ILSourceDocument objects we create
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Env.FSharpLib">

</member>
<member name="T:Microsoft.FSharp.Compiler.Env">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.ErrorLogger.CompileThreadStatic">
<summary>
 Type holds thread-static globals for use by the compile
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.ErrorLogger.PhasedError.Subcategory">
<summary>
 This is the textual subcategory to display in error and warning messages (shows only under --vserrors):

     file1.fs(72): subcategory warning FS0072: This is a warning message

</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.ErrorLogger.PhasedError.IsSubcategoryOfCompile(System.String)">
<summary>
 Return true if the textual phase given is from the compile part of the build process.
 This set needs to be equal to the set of subcategories that the language service can produce. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.ErrorLogger.PhasedError.IsPhaseInCompile">
<summary>
 Return true if this phase is one that&apos;s known to be part of the &apos;compile&apos;. This is the initial phase of the entire compilation that
 the language service knows about.                
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.ErrorLogger.PhasedError.Create(System.Exception,Microsoft.FSharp.Compiler.ErrorLogger.BuildPhase)">
<summary>
 Construct a phased error
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.ErrorLogger.BuildPhase">
<summary>
 Closed enumeration of build phases.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.ErrorLogger.NormalizeErrorString(System.String)">
<summary>
 fixes given string by replacing all control chars with spaces.
 NOTE: newlines are recognized and replaced with stringThatIsAProxyForANewlineInFlatErrors (ASCII 29, the &apos;group separator&apos;), 
 which is decoded by the IDE with &apos;NewlineifyErrorString&apos; back into newlines, so that multi-line errors can be displayed in QuickInfo
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.ErrorLogger.Iterate2D``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Compiler.ErrorLogger.OperationResult{Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Stop on first error. Accumulate warnings and continue. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.ErrorLogger.IterateIdxD``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Compiler.ErrorLogger.OperationResult{Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Stop on first error. Report index 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.ErrorLogger.OptionD``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Compiler.ErrorLogger.OperationResult{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Stop on first error. Accumulate warnings and continue. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.ErrorLogger.IterateD``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Compiler.ErrorLogger.OperationResult{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Stop on first error. Accumulate warnings and continue. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.ErrorLogger.op_PlusPlus``2(Microsoft.FSharp.Compiler.ErrorLogger.OperationResult{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Compiler.ErrorLogger.OperationResult{``1}})">
<summary>
 The bind in the monad. Stop on first error. Accumulate warnings and continue. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.ErrorLogger.PushErrorLoggerPhaseUntilUnwind``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.ErrorLogger.ErrorLogger,``0})">
<summary>
 NOTE: The change will be undone when the returned &quot;unwind&quot; object disposes
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.ErrorLogger.PushThreadBuildPhaseUntilUnwind(Microsoft.FSharp.Compiler.ErrorLogger.BuildPhase)">
<summary>
 NOTE: The change will be undone when the returned &quot;unwind&quot; object disposes
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.ErrorLogger.uninitializedErrorLoggerFallback">
<summary>
 When no errorLogger is installed (on the thread) use this one.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.ErrorLogger.StopProcessing">
<summary>
 Thrown when we stop processing the F# Interactive interactive entry or #load.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.ErrorLogger.ReportedError">
<summary>
 Thrown when immediate, local error recovery is not possible. This indicates
 we&apos;ve reported an error but need to make a non-local transfer of control.
 Error recovery may catch this and continue (see &apos;errorRecovery&apos;)

 The exception that caused the report is carried as data because in some
 situations (LazyWithContext) we may need to re-report the original error
 when a lazy thunk is re-evaluated.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.ErrorLogger.WrappedError">
<summary>
 Thrown when want to add some range information to some .NET exception
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.ErrorLogger.ErrorLoggerExtensions">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.ErrorLogger.BuildPhaseSubcategory">
<summary>
 Literal build phase subcategory strings.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.ErrorLogger">

</member>
<member name="F:Microsoft.FSharp.Compiler.ExtensionTyping.ProvidedAssemblyStaticLinkingMap.ILTypeMap">
<summary>
 The table of remappings from type names in the provided assembly to type
 names in the statically linked, embedded assembly.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.ExtensionTyping.ProvidedAssemblyStaticLinkingMap.CreateNew">
<summary>
 Create a new static linking map, ready to populate with data.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.ExtensionTyping.ProvidedAssemblyStaticLinkingMap">
<summary>
 The mapping information for one [&lt;Generate&gt;] definition, used to guide static linking.
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.ExtensionTyping.ProviderGeneratedType">
<summary>
 One node in a tree. There is one overall tree for each [&lt;Generate&gt;] definition.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.ExtensionTyping.ProvidedExpr.UnderlyingExpressionString">
<summary>
 Convert the expression to a string for diagnostics
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.ExtensionTyping.ProvidedTypeContext.RemapTyconRefs(Microsoft.FSharp.Core.FSharpFunc{System.Object,System.Object})">
<summary>
 Map the TyconRef objects, if any
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.ExtensionTyping.ProvidedTypeContext">
<summary>
 The context used to interpret information in the closure of System.Type, System.MethodInfo and other 
 info objects coming from the type provider.

 At the moment this is the &quot;Type --&gt; ILTypeRef&quot; and &quot;Type --&gt; Tycon&quot; remapping 
 context for generated types (it is empty for erased types). This is computed from
 while processing the [&lt;Generate&gt;] declaration related to the type.

 Immutable (after type generation for a [&lt;Generate&gt;] declaration populates the dictionaries).

 The &apos;obj&apos; values are all TyconRef, but obj is used due to a forward reference being required. Not particularly
 pleasant, but better than intertwining the whole &quot;ProvidedType&quot; with the TAST structure.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.ExtensionTyping.ResolutionEnvironment.temporaryFolder">
<summary>
 The folder for temporary files
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.ExtensionTyping.ResolutionEnvironment.referencedAssemblies">
<summary>
 All referenced assemblies, including the type provider itself, and possibly other type providers.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.ExtensionTyping.ResolutionEnvironment.showResolutionMessages">
<summary>
 Whether or not the --showextensionresolution flag was supplied to the compiler.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.ExtensionTyping.ResolutionEnvironment.outputFile">
<summary>
 Output file name
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.ExtensionTyping.ResolutionEnvironment.resolutionFolder">
<summary>
 The folder from which an extension provider is resolving from. This is typically the project folder.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.ExtensionTyping.ResolutionEnvironment">
<summary>
 Carries information about the current extension type resolution environment.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.ExtensionTyping.GetOriginalILTypeRefOfProvidedType(Microsoft.FSharp.Compiler.Tainted{Microsoft.FSharp.Compiler.ExtensionTyping.ProvidedType},Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Get location of a type before it is relocated by static linking
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.ExtensionTyping.GetILTypeRefOfProvidedType(Microsoft.FSharp.Compiler.Tainted{Microsoft.FSharp.Compiler.ExtensionTyping.ProvidedType},Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Get the parts of the name that encloses the .NET type including nested types, using the scheme needed for ILTypeRef 
 e.g. System.Object -&gt; [&quot;System.Object&quot;]
 e.g. Something.ClassType.NestedType -&gt; [&quot;Something.ClassType&quot;; &quot;NestedType&quot;]
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.ExtensionTyping.GetFSharpPathToProvidedType(Microsoft.FSharp.Compiler.Tainted{Microsoft.FSharp.Compiler.ExtensionTyping.ProvidedType},Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Decompose the enclosing name of a type (including any class nestings) into a list of parts.
 e.g. System.Object -&gt; [&quot;System&quot;; &quot;Object&quot;]
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.ExtensionTyping.GetPartsOfDotNetNamespace(Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tainted{Microsoft.FSharp.Core.CompilerServices.ITypeProvider},System.String)">
<summary>
 Decompose a .NET namespace into a list of parts.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.ExtensionTyping.TryLinkProvidedType(Microsoft.FSharp.Compiler.ExtensionTyping.ResolutionEnvironment,Microsoft.FSharp.Compiler.Tainted{Microsoft.FSharp.Core.CompilerServices.ITypeProvider},System.String[],System.String,Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Try to resolve a type in the given extension type resolver
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.ExtensionTyping.TryResolveProvidedType(Microsoft.FSharp.Compiler.ExtensionTyping.ResolutionEnvironment,Microsoft.FSharp.Compiler.Tainted{Microsoft.FSharp.Core.CompilerServices.ITypeProvider},Microsoft.FSharp.Compiler.Range.range,System.String[],System.String)">
<summary>
 Try to resolve a type in the given extension type resolver
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.ExtensionTyping.TryApplyProvidedType(Microsoft.FSharp.Compiler.Tainted{Microsoft.FSharp.Compiler.ExtensionTyping.ProvidedType},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.String}},System.Object[],Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Try to apply a provided type to the given static arguments. If successful also return a function 
 to check the type name is as expected (this function is called by the caller of TryApplyProvidedType
 after other checks are made).
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.ExtensionTyping.ValidateProvidedTypeAfterStaticInstantiation(Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tainted{Microsoft.FSharp.Compiler.ExtensionTyping.ProvidedType},System.String[],System.String)">
<summary>
 Validate that the given provided type meets some of the rules for F# provided types
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.ExtensionTyping.DisplayNameOfTypeProvider(Microsoft.FSharp.Compiler.Tainted{Microsoft.FSharp.Core.CompilerServices.ITypeProvider},Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Given an extension type resolver, supply a human-readable name suitable for error messages.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.ExtensionTyping.GetTypeProvidersOfAssembly(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit}},System.Boolean,Microsoft.FSharp.Core.FSharpRef{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.ExtensionTyping.ApprovalIO.TypeProviderApprovalStatus}},System.String,Microsoft.FSharp.Compiler.AbstractIL.IL.ILScopeRef,System.String,Microsoft.FSharp.Compiler.ExtensionTyping.ResolutionEnvironment,System.Boolean,System.Boolean,Microsoft.FSharp.Core.FSharpFunc{System.String,System.Boolean},System.Version,Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Return the set of extension type resolvers for the given assembly.
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.ExtensionTyping.ProvidedTypeResolutionNoRange">
<summary>
 Raised when an type provider has thrown an exception.    
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.ExtensionTyping.ProvidedTypeResolution">
<summary>
 Raised when a type provider has thrown an exception.    
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.ExtensionTyping.ApprovalIO.TypeProviderApprovalStatus.Trusted">
<summary>
 Trusted(absoluteFileName)
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.ExtensionTyping.ApprovalIO.TypeProviderApprovalStatus.NotTrusted">
<summary>
 NotTrusted(absoluteFileName)
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.ExtensionTyping.ApprovalIO.replaceApprovalStatus(Microsoft.FSharp.Core.FSharpOption{System.IO.FileStream},Microsoft.FSharp.Compiler.ExtensionTyping.ApprovalIO.TypeProviderApprovalStatus)">
<summary>
 replace one piece of TP approval info (or append it, if this is a new filename).  may throw if trouble with file IO.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.ExtensionTyping.ApprovalIO.readApprovalsFile(Microsoft.FSharp.Core.FSharpOption{System.IO.FileStream})">
<summary>
 read all TP approval data.  does not throw, will swallow exceptions and return empty list if there&apos;s trouble.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.ExtensionTyping.ApprovalIO.doWithApprovalsFile``1(Microsoft.FSharp.Core.FSharpOption{System.IO.FileStream},Microsoft.FSharp.Core.FSharpFunc{System.IO.FileStream,``0})">
<summary>
 do a transaction of operations over approvals file under exclusive lock.  may throw if trouble with file IO.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.ExtensionTyping.ApprovalIO.ApprovalsAbsoluteFileName">
<summary>
 location of approvals data file, e.g. C:\Users\username\AppData\Local\Microsoft\VisualStudio\12.0\type-providers.txt
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.ExtensionTyping.ApprovalIO">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.ExtensionTyping.GlobalsTheLanguageServiceCanPoke">

</member>
<member name="T:Microsoft.FSharp.Compiler.ExtensionTyping">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.FindUnsolved">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Formats">
<summary>
 Parse &quot;printf-style&quot; format specifiers at compile time, producing
 a list of items that specify the types of the things that follow.

 Must be updated if the Printf runtime component is updated.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Fscopts">

</member>
<member name="M:Microsoft.FSharp.Compiler.Ilxgen.IlxAssemblyGenerator.LookupGeneratedValue(Microsoft.FSharp.Compiler.Ilxgen.ExecutionContext,Microsoft.FSharp.Compiler.Tast.Val)">
<summary>
 Invert the compilation of the given value and return its current dynamic value and its compiled System.Type
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ilxgen.IlxAssemblyGenerator.GenerateCode(Microsoft.FSharp.Compiler.Ilxgen.IlxGenOptions,Microsoft.FSharp.Compiler.Tast.TypedAssembly,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Attrib},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Attrib})">
<summary>
 Generate ILX code for an assembly fragment
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ilxgen.IlxAssemblyGenerator.CreatePermissionSets(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Attrib})">
<summary>
 Create the CAS permission sets for an assembly fragment
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ilxgen.IlxAssemblyGenerator.ClearGeneratedValue(Microsoft.FSharp.Compiler.Ilxgen.ExecutionContext,Microsoft.FSharp.Compiler.Tast.Val)">
<summary>
 Invert the compilation of the given value and clear the storage of the value
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ilxgen.IlxAssemblyGenerator.AddIncrementalLocalAssemblyFragment(System.Boolean,System.String,Microsoft.FSharp.Compiler.Tast.TypedAssembly)">
<summary>
 Register a fragment of the current assembly with the ILX code generator. If &apos;isIncrementalFragment&apos; is true then the input
 is assumed to be a fragment &apos;typed&apos; into FSI.EXE, otherwise the input is assumed to be the result of a &apos;#load&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ilxgen.IlxAssemblyGenerator.AddExternalCcus(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.CcuThunk})">
<summary>
 Register a set of referenced assemblies with the ILX code generator
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Ilxgen.IlxAssemblyGenerator.#ctor(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Tast.ValRef,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Tast.ValUseFlag,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Range.range,System.Tuple{Microsoft.FSharp.Compiler.Tast.Expr,Microsoft.FSharp.Compiler.Tast.TType}}}}},Microsoft.FSharp.Compiler.Tast.CcuThunk)">
<summary>
 Create an incremental ILX code generator for a single assembly
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ilxgen.IlxAssemblyGenerator">
<summary>
 An incremental ILX code generator for a single assembly
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ilxgen.ExecutionContext">
<summary>
 Used to support the compilation-inversion operations &quot;ClearGeneratedValue&quot; and &quot;LookupGeneratedValue&quot;
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Ilxgen.IlxGenResults.quotationResourceBytes">
<summary>
 The generated IL/ILX resources associated with F# quotations
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Ilxgen.IlxGenResults.ilNetModuleAttrs">
<summary>
 The generated IL/ILX .NET module attributes
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Ilxgen.IlxGenResults.ilAssemAttrs">
<summary>
 The generated IL/ILX assembly attributes
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Ilxgen.IlxGenResults.ilTypeDefs">
<summary>
 The generated IL/ILX type definitions
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Ilxgen.IlxGenResults">
<summary>
 The results of the ILX compilation of one fragment of an assembly
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Ilxgen.IlxGenOptions.alwaysCallVirt">
<summary>
 Indicates that, whenever possible, use callvirt instead of call
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Ilxgen.IlxGenOptions.isInteractive">
<summary>
 Indicates the code is being generated in FSI.EXE and is executed immediately after code generation
 This includes all interactively compiled code, including #load, definitions, and expressions
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Ilxgen.IlxGenOptions.mainMethodInfo">
<summary>
 If this is set, then the last module becomes the &quot;main&quot; module 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ilxgen.IlxGenBackend">
<summary>
 Indicates how the generated IL code is ultimately emitted 
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Ilxgen">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Import.ImportMap">
<summary>
 This is the context used for converting AbstractIL .NET and provided types to F# internal compiler data structures.
 We currently cache the conversion of AbstractIL ILTypeRef nodes, based on hashes of these.

 There is normally only one ImportMap for any assembly compilation, though additional instances can be created
 using tcImports.GetImportMap() if needed, and it is not harmful if multiple instances are used. The object 
 serves as an interface through to the tables stored in the primary TcImports structures defined in build.fs. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Import.AssemblyLoader.RecordGeneratedTypeRoot(Microsoft.FSharp.Compiler.ExtensionTyping.ProviderGeneratedType)">
<summary>
 Record a root for a [&lt;Generate&gt;] type to help guide static linking &amp; type relocation
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Import.AssemblyLoader.GetProvidedAssemblyInfo(Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tainted{Microsoft.FSharp.Compiler.ExtensionTyping.ProvidedAssembly})">
<summary>
 Get a flag indicating if an assembly is a provided assembly, plus the
 table of information recording remappings from type names in the provided assembly to type
 names in the statically linked, embedded assembly.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Import">

</member>
<member name="M:Microsoft.FSharp.Compiler.IncrementalBuild.BuildDescriptionScope.GetInitialPartialBuild(Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,System.Int32,Microsoft.FSharp.Collections.FSharpList{System.Object}}},Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,System.Object}})">
<summary>
 Set the conrete inputs for this build. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.IncrementalBuild.BuildDescriptionScope.DeclareVectorOutput``1(System.String,Microsoft.FSharp.Compiler.IncrementalBuild.Vector{``0})">
<summary>
 Declare a named vector output.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.IncrementalBuild.BuildDescriptionScope.DeclareScalarOutput``1(System.String,Microsoft.FSharp.Compiler.IncrementalBuild.Scalar{``0})">
<summary>
 Declare a named scalar output.
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.IncrementalBuild.BuildDescriptionScope">
<summary>
 Declare build outputs and bind them to real values.
 Only required for unit testing.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.IncrementalBuild.PartialBuild">
<summary>
 A set of build rules and the corresponding, possibly partial, results from building.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.IncrementalBuild.Vector`1">
<summary>
 A build vector.        
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.IncrementalBuild.GetVectorResultBySlot``1(System.String,System.Int32,Microsoft.FSharp.Compiler.IncrementalBuild.PartialBuild)">
<summary>
 Get an element of vector result or None if there were no results. Only required for unit testing.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.IncrementalBuild.GetVectorResult``1(System.String,Microsoft.FSharp.Compiler.IncrementalBuild.PartialBuild)">
<summary>
 Get a result vector. All results must be available or thrown an exception. Only required for unit testing.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.IncrementalBuild.GetScalarResult``1(System.String,Microsoft.FSharp.Compiler.IncrementalBuild.PartialBuild)">
<summary>
 Get a scalar vector. Result must be available. Only required for unit testing.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.IncrementalBuild.Step">
<summary>
 Do one step in the build. Only required for unit testing.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.IncrementalBuild.Eval(System.String,Microsoft.FSharp.Compiler.IncrementalBuild.PartialBuild)">
<summary>
 Evaluate a build. Only required for unit testing.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.IncrementalBuild.InputVector``1(System.String)">
<summary>
 Declares a scalar build input.
 Only required for unit testing.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.IncrementalBuild.InputScalar``1(System.String)">
<summary>
 Declares a vector build input.
 Only required for unit testing.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.IncrementalBuild.Vector.AsScalar``1(System.String,Microsoft.FSharp.Compiler.IncrementalBuild.Vector{``0})">
<summary>
 Convert a Vector into a Scalar.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.IncrementalBuild.Vector.Demultiplex``2(System.String,Microsoft.FSharp.Core.FSharpFunc{``0[],``1},Microsoft.FSharp.Compiler.IncrementalBuild.Vector{``0})">
<summary>
 Apply a function to a vector to get a scalar value.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.IncrementalBuild.Vector.ScanLeft``2(System.String,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Compiler.AbstractIL.Internal.Library.Eventually{``0}}},Microsoft.FSharp.Compiler.IncrementalBuild.Scalar{``0},Microsoft.FSharp.Compiler.IncrementalBuild.Vector{``1})">
<summary>
 Apply a function to each element of the vector, threading an accumulator argument
 through the computation. Returns intermediate results in a vector.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.IncrementalBuild.Vector.Stamp``1(System.String,Microsoft.FSharp.Core.FSharpFunc{``0,System.DateTime},Microsoft.FSharp.Compiler.IncrementalBuild.Vector{``0})">
<summary>
 Updates the creates a new vector with the same items but with 
 timestamp specified by the passed-in function.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.IncrementalBuild.Vector.Map``2(System.String,Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Compiler.IncrementalBuild.Vector{``0})">
<summary>
 Maps one vector to another using the given function.    
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.IncrementalBuild.Vector">
<summary>
 Methods for acting on build Vectors
 Only required for unit testing.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.IncrementalBuild.Scalar.Multiplex``2(System.String,Microsoft.FSharp.Core.FSharpFunc{``0,``1[]},Microsoft.FSharp.Compiler.IncrementalBuild.Scalar{``0})">
<summary>
 Apply a function to scalar value to produce a vector.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.IncrementalBuild.Scalar.Map``2(System.String,Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Compiler.IncrementalBuild.Scalar{``0})">
<summary>
 Apply a function to one scalar to produce another.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.IncrementalBuild.Scalar">
<summary>
 Methods for acting on build Scalars
 Only required for unit testing.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.IncrementalBuild">
<summary>
 Generalized Incremental Builder. This is exposed only for unittesting purposes.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.IncrementalFSharpBuild.IncrementalBuilder.ThereAreLiveTypeProviders">
<summary>
 Whether there are any &apos;live&apos; type providers that may need a refresh when a project is Cleaned
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.IncrementalFSharpBuild.IncrementalBuilder.TcConfig">
<summary>
 The TcConfig passed in to the builder creation.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.IncrementalFSharpBuild.IncrementalBuilder.IsAlive">
<summary>
 Check if the builder is not disposed
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.IncrementalFSharpBuild.IncrementalBuilder.ImportedCcusInvalidated">
<summary>
 Raised when a type provider invalidates the build.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.IncrementalFSharpBuild.IncrementalBuilder.Dependencies">
<summary>
 The list of files the build depends on
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.IncrementalFSharpBuild.IncrementalBuilder.BeforeTypeCheckFile">
<summary>
 Raised just before a file is type-checked, to invalidate the state of the file in VS and force VS to request a new direct typecheck of the file.
 The incremental builder also typechecks the file (error and intellisense results from the backgroud builder are not
 used by VS). 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.IncrementalFSharpBuild.IncrementalBuilder.TypeCheck">
<summary>
 Get the final typecheck result. Only allowed when &apos;generateTypedImplFiles&apos; was set on Create, otherwise the TypedAssembly will have not implementations.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.IncrementalFSharpBuild.IncrementalBuilder.Step">
<summary>
 Perform one step in the F# build.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.IncrementalFSharpBuild.IncrementalBuilder.IncrementUsageCount">
<summary>
 Increment the usage count on the IncrementalBuilder by 1. Ths initial usage count is 0. The returns an IDisposable which will 
 decrement the usage count on the entire build by 1 and dispose if it is no longer used by anyone.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.IncrementalFSharpBuild.IncrementalBuilder.GetSlotsCount">
<summary>
 Get the number of slots on the vector of parse results
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.IncrementalFSharpBuild.IncrementalBuilder.GetSlotOfFileName(System.String)">
<summary>
 Attempts to find the slot of the given input file name. Throws an exception if it couldn&apos;t find it.    
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.IncrementalFSharpBuild.IncrementalBuilder.GetParseResultsBySlot(System.Int32)">
<summary>
 Await the untyped parse results for a particular slot in the vector of parse results.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.IncrementalFSharpBuild.IncrementalBuilder.GetAntecedentTypeCheckResultsBySlot(System.Int32)">
<summary>
 Ensure that the given file has been typechecked.
 Get the preceding typecheck state of a slot, allow stale results.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.IncrementalFSharpBuild.IBEvent">
<summary>
 Used for unit testing
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.IncrementalFSharpBuild.GetCurrentIncrementalBuildEventNum">
<summary>
 Used for unit testing
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.IncrementalFSharpBuild.GetMostRecentIncrementalBuildEvents(System.Int32)">
<summary>
 Used for unit testing
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.IncrementalFSharpBuild">
<summary>
 Incremental builder for F# parsing and type checking.  
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.SigOfFunctionForDelegate">
<summary>
 The Invoke MethInfo, the function argument types, the function return type 
 and the overall F# function type for the function type associated with a .NET delegate type
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.IndexedList`1">
<summary>
 The input list is sorted from most-derived to least-derived type, so any System.Object methods 
 are at the end of the list. Return a filtered list where prior/subsequent members matching by name and 
 that are in the same equivalence class have been removed. We keep a name-indexed table to 
 be more efficient when we check to see if we&apos;ve already seen a particular named method. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.FindMemberFlag.PreferOverrides">
<summary>
 Get overrides instead of abstract slots when measuring whether a class/interface implements all its required slots. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.FindMemberFlag.IgnoreOverrides">
<summary>
 Prefer items toward the top of the hierarchy, which we do if the items are virtual 
 but not when resolving base calls. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.InfoReader.GetRawIntrinsicMethodSetsOfType(Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Compiler.Infos.AccessorDomain,Microsoft.FSharp.Compiler.Infos.AllowMultiIntfInstantiations,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Read the method infos for a type

 Cache the result for monomorphic types
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.InfoReader">
<summary>
 An InfoReader is an object to help us read and cache infos. 
 We create one of these for each file we typecheck. 

 REVIEW: We could consider sharing one InfoReader across an entire compilation 
 run or have one global one for each (g,amap) pair.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.HierarchyItem">
<summary>
 Sets of methods up the hierarchy, ignoring duplicates by name and sig.
 Used to collect sets of virtual methods, protected methods, protected
 properties etc. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.PropertyCollector">
<summary>
 A helper type to help collect properties.

 Join up getters and setters which are not associated in the F# data structure 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.AccessorDomain.AccessibleFromSomewhere">
<summary>
 Can access everything
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.AccessorDomain.AccessibleFromSomeFSharpCode">
<summary>
 An AccessorDomain which returns everything but .NET private/internal items.
 This is used 
    - when solving member trait constraints, which are solved independently of accessibility 
    - for failure paths in error reporting, e.g. to produce an error that an F# item is not accessible
    - an adhoc use in service.fs to look up a delegate signature
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.AccessorDomain.AccessibleFrom">
<summary>
 AccessibleFrom(cpaths, tyconRefOpt)

 cpaths: indicates we have the keys to access any members private to the given paths 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.AccessorDomain">
<summary>
 Represents the &apos;keys&apos; a particular piece of code can use to access other constructs?.
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.CompiledSig">
<summary>
 Represents the information about the compiled form of a method signature. Used when analyzing implementation
 relations between members and abstract slots.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.EventInfo.ProvidedEvent">
<summary>
 An F# use of an event backed by provided metadata
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.EventInfo.ILEvent">
<summary>
 An F# use of an event backed by .NET metadata
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.EventInfo.FSEvent">
<summary>
 An F# use of an event backed by F#-declared metadata
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.EventInfo.XmlDoc">
<summary>
 Get the intra-assembly XML documentation for the property.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.EventInfo.TcGlobals">
<summary>
 Get the TcGlobals associated with the object
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.EventInfo.IsValueType">
<summary>
 Indicates if the enclosing type for the event is a value type. 

 For an extension event, this indicates if the event extends a struct type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.EventInfo.IsStatic">
<summary>
 Indicates if this property is static.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.EventInfo.HasDirectXmlComment">
<summary>
 Indicates if this event has an associated XML comment authored in this assembly.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.EventInfo.EventName">
<summary>
 Get the logical name of the event.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.EventInfo.EnclosingType">
<summary>
 Get the enclosing type of the event. 

 If this is an extension member, then this is the apparent parent, i.e. the type the event appears to extend.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.EventInfo.ArbitraryValRef">
<summary>
 Try to get an arbitrary F# ValRef associated with the member. This is to determine if the member is virtual, amongst other things.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.EventInfo.GetRemoveMethod">
<summary>
 Get the &apos;remove&apos; method associated with an event
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.EventInfo.GetDelegateType(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Get the delegate type associated with the event. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.EventInfo.GetAddMethod">
<summary>
 Get the &apos;add&apos; method associated with an event
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.EventInfo.EventInfosUseIdenticalDefintions(Microsoft.FSharp.Compiler.Infos.EventInfo,Microsoft.FSharp.Compiler.Infos.EventInfo)">
<summary>
 Test whether two event infos have the same underlying definition.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.EventInfo.ComputeHashCode">
<summary>
 Calculates a hash code of event info (similar as previous)
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.EventInfo">
<summary>
 Describes an F# use of an event
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILEventInfo.TypeRef">
<summary>
 Get the declaring type of the event as an ILTypeRef
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILEventInfo.RawMetadata">
<summary>
 Get the raw Abstract IL metadata for the event
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILEventInfo.Name">
<summary>
 Get the name of the event
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILEventInfo.ILTypeInfo">
<summary>
 Get the declaring IL type of the event as an ILTypeInfo
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ILEventInfo.RemoveMethod(Microsoft.FSharp.Compiler.Env.TcGlobals)">
<summary>
 Get the ILMethInfo describing the &apos;remove&apos; method associated with the event
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ILEventInfo.IsStatic(Microsoft.FSharp.Compiler.Env.TcGlobals)">
<summary>
 Indicates if the property is static
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ILEventInfo.AddMethod(Microsoft.FSharp.Compiler.Env.TcGlobals)">
<summary>
 Get the ILMethInfo describing the &apos;add&apos; method associated with the event
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.ILEventInfo">
<summary>
 Describes an F# use of an event backed by Abstract IL metadata
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.PropInfo.ProvidedProp">
<summary>
 An F# use of a property backed by provided metadata
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.PropInfo.ILProp">
<summary>
 An F# use of a property backed by Abstract IL metadata
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.PropInfo.FSProp">
<summary>
 An F# use of a property backed by F#-declared metadata
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.PropInfo.XmlDoc">
<summary>
 Get the intra-assembly XML documentation for the property.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.PropInfo.TcGlobals">
<summary>
 Get the TcGlobals associated with the object
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.PropInfo.SetterMethod">
<summary>
 Get a MethInfo for the &apos;setter&apos; method associated with the property
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.PropInfo.PropertyName">
<summary>
 Get the logical name of the property.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.PropInfo.IsVirtualProperty">
<summary>
 True if the getter (or, if absent, the setter) is a virtual method
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.PropInfo.IsValueType">
<summary>
 Indicates if the enclosing type for the property is a value type. 

 For an extension property, this indicates if the property extends a struct type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.PropInfo.IsStatic">
<summary>
 Indicates if this property is static.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.PropInfo.IsNewSlot">
<summary>
 Indicates if the property is logically a &apos;newslot&apos;, i.e. hides any previous slots of the same name.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.PropInfo.IsIndexer">
<summary>
 Indicates if this property is an indexer property, i.e. a property with arguments.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.PropInfo.IsFSharpEventProperty">
<summary>
 Indicates if this is an F# property compiled as a CLI event, e.g. a [&lt;CLIEvent&gt;] property.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.PropInfo.IsExtensionMember">
<summary>
 Determine if this is an extension member. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.PropInfo.IsDispatchSlot">
<summary>
 Indicates if the getter (or, if absent, the setter) for the property is a dispatch slot.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.PropInfo.IsDefiniteFSharpOverride">
<summary>
 Indicates if this property is marked &apos;override&apos; and thus definitely overrides another property.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.PropInfo.HasSetter">
<summary>
 Indicates if this property has an associated setter method.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.PropInfo.HasGetter">
<summary>
 Indicates if this property has an associated getter method.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.PropInfo.HasDirectXmlComment">
<summary>
 Indicates if this property has an associated XML comment authored in this assembly.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.PropInfo.GetterMethod">
<summary>
 Get a MethInfo for the &apos;getter&apos; method associated with the property
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.PropInfo.EnclosingType">
<summary>
 Get the enclosing type of the proeprty. 

 If this is an extension member, then this is the apparent parent, i.e. the type the property appears to extend.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.PropInfo.DropSetter">
<summary>
 Return a new property info where there is no associated setter, only an associated getter.

 Property infos can combine getters and setters, assuming they are consistent w.r.t. &apos;virtual&apos;, indexer argument types etc.
 When checking consistency we split these apart
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.PropInfo.DropGetter">
<summary>
 Return a new property info where there is no associated getter, only an associated setter.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.PropInfo.ArbitraryValRef">
<summary>
 Try to get an arbitrary F# ValRef associated with the member. This is to determine if the member is virtual, amongst other things.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.PropInfo.PropInfosUseIdenticalDefinitions(Microsoft.FSharp.Compiler.Infos.PropInfo,Microsoft.FSharp.Compiler.Infos.PropInfo)">
<summary>
 Test whether two property infos have the same underlying definition.

 Uses the same techniques as &apos;MethInfosUseIdenticalDefinitions&apos;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.PropInfo.GetPropertyType(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Get the result type of the property
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.PropInfo.GetParamTypes(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Get the types of the indexer parameters associated with the property
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.PropInfo.GetParamNamesAndTypes(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Get the names and types of the indexer parameters associated with the property
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.PropInfo.GetParamDatas(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Get the details of the indexer parameters associated with the property
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.PropInfo.ComputeHashCode">
<summary>
 Calculates a hash code of property info (similar as previous)
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.PropInfo">
<summary>
 Describes an F# use of a property 
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILPropInfo.RawMetadata">
<summary>
 Get the raw Abstract IL metadata for the IL property
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILPropInfo.PropertyName">
<summary>
 Get the name of the IL property
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILPropInfo.IsStatic">
<summary>
 Indicates if the IL property is static
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILPropInfo.ILTypeInfo">
<summary>
 Get the declaring IL type of the IL property, including any generic instantiation
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILPropInfo.HasSetter">
<summary>
 Indicates if the IL property has a &apos;set&apos; method
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILPropInfo.HasGetter">
<summary>
 Indicates if the IL property has a &apos;get&apos; method
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ILPropInfo.SetterMethod(Microsoft.FSharp.Compiler.Env.TcGlobals)">
<summary>
 Gets the ILMethInfo of the &apos;set&apos; method for the IL property
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ILPropInfo.IsVirtual(Microsoft.FSharp.Compiler.Env.TcGlobals)">
<summary>
 Indicates if the IL property is virtual
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ILPropInfo.IsNewSlot(Microsoft.FSharp.Compiler.Env.TcGlobals)">
<summary>
 Indicates if the IL property is logically a &apos;newslot&apos;, i.e. hides any previous slots of the same name.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ILPropInfo.GetterMethod(Microsoft.FSharp.Compiler.Env.TcGlobals)">
<summary>
 Gets the ILMethInfo of the &apos;get&apos; method for the IL property
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ILPropInfo.GetPropertyType(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Get the return type of the IL property.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ILPropInfo.GetParamTypes(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Get the types of the indexer arguments associated wih the IL property.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ILPropInfo.GetParamNamesAndTypes(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Get the names and types of the indexer arguments associated wih the IL property.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.ILPropInfo">
<summary>
 Describes an F# use of a property backed by Abstract IL metadata
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.UnionCaseInfo.UnionCaseRef">
<summary>
 Get a reference to the F# metadata for the uninstantiated union case
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.UnionCaseInfo.UnionCase">
<summary>
 Get the F# metadata for the uninstantiated union case
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.UnionCaseInfo.TypeInst">
<summary>
 Get the generic instantiation of the declaring type of the union case
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.UnionCaseInfo.TyconRef">
<summary>
 Get a reference to the F# metadata for the declaring union type
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.UnionCaseInfo.Tycon">
<summary>
 Get the F# metadata for the declaring union type
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.UnionCaseInfo.Name">
<summary>
 Get the name of the union case
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.UnionCaseInfo">
<summary>
 Describes an F# use of a union case
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.RecdFieldInfo.TypeInst">
<summary>
 Get the generic instantiation of the declaring type of the field
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.RecdFieldInfo.TyconRef">
<summary>
 Get a reference to the F# metadata for the F#-declared record, class or struct type 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.RecdFieldInfo.Tycon">
<summary>
 Get the F# metadata for the F#-declared record, class or struct type 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.RecdFieldInfo.RecdFieldRef">
<summary>
 Get a reference to the F# metadata for the uninstantiated field
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.RecdFieldInfo.RecdField">
<summary>
 Get the F# metadata for the uninstantiated field
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.RecdFieldInfo.Name">
<summary>
 Get the name of the field in an F#-declared record, class or struct type 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.RecdFieldInfo.LiteralValue">
<summary>
 Indicate if the field is a literal field in an F#-declared record, class or struct type 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.RecdFieldInfo.IsStatic">
<summary>
 Indicate if the field is a static field in an F#-declared record, class or struct type 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.RecdFieldInfo.FieldType">
<summary>
 Get the (instantiated) type of the field in an F#-declared record, class or struct type 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.RecdFieldInfo.EnclosingType">
<summary>
 Get the enclosing (declaring) type of the field in an F#-declared record, class or struct type 
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.RecdFieldInfo">
<summary>
 Describes an F# use of a field in an F#-declared record, class or struct type 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.ILFieldInfo.ProvidedField">
<summary>
 Represents a single use of a field backed by provided metadata
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.ILFieldInfo.ILFieldInfo">
<summary>
 Represents a single use of a field backed by Abstract IL metadata
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILFieldInfo.TypeInst">
<summary>
 Get the type instantiation of the declaring type of the field 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILFieldInfo.ScopeRef">
<summary>
 Get the scope used to interpret IL metadata
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILFieldInfo.LiteralValue">
<summary>
 Indicates if the field is a literal field with an associated literal value
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILFieldInfo.IsValueType">
<summary>
 Indicates if the field is a member of a struct or enum type
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILFieldInfo.IsStatic">
<summary>
 Indicates if the field is static
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILFieldInfo.IsSpecialName">
<summary>
 Indicates if the field has the &apos;specialname&apos; property in the .NET IL
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILFieldInfo.IsInitOnly">
<summary>
 Indicates if the field is readonly (in the .NET/C# sense of readonly)
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILFieldInfo.ILTypeRef">
<summary>
 Get a reference to the declaring type of the field as an ILTypeRef
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILFieldInfo.ILFieldType">
<summary>
 Get the type of the field as an IL type
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILFieldInfo.ILFieldRef">
<summary>
 Get an (uninstantiated) reference to the field as an Abstract IL ILFieldRef
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILFieldInfo.FieldName">
<summary>
 GENERIC TYPE PROVIDERS
 Get the name of the field
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILFieldInfo.EnclosingType">
<summary>
 Get the enclosing (&quot;parent&quot;/&quot;declaring&quot;) type of the field. 
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ILFieldInfo.FieldType(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Get the type of the field as an F# type
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.ILFieldInfo">
<summary>
 Represents a single use of a IL or provided field from one point in an F# program
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.MethInfo.ProvidedMeth">
<summary>
 Describes a use of a method backed by provided metadata
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.MethInfo.DefaultStructCtor">
<summary>
 Describes a use of a pseudo-method corresponding to the default constructor for a .NET struct type
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.MethInfo.ILMeth">
<summary>
 ILMeth(tcGlobals, ilMethInfo, extensionMethodPriority).

 Describes a use of a method backed by Abstract IL # metadata
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.MethInfo.FSMeth">
<summary>
 FSMeth(tcGlobals, declaringType, valRef, extensionMethodPriority).

 Describes a use of a method declared in F# code and backed by F# metadata.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.MethInfo.XmlDoc">
<summary>
 Get the XML documentation associated with the method
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.MethInfo.TcGlobals">
<summary>
 Get the TcGlobals value that governs the method declaration
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.MethInfo.NumArgs">
<summary>
 Get a list of argument-number counts, one count for each set of curried arguments.

 For an extension member, drop the &apos;this&apos; argument.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.MethInfo.LogicalName">
<summary>
 Get the method name in LogicalName form, i.e. the name as it would be stored in .NET metadata
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.MethInfo.IsStruct">
<summary>
 Indicates if the enclosing type for the method is a value type. 

 For an extension method, this indicates if the method extends a struct type.
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.MethInfo.IsNullary">
<summary>
 Indicates if this method takes no arguments
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.MethInfo.IsInstance">
<summary>
 Does the method appear to the user as an instance method?
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.MethInfo.IsFSharpStyleExtensionMember">
<summary>
 Determine if this is an F# extension member. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.MethInfo.IsFSharpEventPropertyMethod">
<summary>
 Indicates if this method is a generated method associated with an F# CLIEvent property compiled as a .NET event
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.MethInfo.IsExtensionMember">
<summary>
 Determine if this is an extension member. 
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.MethInfo.IsDefiniteFSharpOverride">
<summary>
 Check if this method is marked &apos;override&apos; and thus definitely overrides another method.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.MethInfo.IsCSharpStyleExtensionMember">
<summary>
 Determine if this is an C#-style extension member. 
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.MethInfo.HasDirectXmlComment">
<summary>
 Indicates if this is a method defined in this assembly with an internal XML comment
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.MethInfo.GenericArity">
<summary>
 Get the number of generic method parameters for a method.
 For an extension method this includes all type parameters, even if it is extending a generic type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.MethInfo.FormalMethodTypars">
<summary>
 Get the formal generic method parameters for the method as a list of type variables.

 For an extension method this includes all type parameters, even if it is extending a generic type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.MethInfo.FormalMethodInst">
<summary>
 Get the formal generic method parameters for the method as a list of variable types.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.MethInfo.ExtensionMemberPriorityOption">
<summary>
 Get the extension method priority of the method, if it has one.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.MethInfo.ExtensionMemberPriority">
<summary>
 Get the extension method priority of the method. If it is not an extension method
 then use the highest possible value since non-extension methods always take priority
 over extension members.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.MethInfo.EnclosingType">
<summary>
 Get the enclosing type of the method info. 

 If this is an extension member, then this is the apparent parent, i.e. the type the method appears to extend.
 This may be a variable type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.MethInfo.DisplayName">
<summary>
 Get the method name in DisplayName form
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.MethInfo.DeclaringTypeInst">
<summary>
 Get the actual type instantiation of the declaring type associated with this use of the method.
 
 For extension members this is empty (the instantiation of the declaring type). 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.MethInfo.DeclaringEntityRef">
<summary>
 Get the declaring type or module holding the method. If this is an C#-style extension method then this is the type
 holding the static member that is the extension method. If this is an F#-style extension method it is the logical module
 holding the value for the extension method.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.MethInfo.ArbitraryValRef">
<summary>
 Try to get an arbitrary F# ValRef associated with the member. This is to determine if the member is virtual, amongst other things.
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.MethInfo.MethInfosUseIdenticalDefinitions(Microsoft.FSharp.Compiler.Infos.MethInfo,Microsoft.FSharp.Compiler.Infos.MethInfo)">
<summary>
 Tests whether two method infos have the same underlying definition.
 Used to merge operator overloads collected from left and right of an operator constraint.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.MethInfo.Instantiate(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Compiler.Tast.Typar,Microsoft.FSharp.Compiler.Tast.TType}})">
<summary>
 Apply a type instantiation to a method info, i.e. apply the instantiation to the enclosing type. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.MethInfo.GetSlotSig(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Get the signature of an abstract method slot.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.MethInfo.GetParamTypes(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType})">
<summary>
 Get the parameter types of a method info
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.MethInfo.GetParamDatas(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType})">
<summary>
 Get the ParamData objects for the parameters of a MethInfo
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.MethInfo.GetParamAttribs(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Get the parameter attributes of a method info, which get combined with the parameter names and types
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.MethInfo.GetObjArgTypes(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType})">
<summary>
 Get the (zero or one) &apos;self&apos;/&apos;this&apos;/&apos;object&apos; arguments associated with a method.
 An instance method returns one object argument.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.MethInfo.GetFormalTyparsOfDeclaringType(Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Select all the type parameters of the declaring type of a method. 

 For extension methods, no type parameters are returned, because all the 
 type parameters are part of the apparent type, rather the 
 declaring type, even for extension methods extending generic types.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.MethInfo.GetFSharpReturnTy(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType})">
<summary>
 Get the return type of a method info, where &apos;void&apos; is returned as &apos;unit&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.MethInfo.GetCompiledReturnTy(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType})">
<summary>
 Get the return type of a method info, where &apos;void&apos; is returned as &apos;None&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.MethInfo.CreateILMeth(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Compiler.AbstractIL.IL.ILMethodDef)">
<summary>
 Build IL method infos.  
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.MethInfo.CreateILExtensionMeth(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Compiler.Tast.EntityRef,Microsoft.FSharp.Core.FSharpOption{System.UInt64},Microsoft.FSharp.Compiler.AbstractIL.IL.ILMethodDef)">
<summary>
 Build IL method infos for a C#-style extension method
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.MethInfo.ComputeHashCode">
<summary>
 Calculates a hash code of method info. Note: this is a very imperfect implementation,
 but it works decently for comparing methods in the language service...
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.MethInfo.AdjustUserTypeInstForFSharpStyleIndexedExtensionMembers(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType})">
<summary>
 Add the actual type instantiation of the apparent type of an F# extension method.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.MethInfo">
<summary>
 Describes an F# use of a method
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.ILMethInfo.ILMethInfo">
<summary>
 ILMethInfo(g, ilApparentType, ilDeclaringTyconRefOpt, ilMethodDef, ilGenericMethodTyArgs)
	
 Describes an F# use of an IL method. 

 If ilDeclaringTyconRefOpt is &apos;Some&apos; then this is an F# use of an C#-style extension method.
 If ilDeclaringTyconRefOpt is &apos;None&apos; then ilApparentType is an IL type definition.
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.RawMetadata">
<summary>
 Get the Abstract IL metadata associated with the method.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.ParamMetadata">
<summary>
 Get the Abstract IL metadata corresponding to the parameters of the method. 
 If this is an C#-style extension method then drop the object argument.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.NumParams">
<summary>
 Get the number of parameters of the method
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.MetadataScope">
<summary>
 Get the Abstract IL scope information associated with interpreting the Abstract IL metadata that backs this method.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.IsVirtual">
<summary>
 Indicates if the IL method is marked virtual.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.IsStatic">
<summary>
 Does it appear to the user as a static method?
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.IsProtectedAccessibility">
<summary>
 Indicates if the method has protected accessibility,
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.IsNewSlot">
<summary>
 Does it have the .NET IL &apos;newslot&apos; flag set, and is also a virtual?
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.IsInstance">
<summary>
 Does it appear to the user as an instance method?
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.IsILExtensionMethod">
<summary>
 Indicates if the method is an extension method
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.IsFinal">
<summary>
 Indicates if the IL method is marked final.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.IsConstructor">
<summary>
 Indicates if the method is a constructor
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.IsClassConstructor">
<summary>
 Indicates if the method is a class initializer.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.IsAbstract">
<summary>
 Indicates if the IL method is marked abstract.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.ILName">
<summary>
 Get the IL name of the method
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.ILMethodRef">
<summary>
 Get a reference to the method (dropping all generic instantiations), as an Abstract IL ILMethodRef.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.FormalMethodTypars">
<summary>
 Get the formal method type parameters associated with a method.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.DeclaringTypeInst">
<summary>
 Get the instantiation of the declaring type of the method. 
 If this is an C#-style extension method then this is empty because extension members
 are never in generic classes.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.DeclaringTyconRefOption">
<summary>
 Get the declaring type associated with an extension member, if any.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.DeclaringTyconRef">
<summary>
 Get the declaring type of the method. If this is an C#-style extension method then this is the IL type
 holding the static member that is the extension method.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Infos.ILMethInfo.ApparentEnclosingType">
<summary>
 Get the apparent declaring type of the method as an F# type. 
 If this is an C#-style extension method then this is the type which the method 
 appears to extend. This may be a variable type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ILMethInfo.IsDllImport(Microsoft.FSharp.Compiler.Env.TcGlobals)">
<summary>
 Indicates if the method is marked as a DllImport (a PInvoke). This is done by looking at the IL custom attributes on 
 the method.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ILMethInfo.GetRawArgTypes(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType})">
<summary>
 Get all the argument types of the IL method. Include the object argument even if this is 
 an C#-style extension method.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ILMethInfo.GetParamTypes(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType})">
<summary>
 Get the argument types of the the IL method. If this is an C#-style extension method 
 then drop the object argument.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ILMethInfo.GetParamNamesAndTypes(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType})">
<summary>
 Get info about the arguments of the IL method. If this is an C#-style extension method then 
 drop the object argument.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ILMethInfo.GetObjArgTypes(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType})">
<summary>
 Get the (zero or one) &apos;self&apos;/&apos;this&apos;/&apos;object&apos; arguments associated with an IL method. 
 An instance extension method returns one object argument.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ILMethInfo.GetFSharpReturnTy(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType})">
<summary>
 Get the F# view of the return type of the method, where &apos;void&apos; is &apos;unit&apos;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ILMethInfo.GetCompiledReturnTy(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType})">
<summary>
 Get the compiled return type of the method, where &apos;void&apos; is None.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.ILMethInfo">
<summary>
 Describes an F# use of an IL method.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.ILTypeInfo.ILTypeInfo">
<summary>
 ILTypeInfo (tyconRef, ilTypeRef, typeArgs, ilTypeDef).
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.ILTypeInfo">
<summary>
 Describes an F# use of an IL type, including the type instantiation associated with the type at a particular usage point.

 This is really just 1:1 with the subset ot TType which result from building types using IL type definitions.
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.ParamData">
<summary>
 Full information about a parameter returned for use by the type checker and language service.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.ParamNameAndType">
<summary>
 Partial information about a parameter returned for use by the Language Service
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.OptionalArgInfo.CallerSide">
<summary>
 The argument is optional, and is a caller-side .NET optional or default arg 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.OptionalArgInfo.CalleeSide">
<summary>
 The argument is optional, and is an F# callee-side optional arg 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.OptionalArgInfo.NotOptional">
<summary>
 The argument is not optional
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.OptionalArgInfo.FromILParameter(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.AbstractIL.IL.ILScopeRef,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType},Microsoft.FSharp.Compiler.AbstractIL.IL.ILParameter)">
<summary>
 Compute the OptionalArgInfo for an IL parameter

 This includes the Visual Basic rules for IDispatchConstant and IUnknownConstant and optinal arguments.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.OptionalArgInfo">
<summary>
 Represents information about a parameter indicating if it is optional.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.OptionalArgCallerSideValue">
<summary>
 The caller-side value for the optional arg, is any 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.ExtensionMethodPriority">
<summary>
 Describes the sequence order of the introduction of an extension method. Extension methods that are introduced
 later through &apos;open&apos; get priority in overload resolution.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.AllowMultiIntfInstantiations">
<summary>
 Indicates whether we should visit multiple instantiations of the same generic interface or not
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.PropTypOfEventInfo(Microsoft.FSharp.Compiler.Infos.InfoReader,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.AccessorDomain,Microsoft.FSharp.Compiler.Infos.EventInfo)">
<summary>
 Get the type of the event when looked at as if it is a property 
 Used when displaying the property in Intellisense 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ArgsTypOfEventInfo(Microsoft.FSharp.Compiler.Infos.InfoReader,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.AccessorDomain,Microsoft.FSharp.Compiler.Infos.EventInfo)">
<summary>
 Get the (perhaps tupled) argument type accepted by an event 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.IsStandardEventInfo(Microsoft.FSharp.Compiler.Infos.InfoReader,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.AccessorDomain,Microsoft.FSharp.Compiler.Infos.EventInfo)">
<summary>
 Indicates if an event info is associated with a delegate type that is a &quot;standard&quot; .NET delegate type
 with a sender parameter.
 In the F# design, we take advantage of the following idiom to simplify away the bogus &quot;object&quot; parameter of the 
 of the &quot;Add&quot; methods associated with events.  If you want to access it you
 can use AddHandler instead.
 The .NET Framework guidelines indicate that the delegate type used for
 an event should take two parameters, an &quot;object source&quot; parameter
 indicating the source of the event, and an &quot;e&quot; parameter that
 encapsulates any additional information about the event. The type of
 the &quot;e&quot; parameter should derive from the EventArgs class. For events
 that do not use any additional information, the .NET Framework has
 already defined an appropriate delegate type: EventHandler.
 (from http://msdn.microsoft.com/library/default.asp?url=/library/en-us/csref/html/vcwlkEventsTutorial.asp) 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.TryDestStandardDelegateTyp(Microsoft.FSharp.Compiler.Infos.InfoReader,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.AccessorDomain,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Try and interpret a delegate type as a &quot;standard&quot; .NET delegate type associated with an event, with a &quot;sender&quot; parameter.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.GetSigOfFunctionForDelegate(Microsoft.FSharp.Compiler.Infos.InfoReader,Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.AccessorDomain)">
<summary>
 Given a delegate type work out the minfo, argument types, return type 
 and F# function type by looking at the Invoke signature of the delegate. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.TryFindPropInfo(Microsoft.FSharp.Compiler.Infos.InfoReader,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.AccessorDomain,System.String,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Try to find a particular named property on a type. Only used to ensure that local &apos;let&apos; definitions and property names
 are distinct, a somewhat adhoc check in tc.fs.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.TryFindIntrinsicMethInfo(Microsoft.FSharp.Compiler.Infos.InfoReader,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.AccessorDomain,System.String,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Try to detect the existence of a method on a type.
 Used for 
     -- getting the GetEnumerator, get_Current, MoveNext methods for enumerable types 
     -- getting the Dispose method when resolving the &apos;use&apos; construct 
     -- getting the various methods used to desugar the computation expression syntax 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.TryFindIntrinsicNamedItemOfType(Microsoft.FSharp.Compiler.Infos.InfoReader,System.String,Microsoft.FSharp.Compiler.Infos.AccessorDomain,Microsoft.FSharp.Compiler.Infos.FindMemberFlag,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Perform type-directed name resolution of a particular named member in an F# type
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.FilterOverridesOfMethInfos(Microsoft.FSharp.Compiler.Infos.FindMemberFlag,Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Infos.MethInfo}})">
<summary>
      (a) not virtual
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.emptyIndexedList``1">
<summary>
 Add all the items to the IndexedList if better items are not already present. This is used to hide methods
 in super classes and/or hide overrides of methods in subclasses.

 Assume no items in &apos;items&apos; are equivalent according to &apos;equiv&apos;. This is valid because each step in a
 .NET class hierarchy introduces a consistent set of methods, none of which hide each other within the 
 given set. This is an important optimization because it means we don&apos;t have to List.filter for equivalence between the 
 large overload sets introduced by methods like System.WriteLine.
 Assume items can be given names by &apos;nmf&apos;, where two items with different names are
 not equivalent.
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.GetIntrinsicConstructorInfosOfType(Microsoft.FSharp.Compiler.Infos.InfoReader,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Get the constructors of any F# type
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ConstructorInfosOfILType(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Get the constructors of an IL type
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.GetImmediateIntrinsicPropInfosOfType(Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Compiler.Infos.AccessorDomain,Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Query the immediate properties of an F# type, not taking into account inherited properties. The optFilter
 parameter is an optional name to restrict the set of properties returned.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.GetImmediateIntrinsicMethInfosOfType(Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Compiler.Infos.AccessorDomain,Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Query the immediate methods of an F# type, not taking into account inherited methods. The optFilter
 parameter is an optional name to restrict the set of properties returned.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.TrySelectMemberVal``1(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Core.FSharpOption{System.UInt64},``0,Microsoft.FSharp.Compiler.Tast.ValRef)">
<summary>
 Try to select an F# value when querying members, and if so return a MethInfo that wraps the F# value.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.checkFilter(Microsoft.FSharp.Core.FSharpOption{System.String},System.String)">
<summary>
 Check whether a name matches an optional filter
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.SelectImmediateMemberVals``1(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Tast.ValMemberInfo,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Tast.ValRef,Microsoft.FSharp.Core.FSharpOption{``0}}},Microsoft.FSharp.Compiler.Tast.EntityRef)">
<summary>
 Use the given function to select some of the member values from the members of an F# type
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.MakeMethInfoCall(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.MethInfo,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Expr})">
<summary>
 Make a call to a method info. Used by the optimizer and code generator to build 
 calls to the type-directed solutions to member constraints.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.BuildFSharpMethodCall(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Compiler.Tast.ValRef,Microsoft.FSharp.Compiler.Tast.ValUseFlag,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Expr})">
<summary>
 Build a call to an F# method.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.BuildFSharpMethodApp(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.ValRef,Microsoft.FSharp.Compiler.Tast.Expr,Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Expr})">
<summary>
 Build a call to an F# method.

 Consume the arguments in chunks and build applications.  This copes with various F# calling signatures
 all of which ultimately become &apos;methods&apos;.

 QUERY: this looks overly complex considering that we are doing a fundamentally simple 
 thing here. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.BuildObjCtorCall(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Build a call to the System.Object constructor taking no arguments,
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.BuildILMethInfoCall(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,System.Boolean,Microsoft.FSharp.Compiler.Infos.ILMethInfo,Microsoft.FSharp.Compiler.Tast.ValUseFlag,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType},System.Boolean,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Expr})">
<summary>
 Build an expression node that is a call to a .NET method. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.PropInfosEquivByNameAndSig(Microsoft.FSharp.Compiler.Tastops.Erasure,Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.PropInfo,Microsoft.FSharp.Compiler.Infos.PropInfo)">
<summary>
 Used to hide/filter members from super classes based on signature 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.MethInfosEquivByNameAndSig(Microsoft.FSharp.Compiler.Tastops.Erasure,System.Boolean,Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.MethInfo,Microsoft.FSharp.Compiler.Infos.MethInfo)">
<summary>
 Used to hide/filter members from super classes based on signature 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.PropInfosEquivByNameAndPartialSig(Microsoft.FSharp.Compiler.Tastops.Erasure,Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.PropInfo,Microsoft.FSharp.Compiler.Infos.PropInfo)">
<summary>
 Used to hide/filter members from super classes based on signature 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.MethInfosEquivByNameAndPartialSig(Microsoft.FSharp.Compiler.Tastops.Erasure,System.Boolean,Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.MethInfo,Microsoft.FSharp.Compiler.Infos.MethInfo)">
<summary>
 Used to hide/filter members from super classes based on signature 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.CompiledSigOfMeth(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.MethInfo)">
<summary>
 Get the information about the compiled form of a method signature. Used when analyzing implementation
 relations between members and abstract slots.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.FindDelegateTypeOfPropertyEvent(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,System.String,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Find the delegate type that an F# event property implements by looking through the type hierarchy of the type of the property
 for the first instantiation of IDelegateEvent.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.nonStandardEventError(System.String,Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Create an error object to raise should an event not have the shape expected by the .NET idiom described further below 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.tyConformsToIDelegateEvent(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Properties compatible with type IDelegateEvent and atributed with CLIEvent are special: we generate metadata and add/remove methods 
 to make them into a .NET event, and mangle the name of a property.  
 We don&apos;t handle static, indexer or abstract properties correctly. 
 Note the name mangling doesn&apos;t affect the name of the get/set methods for the property 
 and so doesn&apos;t affect how we compile F# accesses to the property. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ArbitraryMethodInfoOfPropertyInfo(Microsoft.FSharp.Compiler.Tainted{Microsoft.FSharp.Compiler.ExtensionTyping.ProvidedPropertyInfo},Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Try to get an arbitrary ProvidedMethodInfo associated with a property.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.GetAndSanityCheckProviderMethod``1(Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tainted{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Compiler.ExtensionTyping.ProvidedMethodInfo},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.String,System.String},System.Tuple{System.Int32,System.String}})">
<summary>
 Compute the ILFieldInit for the given provided constant value for a provided enum type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.OptionalArgInfoOfProvidedParameter(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tainted{Microsoft.FSharp.Compiler.ExtensionTyping.ProvidedParameterInfo})">
<summary>
 Compute the OptionalArgInfo for a provided parameter. 

 This is the same logic as OptionalArgInfoOfILParameter except we do not apply the 
 Visual Basic rules for IDispatchConstant and IUnknownConstant to optional 
 provided parameters.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ILFieldInit.FromProvidedObj.Static(Microsoft.FSharp.Compiler.Range.range,System.Object)">
<summary>
 Compute the ILFieldInit for the given provided constant value for a provided enum type.
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.GetInstantiationForMemberVal(Microsoft.FSharp.Compiler.Env.TcGlobals,System.Boolean,Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Compiler.Tast.ValRef,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType})">
<summary>
 Work out the instantiation relevant to interpret the backing metadata for a member.

 The &apos;minst&apos; is the instantiation of any generic method type parameters (this instantiation is
 not included in the MethInfo objects, but carreid separately).
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.CombineMethInsts(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Typar},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Typar},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType})">
<summary>
 Combine the type instantiation and generic method instantiation
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.GetArgInfosOfMember(System.Boolean,Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Tast.ValRef)">
<summary>
 Get the object type for a member value which is a C#-style extension method 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.GetObjTypeOfInstanceExtensionMethod(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Tast.ValRef)">
<summary>
 Get the object type for a member value which is an extension method  (C#-style or F#-style)
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.AnalyzeTypeOfMemberVal(System.Boolean,Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Compiler.Tast.ValRef)">
<summary>
 Split the type of an F# member value into 
    - the type parameters associated with method but matching those of the enclosing type
    - the type parameters associated with a generic method
    - the return type of the method
    - the actual type arguments of the enclosing type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.MakeSlotSig(System.String,Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Typar},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Typar},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.SlotParam}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Compiler.Tast.TType})">
<summary>
 Construct the data representing the signature of an abstract method slot
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.MakeSlotParam(Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Compiler.Tast.ArgReprInfo)">
<summary>
 Construct the data representing a parameter in the signature of an abstract method slot
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ReparentSlotSigToUseMethodTypars(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.ValRef,Microsoft.FSharp.Compiler.Tast.SlotSig)">
<summary>
 The slotsig returned by methInfo.GetSlotSig is in terms of the type parameters on the parent type of the overriding method.
 Reverse-map the slotsig so it is in terms of the type parameters for the overriding method 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.GetCompiledReturnTyOfProvidedMethodInfo(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tainted{Microsoft.FSharp.Compiler.ExtensionTyping.ProvidedMethodBase})">
<summary>
 Get the return type of a provided method, where &apos;void&apos; is returned as &apos;None&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ValRef.get_IsDefiniteFSharpOverrideMember(Microsoft.FSharp.Compiler.Tast.ValRef)">
<summary>
 Check if an F#-declared member value is an &apos;override&apos; or explicit member implementation
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ValRef.get_IsDispatchSlotMember(Microsoft.FSharp.Compiler.Tast.ValRef)">
<summary>
 Check if an F#-declared member value is a dispatch slot
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ValRef.get_IsVirtualMember(Microsoft.FSharp.Compiler.Tast.ValRef)">
<summary>
 Check if an F#-declared member value is a virtual method
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ValRef.IsFSharpEventProperty(Microsoft.FSharp.Compiler.Tast.ValRef,Microsoft.FSharp.Compiler.Env.TcGlobals)">
<summary>
 Indicates if an F#-declared function or member value is a CLIEvent property compiled as a .NET event
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.FixupNewTypars(Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Typar},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Typar},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Typar})">
<summary>
 The constraints for each typar copied from another typar can only be fixed up once 
 we have generated all the new constraints, e.g. f&lt;A :&gt; List&lt;B&gt;, B :&gt; List&lt;A&gt;&gt; ... 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.CopyTyparConstraints(Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Compiler.Tast.Typar,Microsoft.FSharp.Compiler.Tast.TType}},Microsoft.FSharp.Compiler.Tast.Typar)">
<summary>
 Copy constraints.  If the constraint comes from a type parameter associated
 with a type constructor then we are simply renaming type variables.  If it comes
 from a generic method in a generic class (e.g. typ.M&lt;_&gt;) then we may be both substituting the
 instantiation associated with &apos;typ&apos; as well as copying the type parameters associated with 
 M and instantiating their constraints

 Note: this now looks identical to constraint instantiation.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ImportReturnTypeFromMetaData(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.AbstractIL.IL.ILType,Microsoft.FSharp.Compiler.AbstractIL.IL.ILScopeRef,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType})">
<summary>
 Get the return type of an IL method, taking into account instantiations for type and method generic parameters, and
 translating &apos;void&apos; to &apos;None&apos;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ImportTypeFromMetadata(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.AbstractIL.IL.ILScopeRef,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType},Microsoft.FSharp.Compiler.AbstractIL.IL.ILType)">
<summary>
 Read an Abstract IL type from metadata and convert to an F# type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ExistsHeadTypeInEntireHierarchy(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Compiler.Tast.EntityRef)">
<summary>
 Check if a type exists somewhere in the hierarchy which has the given head type.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ExistsSameHeadTypeInHierarchy(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Check if a type exists somewhere in the hierarchy which has the same head type as the given type (note, the given type need not have a head type at all)
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.HasHeadType(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Tast.EntityRef,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Check if a type has a particular head type
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.HaveSameHeadType(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Check if two types have the same nominal head type
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.AllInterfacesOfType(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.AllowMultiIntfInstantiations,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Get all interfaces of a type, including the type itself if it is an interface
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.AllSuperTypesOfType(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.AllowMultiIntfInstantiations,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Get all super types of the type, including the type itself
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.SearchEntireHierarchyOfType(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Tast.TType,System.Boolean},Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Search for one element where a function returns a &apos;Some&apos; result, following interfaces
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ExistsInEntireHierarchyOfType(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Tast.TType,System.Boolean},Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.AllowMultiIntfInstantiations,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Search for one element satisfying a predicate, following interfaces
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.IterateEntireHierarchyOfType(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.AllowMultiIntfInstantiations,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Iterate, following interfaces
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.FoldEntireHierarchyOfType``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.AllowMultiIntfInstantiations,Microsoft.FSharp.Compiler.Tast.TType,``0)">
<summary>
 Fold, following interfaces
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.FoldPrimaryHierarchyOfType``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.AllowMultiIntfInstantiations,Microsoft.FSharp.Compiler.Tast.TType,``0)">
<summary>
 Fold, do not follow interfaces
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.FoldHierarchyOfTypeAux``1(System.Boolean,Microsoft.FSharp.Compiler.Infos.AllowMultiIntfInstantiations,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.TType,``0)">
<summary>
 Traverse the type hierarchy, e.g. f D (f C (f System.Object acc)). 
 Visit base types and interfaces first.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.GetImmediateInterfacesOfType(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Collect the set of interface types supported by an F# type
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.ImportType(Microsoft.FSharp.Compiler.AbstractIL.IL.ILScopeRef,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType},Microsoft.FSharp.Compiler.AbstractIL.IL.ILType)">
<summary>
 importInst gives the context for interpreting type variables 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.BadEventTransformation">
<summary>
 An exception type used to raise an error using the old error system.

 Error text: &quot;A definition to be compiled as a .NET event does not have the expected form. Only property members can be compiled as .NET events.&quot;
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.AttributeChecking.CheckProvidedAttributesForUnseen(Microsoft.FSharp.Compiler.Tainted{Microsoft.FSharp.Compiler.ExtensionTyping.IProvidedCustomAttributeProvider},Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Check provided attributes for existence of &apos;ObsoleteAttribute&apos;, to suppress the item in intellisense
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.AttributeChecking.CheckFSharpAttributesForUnseen``1(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Attrib},``0)">
<summary>
 Check F# attributes for existence of &apos;ObsoleteAttribute&apos;, to suppress the item in intellisense
 Also check F# attributes for CompilerMessageAttribute, which has an IsHidden argument that allows
 items to be suppressed from intellisense.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.AttributeChecking.CheckILAttributesForUnseen``1(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.AbstractIL.IL.ILAttributes,``0)">
<summary>
 Check IL attributes for existence of &apos;ObsoleteAttribute&apos;, to suppress the item in intellisense
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.AttributeChecking.CheckFSharpAttributes(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Attrib},Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Check F# attributes for &apos;ObsoleteAttribute&apos;, &apos;CompilerMessageAttribute&apos; and &apos;ExperimentalAttribute&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.AttributeChecking.CheckILAttributes(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.AbstractIL.IL.ILAttributes,Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Check IL attributes for &apos;ObsoleteAttribute&apos;
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.AttributeChecking.TryFindTyconRefStringAttribute(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Env.BuiltinAttribInfo,Microsoft.FSharp.Compiler.Tast.EntityRef)">
<summary>
 This is used to detect the &apos;DefaultMemberAttribute&apos; and &apos;ConditionalAttribute&apos; attributes (on type definitions)
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.AttributeChecking.TryFindMethInfoStringAttribute(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Env.BuiltinAttribInfo,Microsoft.FSharp.Compiler.Infos.MethInfo)">
<summary>
 This is just used for the &apos;ConditionalAttribute&apos; attribute
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.AttributeChecking">
<summary>
 Check custom attributes. This is particularly messy because custom attributes come in in three different
 formats.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.AccessibilityLogic.IsTypeAndMethInfoAccessible(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.AccessorDomain,Microsoft.FSharp.Compiler.Infos.AccessorDomain,Microsoft.FSharp.Compiler.Infos.MethInfo)">
<summary>
 Uses a separate accessibility domains for containing type and method itself
 This makes sense cases like
 type A() =
     type protected B() =
         member this.Public() = ()
         member protected this.Protected() = ()
 type C() =
     inherit A()
     let x = A.B()
     do x.Public()
 when calling x.SomeMethod() we need to use &apos;adTyp&apos; do verify that type of x is accessible from C 
 and &apos;ad&apos; to determine accessibility of SomeMethod.
 I.e when calling x.Public() and x.Protected() -in both cases first check should succeed and second - should fail in the latter one. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.AccessibilityLogic.isILTypeInfoAccessible(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.AccessorDomain,Microsoft.FSharp.Compiler.Tast.EntityRef)">
<summary>
 Determine if given IL based TyconRef is accessible. If TyconRef is nested then we&apos;ll walk though the list of enclosing types
 and test if all of them are accessible 
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Infos.AccessibilityLogic.isILTypeDefAccessible(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.AccessorDomain,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Compiler.Tast.EntityRef},Microsoft.FSharp.Compiler.AbstractIL.IL.ILTypeDef)">
<summary>
 Determine if tdef is accessible. If tdef.Access = ILTypeDefAccess.Nested then encTyconRefOpt s TyconRef of enclosing type
 and visibility of tdef is obtained using member access rules
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Infos.AccessibilityLogic">

</member>
<member name="T:Microsoft.FSharp.Compiler.Infos">
<summary>
 tinfos, minfos, finfos, pinfos - summaries of information for references
 to .NET and F# constructs.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Layout">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Lexer">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Lexfilter.TokenTup.StartPos">
<summary>
 Returns starting position of the token
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Lexfilter.TokenTup.EndPos">
<summary>
 Returns end position of the token
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Lexfilter.TokenTup.UseShiftedLocation(Microsoft.FSharp.Compiler.Parser.token,System.Int32,System.Int32)">
<summary>
 Returns a token &apos;tok&apos; with the same position as this token, except that 
 it is shifted by specified number of characters from the left and from the right
 Note: positive value means shift to the right in both cases
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Lexfilter.TokenTup.UseLocation(Microsoft.FSharp.Compiler.Parser.token)">
<summary>
 Returns a token &apos;tok&apos; with the same position as this token
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Lexfilter.TokenTup">
<summary>
 Used to save the state related to a token
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Lexfilter.LexbufState">
<summary>
 Used to save some aspects of the lexbuffer state
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Lexfilter.isTryBlockContinuator(Microsoft.FSharp.Compiler.Parser.token)">
<summary>
 Determine the token that may align with the &apos;try&apos; of a &apos;try/catch&apos; or &apos;try/finally&apos; without closing
 the construct
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Lexfilter.isIfBlockContinuator(Microsoft.FSharp.Compiler.Parser.token)">
<summary>
 Determine the tokens that may align with the &apos;if&apos; of an &apos;if/then/elif/else&apos; without closing
 the construct
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Lexfilter.warningStringOfPos(Internal.Utilities.Text.Lexing.Position)">
<summary>
 Used for warning strings, which should display columns as 1-based and display 
 the lines after taking &apos;# line&apos; directives into account (i.e. do not use
 p.OriginalLine)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Lexfilter">
<summary>
 LexFilter - process the token stream prior to parsing.
 Implements the offside rule and a copule of other lexical transformations.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Lexhelp.Keywords">

</member>
<member name="T:Microsoft.FSharp.Compiler.Lexhelp">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Lib.debug">
<summary>
 is this the developer-debug build? 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Lib.UnmanagedProcessExecutionOptions">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Lib.AsyncUtil.AsyncResultCell`1.AsyncResult">
<summary>
 Get the result and commit it
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Lib.AsyncUtil.AsyncResultCell`1.AsyncPrimitiveResult">
<summary>
 Get the reified result
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Lib.AsyncUtil.AsyncResultCell`1">
<summary>
 When using .NET 4.0 you can replace this type by Task&lt;&apos;T&gt;
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Lib.AsyncUtil.AsyncResult`1">
<summary>
 Represents the reified result of an asynchronous computation
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Lib.AsyncUtil">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Lib.Zset">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Lib.Zmap">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Lib.List">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Lib.FlatListSet">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Lib.ListSet">

</member>
<member name="M:Microsoft.FSharp.Compiler.Lib.ListAssoc.containsKey``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},``0,Microsoft.FSharp.Collections.FSharpList{System.Tuple{``0,``1}})">
<summary>
 Treat a list of key-value pairs as a lookup collection.
 This function returns true if two keys are the same according to the predicate
 function passed in.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Lib.ListAssoc.find``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},``0,Microsoft.FSharp.Collections.FSharpList{System.Tuple{``1,``2}})">
<summary>
 Treat a list of key-value pairs as a lookup collection.
 This function looks up a value based on a match from the supplied
 predicate function.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Lib.ListAssoc">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Lib.IntMap">

</member>
<member name="M:Microsoft.FSharp.Compiler.Lib.Check.StringArgumentNotNullOrEmpty(System.String,System.String)">
<summary>
 Throw System.ArgumentNullException() if string argument is null.
 Throw System.ArgumentOutOfRangeException() is string argument is empty.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Lib.Check.ArrayArgumentNotNullOrEmpty``1(``0[],System.String)">
<summary>
 Throw System.ArgumentNullException() if array argument is null.
 Throw System.ArgumentOutOfRangeException() is array argument is empty.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Lib.Check.ArgumentNotNull``1(``0,System.String)">
<summary>
 Throw System.ArgumentNullException() if argument is null.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Lib.Check.NotNone``1(System.String,Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Throw System.InvalidOperationException() if argument is None.
 If there is a value (e.g. Some(value)) then value is returned.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Lib.Check">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Lib.NameMapModule">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Lib.NameSetModule">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Lib.Pair">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Lib.Int64">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Lib.Int32">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Lib.Bool">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Lib.Filename">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Lib.Bits">

</member>
<member name="T:Microsoft.FSharp.Compiler.Lib">

</member>
<member name="F:Microsoft.FSharp.Compiler.Lowertop.LoweredSeqFirstPhaseResult.stateVars">
<summary>
 The state variables allocated for one portion of the sequence expression (i.e. the local let-bound variables which become state variables)
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Lowertop.LoweredSeqFirstPhaseResult.significantClose">
<summary>
 any actual work done in Close
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Lowertop.LoweredSeqFirstPhaseResult.labels">
<summary>
 The labels allocated for one portion of the sequence expression
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Lowertop.LoweredSeqFirstPhaseResult.phase2">
<summary>
 The code to run in the second phase, to rebuild the expressions, once all code labels and their mapping to program counters have been determined
 &apos;nextVar&apos; is the argument variable for the GenerateNext method that represents the byref argument that holds the &quot;goto&quot; destination for a tailcalling sequence expression
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Lowertop.LowerSeqExpr(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Tast.Expr)">
<summary>
 Analyze a TAST expression to detect the elaborated form of a sequence expression.
 Then compile it to a state machine represented as a TAST containing goto, return and label nodes. 
 The returned state machine will also contain references to state variables (from internal &apos;let&apos; bindings),
 a program counter (pc) that records the current state, and a current generated value (current).
 All these variables are then represented as fields in a hosting closure object along with any additional
 free variables of the sequence expression.

 The analysis is done in two phases. The first phase determines the state variables and state labels (as Abstract IL code labels).
 We then allocate an integer pc for each state label and proceed with the second phase, which builds two related state machine
 expressions: one for &apos;MoveNext&apos; and one for &apos;Dispose&apos;.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Lowertop.LowerImplFile(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Tast.TypedImplFile)">
<summary>
 An &quot;expr -&gt; expr&quot; pass that eta-expands under-applied values of 
 known arity to lambda expressions and beta-var-reduces to bind 
 any known arguments.  The results are later optimized by the peephole 
 optimizer in opt.fs
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Lowertop">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.MSBuildResolver.DecodeResolvedFrom(System.String)">
<summary>
 Decode the ResolvedFrom code from MSBuild.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.MSBuildResolver.DeriveTargetFrameworkDirectories(System.String,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit})">
<summary>
 Derive the target framework directories.        
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.MSBuildResolver.HighestInstalledNetFrameworkVersionMajorMinor">
<summary>
 Determine the default &quot;frameworkVersion&quot; (which is passed into MSBuild resolve).
 This code uses MSBuild to determine version of the highest installed framework.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.MSBuildResolver">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Nameres.PermitDirectReferenceToGeneratedType">
<summary>
 Indicates whether we permit a direct reference to a type generator. Only set when resolving the
 right-hand-side of a [&lt;Generate&gt;] declaration.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Nameres.TypeNameResolutionStaticArgsInfo.DefiniteEmpty">
<summary>
 Indicates definite knowledge of empty type arguments, i.e. the logical equivalent of name&lt; &gt;
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Nameres.TypeNameResolutionStaticArgsInfo.FromTyArgs(System.Int32)">
<summary>
 Deduce definite knowledge of type arguments
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Nameres.NameResolutionEnv">
<summary>
 The environment of information used to resolve names
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Nameres.ExtensionMember">
<summary>
 Information about an extension member held in the name resolution environment
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Nameres.Item.ArgName">
<summary>
 Represents the resolution of a source identifier to a named argument
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Nameres.Item.ImplicitOp">
<summary>
 Represents the resolution of a source identifier to an implicit use of an infix operator (+solution if such available)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Nameres.Item.CustomOperation">
<summary>
 CustomOperation(operationName, operationHelpText, operationImplementation).
 
 Used to indicate the availability or resolution of a custom query operation such as &apos;sortBy&apos; or &apos;where&apos; in computation expression syntax
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Nameres.NameResolver">
<summary>
 A NameResolver primarily holds an InfoReader
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Nameres">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.minimalStringsOfTwoTypes(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Generate text for comparing two types.

 If the output text is different without showing constraints and/or imperative type variable 
 annotations and/or fully qualifying paths then don&apos;t show them! 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.isGeneratedUnionCaseField(System.Int32,Microsoft.FSharp.Compiler.Tast.RecdField)">
<summary>
 Pass negative number as pos in case of single cased discriminated unions
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.stringOfParamData(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Infos.ParamData)">
<summary>
 Convert a ParamData to a string
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.stringOfMethInfo(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Infos.MethInfo)">
<summary>
 Convert a MethInfo to a string
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.formatMethInfoToBufferFreeStyle(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tastops.DisplayEnv,System.Text.StringBuilder,Microsoft.FSharp.Compiler.Infos.MethInfo)">
<summary>
 Convert a MethInfo to a string
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.outputQualifiedValOrMember(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,System.Text.StringBuilder,Microsoft.FSharp.Compiler.Tast.Val)">
<summary>
 Print members with a qualification showing the type they are contained in 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintData.dataExprL(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Tast.Expr)">
<summary>
 Nice printing of a subset of expressions, e.g. for refutations in pattern matching
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.NicePrint.PrintData">

</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.InferredSigPrinting.layoutInferredSigOfModuleExpr(System.Boolean,Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Infos.InfoReader,Microsoft.FSharp.Compiler.Infos.AccessorDomain,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceExprWithSig)">
<summary>
 Layout the inferred signature of a compilation unit
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.NicePrint.InferredSigPrinting">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.TastDefinitionPrinting.layoutProvidedTycon(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Infos.InfoReader,Microsoft.FSharp.Compiler.Infos.AccessorDomain,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Core.FSharpOption{System.String},Internal.Utilities.StructuredFormat.Layout,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Another re-implementation of type printing, this time based off provided info objects.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.TastDefinitionPrinting.breakTypeDefnEqn(Microsoft.FSharp.Compiler.Tast.TyconRepresentation)">
<summary>
 When to force a break? &quot;type tyname = &lt;HERE&gt; repn&quot;
 When repn is class or datatype constructors (not single one).
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.NicePrint.TastDefinitionPrinting">
<summary>
 Printing TAST objects
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.InfoMemberPrinting.layoutMethInfoFSharpStyle(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Infos.MethInfo)">
<summary>
 Format a method to a layotu (actually just containing a string) using &quot;free style&quot; (aka &quot;standalone&quot;). 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.InfoMemberPrinting.formatMethInfoToBufferFreeStyle(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tastops.DisplayEnv,System.Text.StringBuilder,Microsoft.FSharp.Compiler.Infos.MethInfo)">
<summary>
 Format a method to a buffer using &quot;standalone&quot; display style. 
 For example, these are the formats used when printing signatures of methods that have not been overriden,
 and the format used when showing the individual member in QuickInfo and DeclarationInfo.
 The formats differ between .NET/provided methods and F# methods. Surprisingly people don&apos;t really seem 
 to notice this, or they find it helpful. It feels that moving from this position should not be done lightly.
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.InfoMemberPrinting.formatMethInfoToBufferCSharpStyle(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tastops.DisplayEnv,System.Text.StringBuilder,Microsoft.FSharp.Compiler.Infos.MethInfo,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType})">
<summary>
 Format a method info using &quot;half C# style&quot;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.InfoMemberPrinting.formatMethInfoToBufferFSharpStyle(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tastops.DisplayEnv,System.Text.StringBuilder,Microsoft.FSharp.Compiler.Infos.MethInfo,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType})">
<summary>
 Format a method info using &quot;F# style&quot;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.InfoMemberPrinting.formatParamDataToBuffer(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,System.Text.StringBuilder,Microsoft.FSharp.Compiler.Infos.ParamData)">
<summary>
 Format the arguments of a method to a buffer. 

 This uses somewhat &quot;old fashioned&quot; printf-style buffer printing.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.NicePrint.InfoMemberPrinting">
<summary>
 Printing info objects
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.NicePrint.PrintTastMemberOrVals">
<summary>
 Printing TAST objects
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintTypes.layoutTyparDecls(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Internal.Utilities.StructuredFormat.Layout,System.Boolean,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Typar})">
<summary>
 Layout type parameters
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintTypes.layoutTopType(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Tastops.SimplifyTypes.TypeSimplificationInfo,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Compiler.Tast.ArgReprInfo}}},Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Compiler.Tast.Typar,Microsoft.FSharp.Compiler.Tast.TyparConstraint}})">
<summary>
 Layout a single type used as the type of a member or value 
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintTypes.layoutTypeWithInfo(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Tastops.SimplifyTypes.TypeSimplificationInfo,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Layout a single type, taking TypeSimplificationInfo into account 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintTypes.layoutTypesWithInfoAndPrec(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Tastops.SimplifyTypes.TypeSimplificationInfo,System.Int32,Internal.Utilities.StructuredFormat.Layout,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType})">
<summary>
 Layout a list of types, separated with the given separator, either &apos;*&apos; or &apos;,&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintTypes.layoutTypeWithInfoAndPrec(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Tastops.SimplifyTypes.TypeSimplificationInfo,System.Int32,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Layout a type, taking precedence into account to insert brackets where needed *)
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintTypes.layoutTypeAppWithInfoAndPrec(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Tastops.SimplifyTypes.TypeSimplificationInfo,Internal.Utilities.StructuredFormat.Layout,System.Int32,System.Boolean,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType})">
<summary>
 Layout type arguments, either NAME&lt;ty,...,ty&gt; or (ty,...,ty) NAME *)
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintTypes.layoutMeasure(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Tast.MeasureExpr)">
<summary>
 Layout a unit expression 
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintTypes.layoutConstraintWithInfo(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Tastops.SimplifyTypes.TypeSimplificationInfo,Microsoft.FSharp.Compiler.Tast.Typar,Microsoft.FSharp.Compiler.Tast.TyparConstraint)">
<summary>
 Layout constraints, taking TypeSimplificationInfo into account 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintTypes.layoutConstraintsWithInfo(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Tastops.SimplifyTypes.TypeSimplificationInfo,Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Compiler.Tast.Typar,Microsoft.FSharp.Compiler.Tast.TyparConstraint}})">
<summary>
 Layout type parameter constraints, taking TypeSimplificationInfo into account 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintTypes.layoutTyparRefWithInfo(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Tastops.SimplifyTypes.TypeSimplificationInfo,Microsoft.FSharp.Compiler.Tast.Typar)">
<summary>
 Layout a single type parameter declaration, taking TypeSimplificationInfo into account  
 There are several printing-cases for a typar:

  &apos;a              - is multiple  occurance.
  _               - singleton occurrence, an underscore prefered over &apos;b. (OCAML accepts but does not print)
  #Type           - inplace coercion constraint and singleton.
  (&apos;a :&gt; Type)    - inplace coercion constraint not singleton.
  (&apos;a.opM : S-&gt;T) - inplace operator constraint.

</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintTypes.layoutAttribs(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Tast.TyparKind,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Attrib},Internal.Utilities.StructuredFormat.Layout)">
<summary>
 Layout &apos;[&lt;attribs&gt;]&apos; above another block 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintTypes.layoutAttrib(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Tast.Attrib)">
<summary>
 Layout an attribute &apos;Type(arg1, ..., argN)&apos; 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintTypes.layoutAttribArgs(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.AttribExpr})">
<summary>
 Layout arguments of an attribute &apos;arg1, ..., argN&apos; 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintTypes.layoutAttribArg(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Tast.Expr)">
<summary>
 Layout a single attibute arg, following the cases of &apos;gen_attr_arg&apos; in ilxgen.fs
 This is the subset of expressions we display in the NicePrint pretty printer 
 See also dataExprL - there is overlap between these that should be removed 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintTypes.layoutMemberFlags(Microsoft.FSharp.Compiler.Ast.MemberFlags)">
<summary>
 Layout the flags of a member 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintTypes.layoutTyconRef(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Tast.EntityRef)">
<summary>
 Layout a reference to a type 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.NicePrint.PrintTypes">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintIL.layoutILMethodDef(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Collections.FSharpList{Internal.Utilities.StructuredFormat.Layout},System.String,Microsoft.FSharp.Compiler.AbstractIL.IL.ILMethodDef)">
<summary>
 Layout a method&apos;s signature using type-only-F#-style. No argument names are printed.
 
 In the case that we&apos;ve a constructor, we
 pull off the class name from the `path`; naturally, it&apos;s the
 most-deeply-nested element.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintIL.layoutILParameters(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Collections.FSharpList{Internal.Utilities.StructuredFormat.Layout},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.AbstractIL.IL.ILParameter},Microsoft.FSharp.Compiler.AbstractIL.IL.ILType)">
<summary>
 Layout a function pointer signature using type-only-F#-style. No argument names are printed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintIL.layoutILParameter(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Collections.FSharpList{Internal.Utilities.StructuredFormat.Layout},Microsoft.FSharp.Compiler.AbstractIL.IL.ILParameter)">
<summary>
 Layout a function pointer signature using type-only-F#-style. No argument names are printed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintIL.layoutILCallingSignature(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Collections.FSharpList{Internal.Utilities.StructuredFormat.Layout},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Compiler.AbstractIL.IL.ILCallingSignature)">
<summary>
 Layout a function pointer signature using type-only-F#-style. No argument names are printed.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintIL.adjustILMethodName(System.String)">
<summary>
 this fixes up a name just like adjustILName but also handles F#
 operators
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.NicePrint.PrintIL">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.NicePrint.PrintUtilities.adjustILName(System.String)">
<summary>
 fix up a name coming from IL metadata by quoting &quot;funny&quot; names (keywords, otherwise invalid identifiers)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.NicePrint.PrintUtilities">

</member>
<member name="T:Microsoft.FSharp.Compiler.NicePrint">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Opt.ModuleInfo">
<summary>
 Optimization information 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Opt.RemapLazyModulInfo(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Tastops.Remap)">
<summary>
 Rewrite the modul info using the export remapping 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Opt.p_LazyModuleInfo(System.Lazy{Microsoft.FSharp.Compiler.Opt.ModuleInfo},Microsoft.FSharp.Compiler.Pickle.WriterState)">
<summary>
 Saving and re-reading optimization information 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Opt.moduleInfoL(Microsoft.FSharp.Compiler.Env.TcGlobals,System.Lazy{Microsoft.FSharp.Compiler.Opt.ModuleInfo})">
<summary>
 Displaying optimization data
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Opt.OptimizeImplFile(Microsoft.FSharp.Compiler.Opt.OptimizationSettings,Microsoft.FSharp.Compiler.Tast.CcuThunk,Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Tast.ValRef,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Tast.ValUseFlag,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Range.range,System.Tuple{Microsoft.FSharp.Compiler.Tast.Expr,Microsoft.FSharp.Compiler.Tast.TType}}}}},Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Opt.IncrementalOptimizationEnv,System.Boolean,System.Boolean,Microsoft.FSharp.Compiler.Tast.TypedImplFile)">
<summary>
 The entry point. Boolean indicates &apos;incremental extension&apos; in FSI 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Opt.BindCcu(Microsoft.FSharp.Compiler.Tast.CcuThunk,System.Lazy{Microsoft.FSharp.Compiler.Opt.ModuleInfo},Microsoft.FSharp.Compiler.Opt.IncrementalOptimizationEnv,Microsoft.FSharp.Compiler.Env.TcGlobals)">
<summary>
 For building optimization environments incrementally 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Opt">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Outcome">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Parser.prodIdxToNonTerminal(System.Int32)">
<summary>
 This function maps production indexes returned in syntax errors to strings representing the non terminal that would be produced by that production
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Parser">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Patcompile.Pattern">
<summary>
 Represents the typechecked, elaborated form of a pattern, prior to pattern-match compilation.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Patcompile.ActionOnFailure">
<summary>
 What should the decision tree contain for any incomplete match? 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Patcompile.CompilePattern(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Range.range,System.Boolean,Microsoft.FSharp.Compiler.Patcompile.ActionOnFailure,Microsoft.FSharp.Compiler.Tast.Val,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Typar},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Patcompile.TypedMatchClause},Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Compile a pattern into a decision tree and a set of targets.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Patcompile">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Pickle.PickledDataWithReferences`1.FixupThunks">
<summary>
 The assumptions that need to be fixed up
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Pickle.PickledDataWithReferences`1.RawData">
<summary>
 The data that uses a collection of CcuThunks internally
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Pickle.PickledDataWithReferences`1.OptionalFixup(Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Compiler.Tast.CcuThunk}})">
<summary>
 Like Fixup but loader may return None, in which case there is no fixup.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Pickle">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.PostTypecheckSemanticChecks">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.PrettyNaming.TryChopPropertyName(System.String)">
<summary>
 Try to chop &quot;get_&quot; or &quot;set_&quot; from a string
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.PrettyNaming.IsLongIdentifierPartCharacter(System.Char)">
<summary>
 Is this character a part of a long identifier 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.PrettyNaming.IsIdentifierPartCharacter(System.Char)">
<summary>
 The characters that are allowed to be in an identifier.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.PrettyNaming.IsIdentifierFirstCharacter(System.Char)">
<summary>
 The characters that are allowed to be the first character of an identifier.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.PrettyNaming.parenGet">
<summary>
 Anything to do with special names of identifiers and other lexical rules 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.PrettyNaming">
<summary>
 Anything to do with special names of identifiers and other lexical rules 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.QuotationPickler">
<summary>
 Code to pickle out quotations in the quotation binary format.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.QuotationTranslator">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Range.range.IsSynthetic">
<summary>
 Synthetic marks ranges which are produced by intermediate compilation phases. This
 bit signifies that the range covers something that should not be visible to language
 service operations like dot-completion.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Range.pos.EncodingSize">
<summary>
 The maximum number of bits needed to store an encoded position 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Range.rangeOrder">
<summary>
 not a total order, but enough to sort on ranges 
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Range.mkRange(System.String,Microsoft.FSharp.Compiler.Range.pos,Microsoft.FSharp.Compiler.Range.pos)">
<summary>
 This view hides the use of file indexes and just uses filenames 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Range.mkFileIndexRange(System.Int32,Microsoft.FSharp.Compiler.Range.pos,Microsoft.FSharp.Compiler.Range.pos)">
<summary>
 This view of range marks uses file indexes explicitly 
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Range.mkPos(System.Int32,System.Int32)">
<summary>
 Create a position for the given line and column
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Range.Range">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Range.Pos">

</member>
<member name="T:Microsoft.FSharp.Compiler.Range">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.SR">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.SourceCodeServices.Microsoft.FSharp.Compiler.SourceCodeServices.CheckOptions.LoadTime">
<summary>
 Timestamp of project/script load
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.SourceCodeServices.Microsoft.FSharp.Compiler.SourceCodeServices.CheckOptions.UseScriptResolutionRules">
<summary>
 When true, use the reference resolution rules for scripts rather than the rules for compiler.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.SourceCodeServices.Microsoft.FSharp.Compiler.SourceCodeServices.CheckOptions.IsIncompleteTypeCheckEnvironment">
<summary>
 When true, the typechecking environment is known a priori to be incomplete. 
 This can happen, for example, when a .fs file is opened outside of a project.
 It may be appropriate, then, to not show error messages related to type checking
 since they will just be noise.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.CheckOptions">
<summary>
 A set of key information for the language service&apos;s internal caches of project/script build information for a particular source file
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.DataTipElement.DataTipElementCompositionError">
<summary>
 An error occurred formatting this element
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.DataTipElement.DataTipElementGroup">
<summary>
 For example, a method overload group.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.DataTipElement.DataTipElement">
<summary>
 A single type, method, etc with comment.
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.DataTipElement">
<summary>
 A single data tip display element
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.DataTipText.DataTipText">
<summary>
 A list of data tip elements to display.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.DataTipText">
<summary>
 Information for building a data tip box.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.DeclarationItem">
<summary>
 Represents an item to be displayed in the navigation bar
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.DependencyChangeCode">
<summary>
 Identical to _VSFILECHANGEFLAGS in vsshell.idl
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.FindDeclResult.DeclFound">
<summary>
 found declaration; return (position-in-file, name-of-file)
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.FindDeclResult.DeclNotFound">
<summary>
 declaration not found + reason
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.SourceCodeServices.InteractiveChecker.GlobalForegroundTypeCheckCountStatistic">
<summary>
 Report a statistic for testability
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.SourceCodeServices.InteractiveChecker.GlobalForegroundParseCountStatistic">
<summary>
 Report a statistic for testability
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.InteractiveChecker.WaitForBackgroundCompile">
<summary>
 Block until the background compile finishes.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.InteractiveChecker.UntypedParseForSlot(System.Int32,Microsoft.FSharp.Compiler.SourceCodeServices.CheckOptions)">
<summary>
 For QuickSearch index - not used by VS2008/VS2010/VS11
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.InteractiveChecker.UntypedParse(System.String,System.String,Microsoft.FSharp.Compiler.SourceCodeServices.CheckOptions)">
<summary>
 Parse a source code file, returning a handle that can be used for obtaining navigation bar information
 To get the full information, call &apos;TypeCheckSource&apos; method on the result
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.InteractiveChecker.TypeCheckSource(Microsoft.FSharp.Compiler.SourceCodeServices.UntypedParseInfo,System.String,System.Int32,System.String,Microsoft.FSharp.Compiler.SourceCodeServices.CheckOptions,Microsoft.FSharp.Compiler.SourceCodeServices.IsResultObsolete,System.Object)">
<summary>
 Typecheck a source code file, returning a handle to the results of the parse including
 the reconstructed types in the file.

 Return None if the background builder is not yet done prepring the type check results for the antecedent to the 
 file.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.InteractiveChecker.TryGetRecentTypeCheckResultsForFile(System.String,Microsoft.FSharp.Compiler.SourceCodeServices.CheckOptions)">
<summary>
 Try to get recent type check results for a file. This may arbitrarily refuse to return any
 results if the InteractiveChecker would like a chance to recheck the file, in which case
 UntypedParse and TypeCheckSource should be called. If the source of the file
 has changed the results returned by this function may be out of date, though may
 still be usable for generating intellsense menus and information.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.InteractiveChecker.StopBackgroundCompile">
<summary>
 Stop the background compile.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.InteractiveChecker.StartBackgroundCompile(Microsoft.FSharp.Compiler.SourceCodeServices.CheckOptions)">
<summary>
 Begin background parsing the given project.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.InteractiveChecker.NotifyProjectCleaned(Microsoft.FSharp.Compiler.SourceCodeServices.CheckOptions)">
<summary>
 This function is called when a project has been cleaned/rebuilt, and thus any live type providers should be refreshed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.InteractiveChecker.MatchBraces(System.String,System.String,Microsoft.FSharp.Compiler.SourceCodeServices.CheckOptions)">
<summary>
 Parse a source code file, returning information about brace matching in the file
 Return an enumeration of the matching parethetical tokens in the file
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.InteractiveChecker.InvalidateConfiguration(Microsoft.FSharp.Compiler.SourceCodeServices.CheckOptions)">
<summary>
 This function is called when the configuration is known to have changed for reasons not encoded in the CheckOptions.
 For example, dependent references may have been deleted or created.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.InteractiveChecker.InvalidateAll">
<summary>
 This function is called when the entire environment is known to have changed for reasons not encoded in the CheckOptions of any project/compilation.
 For example, the type provider approvals file may have changed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.InteractiveChecker.GetSlotsCount(Microsoft.FSharp.Compiler.SourceCodeServices.CheckOptions)">
<summary>
 For QuickSearch index - not used by VS2008/VS2010/VS11
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.InteractiveChecker.GetCheckOptionsFromScriptRoot(System.String,System.String,System.DateTime,System.String[])">
<summary>
 For a given script file, get the CheckOptions implied by the #load closure. Optional &apos;otherFlags&apos;
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.InteractiveChecker.GetCheckOptionsFromScriptRoot(System.String,System.String,System.DateTime)">
<summary>
 For a given script file, get the CheckOptions implied by the #load closure
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.InteractiveChecker.Create(Microsoft.FSharp.Compiler.SourceCodeServices.NotifyFileTypeCheckStateIsDirty)">
<summary>
 Create an instance of an InteractiveChecker.  Currently resources are not reclaimed.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.InteractiveChecker.ClearLanguageServiceRootCachesAndCollectAndFinalizeAllTransients">
<summary>
 Flush all caches and garbage collect
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.IsResultObsolete">
<summary>
 Callback that indicates whether a requested result has become obsolete.    
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.LexState">
<summary>
 Represents encoded information for the end-of-line continutation of lexing
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.LineTokenizer.ScanToken(System.Int64)">
<summary>
 Scan one token from the line
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.LineTokenizer">
<summary>
 Object to tokenize a line of F# source code, starting with the given lexState.  The lexState should be 0 for
 the first line of text. Returns an array of ranges of the text and two enumerations categorizing the
 tokens and characters covered by that range, i.e. TokenColorKind and TokenCharKind.  The enumerations
 are somewhat adhoc but useful enough to give good colorization options to the user in an IDE.

 A new lexState is also returned.  An IDE-plugin should in general cache the lexState 
 values for each line of the edited code.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.SourceCodeServices.Microsoft.FSharp.Compiler.SourceCodeServices.Method.IsStaticArguments">
<summary>
 Indicates that this not really a method, but actually a static arguments list, like TP&lt;42,&quot;foo&quot;&gt; ?
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.NavigationItems">
<summary>
 Represents result of &apos;GetNavigationItems&apos; operation - this contains
 all the members and currently selected indices. First level correspond to
 types &amp; modules and second level are methods etc.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.NotifyFileTypeCheckStateIsDirty">
<summary>
 This file has become eligible to be re-typechecked.
 This notifies the language service that it needs to set the dirty flag on files whose typecheck antecedents have changed.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.Position">
<summary>
 A line/column pair
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.Range">
<summary>
 A start-position/end-position pair
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.SourceTokenizer">
<summary>
 Tokenizer for a source file. Holds some expensive-to-compute resources at the scope of the file.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.SourceCodeServices.Microsoft.FSharp.Compiler.SourceCodeServices.TokenInformation.FullMatchedLength">
<summary>
 The full length consumed by this match, including delayed tokens (which can be ignored in naive lexers)
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.SourceCodeServices.Microsoft.FSharp.Compiler.SourceCodeServices.TokenInformation.TokenName">
<summary>
 Provides additional information about the token
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.SourceCodeServices.Microsoft.FSharp.Compiler.SourceCodeServices.TokenInformation.Tag">
<summary>
 The tag is an integer identifier for the token
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.SourceCodeServices.Microsoft.FSharp.Compiler.SourceCodeServices.TokenInformation.TriggerClass">
<summary>
 Actions taken when the token is typed
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.SourceCodeServices.Microsoft.FSharp.Compiler.SourceCodeServices.TokenInformation.RightColumn">
<summary>
 Right column of the token.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.SourceCodeServices.Microsoft.FSharp.Compiler.SourceCodeServices.TokenInformation.LeftColumn">
<summary>
 Left column of the token.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.TokenInformation">
<summary>
 Information about a particular token from the tokenizer
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.TopLevelDeclaration">
<summary>
 Represents top-level declarations (that should be in the type drop-down)
 with nested declarations (that can be shown in the member drop-down)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.TypeCheckAnswer">
<summary>
 The result of calling TypeCheckResult including the possibility of abort and background compiler not caught up.
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.SourceCodeServices.TypeCheckResults.Errors">
<summary>
 The errors returned by parsing a source file
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.TypeCheckResults.GetMethods(System.Tuple{System.Int32,System.Int32},System.String,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.String}})">
<summary>
 Resolve the names at the given location to a set of methods
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.TypeCheckResults.GetF1Keyword(System.Tuple{System.Int32,System.Int32},System.String,Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Resolve the names at the given location to give F1 keyword
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.TypeCheckResults.GetExtraColorizations">
<summary>
 Get any extra colorization info that is available after the typecheck
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.TypeCheckResults.GetDeclarations(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Compiler.SourceCodeServices.UntypedParseInfo},System.Tuple{System.Int32,System.Int32},System.String,System.Tuple{Microsoft.FSharp.Collections.FSharpList{System.String},System.String},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.Object,System.Tuple{System.Tuple{System.Int32,System.Int32},System.Tuple{System.Int32,System.Int32}}},System.Boolean})">
<summary>
 Intellisense autocompletions
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.TypeCheckResults.GetDeclarationLocation(System.Tuple{System.Int32,System.Int32},System.String,Microsoft.FSharp.Collections.FSharpList{System.String},System.Int32,System.Boolean)">
<summary>
 Resolve the names at the given location to the declaration location of the corresponding construct
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.TypeCheckResults.GetDataTipText(System.Tuple{System.Int32,System.Int32},System.String,Microsoft.FSharp.Collections.FSharpList{System.String},System.Int32)">
<summary>
 Resolve the names at the given location to give a data tip 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.TypeCheckResults">
<summary>
 A handle to the results of TypeCheckSource.  
 A live object of this type keeps the background corresponding background builder (and type providers) alive (through reference-counting)
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.UnresolvedReferencesSet">
<summary>
 wraps the set of unresolved references providing implementations of Equals\GetHashCode
 of this objects of this type can be used as parts of types with generated Equals\GetHashCode
 i.e. records or DUs
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.SourceCodeServices.UntypedParseInfo.FileName">
<summary>
 Name of the file for which this information were created
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.UntypedParseInfo.ValidateBreakpointLocation(System.Tuple{System.Int32,System.Int32})">
<summary>
 Return the inner-most range associated with a possible breakpoint location
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.UntypedParseInfo.GetNavigationItems">
<summary>
 Get declared items and the selected item at the specified location
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.UntypedParseInfo.FindNoteworthyParamInfoLocations(System.Int32,System.Int32)">
<summary>
 Notable parse info for ParameterInfo at a given location
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.UntypedParseInfo.DependencyFiles">
<summary>
 When these files change then the build is invalid
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.XmlComment">
<summary>
 Describe a comment as either a block of text or a file+signature reference into an intellidoc file.
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.AstTraversal.AstVisitorBase`1.VisitTypeAbbrev(Microsoft.FSharp.Compiler.Ast.SynType,Microsoft.FSharp.Compiler.Range.range)">
<summary>
 VisitTypeAbbrev(ty,m), defaults to ignoring this leaf of the AST
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.AstTraversal.AstVisitorBase`1.VisitModuleDecl(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Ast.SynModuleDecl,Microsoft.FSharp.Core.FSharpOption{`0}},Microsoft.FSharp.Compiler.Ast.SynModuleDecl)">
<summary>
 VisitModuleDecl allows overriding module declaration behavior
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.AstTraversal.AstVisitorBase`1.VisitMatchClause(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Ast.SynMatchClause,Microsoft.FSharp.Core.FSharpOption{`0}},Microsoft.FSharp.Compiler.Ast.SynMatchClause)">
<summary>
 VisitMatchClause allows overriding clause behavior (note: by default it would defaultTraverse expression)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.AstTraversal.AstVisitorBase`1.VisitImplicitInherit(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Ast.SynExpr,Microsoft.FSharp.Core.FSharpOption{`0}},Microsoft.FSharp.Compiler.Ast.SynType,Microsoft.FSharp.Compiler.Ast.SynExpr,Microsoft.FSharp.Compiler.Range.range)">
<summary>
 VisitImplicitInherit(defaultTraverse,ty,expr,m), defaults to just visiting expr
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.AstTraversal.AstVisitorBase`1.VisitExpr(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.SourceCodeServices.AstTraversal.TraverseStep},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Ast.SynExpr,Microsoft.FSharp.Core.FSharpOption{`0}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Ast.SynExpr,Microsoft.FSharp.Core.FSharpOption{`0}},Microsoft.FSharp.Compiler.Ast.SynExpr)">
<summary>
 VisitExpr(path, traverseSynExpr, defaultTraverse, expr)
 controls the behavior when a SynExpr is reached; it can just do 
          defaultTraverse(expr)      if you have no special logic for this node, and want the default processing to pick which sub-node to dive deeper into
 or can inject non-default behavior, which might incorporate:
          traverseSynExpr(subExpr)   to recurse deeper on some particular sub-expression based on your own logic
 path helps to track AST nodes that were passed during traversal
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.AstTraversal.AstVisitorBase`1.VisitBinding(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Ast.SynBinding,Microsoft.FSharp.Core.FSharpOption{`0}},Microsoft.FSharp.Compiler.Ast.SynBinding)">
<summary>
 VisitBinding allows overriding binding behavior (note: by default it would defaultTraverse expression)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.AstTraversal.TraverseStep">
<summary>
 used to track route during traversal AST
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.AstTraversal.Traverse``1(System.Int32,System.Int32,Microsoft.FSharp.Compiler.Ast.ParsedInput,Microsoft.FSharp.Compiler.SourceCodeServices.AstTraversal.AstVisitorBase{``0})">
<summary>
 traverse an implementation file walking all the way down to SynExpr or TypeAbbrev at a particular location

</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.AstTraversal">

</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.CompilerEnvironment.IsCheckerSupportedSubcategory(System.String)">
<summary>
 Return true if this is a subcategory of error or warning message that the language service can emit
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.CompilerEnvironment.GetCompilationDefinesForEditing(System.String,Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Return the compilation defines that should be used when editing the given file.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.SourceCodeServices.CompilerEnvironment.DefaultReferencesForOrphanSources">
<summary>
 These are the names of assemblies that should be referenced for .fs, .ml, .fsi, .mli files that
 are not asscociated with a project.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.CompilerEnvironment">
<summary>
 Information about the compilation environment    
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.DebuggerEnvironment.GetLanguageID">
<summary>
 Return the language ID, which is the expression evaluator id that the
 debugger will use.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.DebuggerEnvironment">
<summary>
 Information about the debugging environment
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.Flags">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.ItemDescriptionIcons">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.ItemDescriptionsImpl">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.NavigationImpl">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.NoteworthyParamInfoLocationsImpl">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.PrettyNaming">

</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.Reactor.Reactor.WaitForBackgroundCompile">
<summary>
 Block until the current build is complete.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.Reactor.Reactor.SyncOp(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Block while performing and operation. Restart the most recent build afterward.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.Reactor.Reactor.StopBuilding">
<summary>
 Halt the current build.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.Reactor.Reactor.StartBuildingRecent">
<summary>
 Start building the most recently building thing.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.Reactor.Reactor.StartBuilding(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Boolean})">
<summary>
 Start building. The build function will return true if there is more work to do.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.Reactor.Reactor.RunSyncOp``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Block while performing and operation. Restart the most recent build afterward.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.Reactor.Reactor.RunAsyncOp``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Start an operation and return an async handle to its result. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.Reactor.Reactor.AsyncOp(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Start an operation and return immediately. Restart the most recent build after the operation is complete.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.Reactor.Reactor">
<summary>
 Reactor operations
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.Reactor.Operation">
<summary>
 A synchronous or asynchronous operation to perform
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.Reactor.BuildStepper">
<summary>
 Does one unit of work and returns true if there is more work to do.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.Reactor.Reactor">
<summary>
 Get the reactor for FSharp.Compiler.dll
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.Reactor">
<summary>
 Reactor is intended to long-running, but interruptible operations to be interleaved
 with one-off synchronous or asynchronous operations. 

 It is used to guard the global compiler state while maintaining  responsiveness on 
 the UI thread.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.SourceFile.MustBeSingleFileProject(System.String)">
<summary>
 Whether or not this file should be a single-file project
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.SourceCodeServices.SourceFile.IsCompilable(System.String)">
<summary>
 Whether or not this file is compilable
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.SourceFile">
<summary>
 Information about F# source file names
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.SourceFileImpl">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.TestExpose">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.TestHooks">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.SourceCodeServices.UntypedParseInfoImpl">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tainted.GetHashCodeTainted``1(Microsoft.FSharp.Compiler.Tainted{``0})">
<summary>
 Compute the hash value for the tainted value
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tainted.EqTainted``1(Microsoft.FSharp.Compiler.Tainted{``0},Microsoft.FSharp.Compiler.Tainted{``0})">
<summary>
 Test whether the tainted value equals given value. Type providers are ignored (equal tainted values produced by different type providers are equal)
 Failure in call to equality operation will be blamed on type provider of first operand
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tainted.Eq``1(Microsoft.FSharp.Compiler.Tainted{``0},``0)">
<summary>
 Test whether the tainted value equals given value. 
 Failure in call to equality operation will be blamed on type provider of first operand
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tainted.|Null|_|``1(Microsoft.FSharp.Compiler.Tainted{``0})">
<summary>
 Test whether the tainted value is null
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tainted">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.CompiledTypeRepr.ILAsmOpen">
<summary>
 An AbstractIL type representation that may include type variables
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.CompiledTypeRepr.ILAsmNamed">
<summary>
 An AbstractIL type representation that is just the name of a type.

 CompiledTypeRepr.ILAsmNamed (ilTypeRef, ilBoxity, ilTypeOpt)
 
 The ilTypeOpt is present for non-generic types. It is an ILType corresponding to the first two elements of the case. This
 prevents reallocation of the ILType each time we need to generate it. For generic types, it is None.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.CompiledTypeRepr">
<summary>
 Specifies the compiled representations of type and exception definitions.  Basically
 just an ILTypeRef. Computed and cached by later phases.  Stored in 
 type and exception definitions. Not pickled. Store an optional ILType object for 
 non-generic types.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.FreeVars.FreeTyvars">
<summary>
 See FreeTyvars above.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.FreeVars.FreeUnionCases">
<summary>
 The summary of union constructors used in the expression. These may be
 marked &apos;internal&apos; or &apos;private&apos; and we have to check various conditions associated with that.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.FreeVars.FreeRecdFields">
<summary>
 The summary of fields used in the expression. These may be made private by a signature 
 or marked &apos;internal&apos; or &apos;private&apos; and we have to check various conditions associated with that. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.FreeVars.FreeLocalTyconReprs">
<summary>
 The summary of locally defined tycon representations used in the expression. These may be made private by a signature 
 or marked &apos;internal&apos; or &apos;private&apos; and we have to check various conditions associated with that. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.FreeVars.UsesUnboundRethrow">
<summary>
 Indicates if the expression contains a call to rethrow that is not bound under a (try-)with branch. 
 Rethrow may only occur in such locations. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.FreeVars.UsesMethodLocalConstructs">
<summary>
 Indicates if the expression contains a call to a protected member or a base call. 
 Calls to protected members and direct calls to super classes can&apos;t escape, also code can&apos;t be inlined 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.FreeVars.FreeLocals">
<summary>
 The summary of locally defined variables used in the expression. These may be hidden at let bindings etc. 
 or made private by a signature or marked &apos;internal&apos; or &apos;private&apos;, and we have to check various conditions associated with that. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.FreeVars">
<summary>
 Represents the set of free variables in an an expression
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.FreeVarsCache">
<summary>
 Represents an amortized computation of the free variables in an expression
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.FreeTyvars.FreeTypars">
<summary>
 The summary of type parameters used in the expression. These may not escape the enclosing generic construct 
 and we have to check various conditions associated with that. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.FreeTyvars.FreeTraitSolutions">
<summary>
 The summary of values used as trait solutions
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.FreeTyvars.FreeTycons">
<summary>
 The summary of locally defined type definitions used in the expression. These may be made private by a signature 
 and we have to check various conditions associated with that. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.FreeTyvars">
<summary>
 Represents a set of &apos;free&apos; type-related elements, including named types, trait solutions, union cases and
 record fields.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.FreeUnionCases">
<summary>
 Represents a set of &apos;free&apos; union cases. Used to collect the union cases referred to from an expression.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.FreeRecdFields">
<summary>
 Represents a set of &apos;free&apos; record field definitions. Used to collect the record field definitions referred to 
 from an expression.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.FreeTycons">
<summary>
 Represents a set of &apos;free&apos; named type definitions. Used to collect the named type definitions referred to 
 from atype or expression.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.FreeTypars">
<summary>
 Represents a set of free type parameters
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.FreeLocals">
<summary>
 Represents a set of free local values.
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TypedAssembly">
<summary>
 Represents a complete typechecked assembly, made up of multiple implementation files.

</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TypedImplFile">
<summary>
 This ModuleOrNamespace that represents the compilation of a module as a class. 
 The same set of tycons etc. are bound in the ModuleOrNamespace as in the ModuleOrNamespaceExpr
 This is the body of the module/namespace 
 Represents a complete typechecked implementation file, including its typechecked signature if any.

 TImplFile(qualifiedNameOfFile,pragmas,implementationExpressionWithSignature,hasExplicitEntryPoint,isScript)
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceBinding">
<summary>
 A named module-or-namespace-fragment definition 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceExpr.TMDefRec">
<summary>
 Indicates the module fragment is a &apos;rec&apos; definition of types, values and modules
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceExpr.TMDefDo">
<summary>
 Indicates the module fragment is an evaluation of expression for side-effects
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceExpr.TMDefLet">
<summary>
 Indicates the module fragment is a &apos;let&apos; definition 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceExpr.TMDefs">
<summary>
 Indicates the module fragment is made of several module fragments in succession 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceExpr.TMAbstract">
<summary>
 Indicates the module is a module with a signature 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceExpr">
<summary>
 The contents of a module-or-namespace-fragment definition 
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceExprWithSig.Type">
<summary>
 The ModuleOrNamespaceType is a binder. However it is not used in the ModuleOrNamespaceExpr: it is only referenced from the &apos;outside&apos; 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceExprWithSig">
<summary>
 A type for a module-or-namespace-fragment and the actual definition of the module-or-namespace-fragment
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.SlotParam">
<summary>
 Represents a parameter to an abstract method slot. 

 TSlotParam(nm,ty,inFlag,outFlag,optionalFlag,attribs)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.SlotSig">
<summary>
 Represents an abstract method slot, or delegate signature.

 TSlotSig(methodName,declaringType,declaringTypeParameters,methodTypeParameters,slotParameters,returnTy)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ObjExprMethod">
<summary>
 A representation of a method in an object expression. 

 TObjExprMethod(slotsig,attribs,methTyparsOfOverridingMethod,methodParams,methodBodyExpr,m)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.StaticOptimization">
<summary>
 Indicates the kind of an F# core library static optimization construct
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValUseFlag.VSlotDirectCall">
<summary>
 A call to a base method, e.g. &apos;base.OnPaint(args)&apos;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValUseFlag.CtorValUsedAsSelfInit">
<summary>
 A call to a constructor, e.g. &apos;new C() = new C(3)&apos;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValUseFlag.CtorValUsedAsSuperInit">
<summary>
 A call to a constructor, e.g. &apos;inherit C()&apos;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValUseFlag.NormalValUse">
<summary>
 A normal use of a value
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValUseFlag.PossibleConstrainedCall">
<summary>
 Indicates a use of a value represents a call to a method that may require
 a .NET 2.0 constrained call. A constrained call is only used for calls where 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValUseFlag">
<summary>
 Indicates how a value, function or member is being used at a particular usage point.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.SequentialOpKind.ThenDoSeq">
<summary>
 let res = a in b;res 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.SequentialOpKind.NormalSeq">
<summary>
 a ; b 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.SequentialOpKind">
<summary>
 Indicates the kind of sequential operation, i.e. &quot;normal&quot; or &quot;to a before returning b&quot;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.LValueOperation.LByrefSet">
<summary>
 In C syntax this is: *localv_ptr = e   
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.LValueOperation.LSet">
<summary>
 In C syntax this is:  localv = e     , note == *(&amp;localv) = e == LGetAddr; LByrefSet
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.LValueOperation.LByrefGet">
<summary>
 In C syntax this is: *localv_ptr        
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.LValueOperation.LGetAddr">
<summary>
 In C syntax this is: &amp;localv            
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.LValueOperation">
<summary>
 Indicates what kind of pointer operation this is.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ForLoopStyle.CSharpForLoopUp">
<summary>
 Evaluate start once and end multiple times, loop up
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ForLoopStyle.FSharpForLoopDown">
<summary>
 Evaluate start and end once, loop down
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ForLoopStyle.FSharpForLoopUp">
<summary>
 Evaluate start and end once, loop up
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ForLoopStyle">
<summary>
 Indicates the kind of looping operation.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.SpecialWhileLoopMarker">
<summary>
 Indicates the kind of looping operation.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ConstrainedCallInfo">
<summary>
 If this is Some(ty) then it indicates that a .NET 2.0 constrained call is required, witht he given type as the
 static type of the object argument.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.RecordConstructionInfo.RecdExpr">
<summary>
 Normal record construction 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.RecordConstructionInfo.RecdExprIsObjInit">
<summary>
 We&apos;re in an explicit constructor. The purpose of the record expression is to 
 fill in the fields of a pre-created but uninitialized object 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.RecordConstructionInfo">
<summary>
 Indicates the kind of record construction operation.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.ILCall">
<summary>
 ILCall(useCallvirt,isProtected,valu,newobj,valUseFlags,isProp,noTailCall,mref,actualTypeInst,actualMethInst, retTy)
  
 IL method calls.
     value -- is the object a value type? 
     isProp -- used for quotation reflection.
     noTailCall - DllImport? if so don&apos;t tailcall 
     actualTypeInst -- instantiation of the enclosing type
     actualMethInst -- instantiation of the method
     retTy -- the types of pushed values, if any 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.LValueOp">
<summary>
 Operation nodes represnting C-style operations on byrefs and mutable vals (l-values) 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.TraitCall">
<summary>
 Pseudo method calls. This is used for overloaded operations like op_Addition. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.Label">
<summary>
 Used for state machine compilation
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.Goto">
<summary>
 Used for state machine compilation
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.Return">
<summary>
 Used for state machine compilation
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.Reraise">
<summary>
 Represents a &quot;rethrow&quot; operation. May not be rebound, or used outside of try-finally, expecting a unit argument 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.Coerce">
<summary>
 Conversion node, compiled via type-directed translation or to box/unbox 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.RefAddrGet">
<summary>
 Generate a ldflda on an &apos;a ref. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.ILAsm">
<summary>
 IL assembly code - type list are the types pushed on the stack 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.TupleFieldGet">
<summary>
 An operation representing a field-get from an F# tuple value.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.ExnFieldSet">
<summary>
 An operation representing a field-set on an F# exception value.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.ExnFieldGet">
<summary>
 An operation representing a field-get from an F# exception value.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.UnionCaseFieldSet">
<summary>
 An operation representing a field-get from a union value. The value is not assumed to have been proven to be of the corresponding union case.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.UnionCaseFieldGet">
<summary>
 An operation representing a field-get from a union value, where that value has been proven to be of the corresponding union case.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.UnionCaseProof">
<summary>
 An operation representing a coercion that proves a union value is of a particular union case. This is not a test, its
 simply added proof to enable us to generate verifiable code for field access on union types
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.UnionCaseTagGet">
<summary>
 An operation representing getting an integer tag for a union value representing the union case number
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.ValFieldGetAddr">
<summary>
 An operation representing getting the address of a record field
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.ValFieldGet">
<summary>
 An operation representing getting a record or class field
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.ValFieldSet">
<summary>
 An operation representing setting a record or class field
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.Recd">
<summary>
 Construct a record or object-model value. The ValRef is for self-referential class constructors, otherwise 
 it indicates that we&apos;re in a constructor and the purpose of the expression is to 
 fill in the fields of a pre-created but uninitialized object, and to assign the initialized 
 version of the object into the optional mutable cell pointed to be the given value. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.TryFinally">
<summary>
 An operation representing a lambda-encoded try/finally
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.TryCatch">
<summary>
 An operation representing a lambda-encoded try/catch
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.For">
<summary>
 An operation representing a lambda-encoded for loop
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.While">
<summary>
 An operation representing a lambda-encoded while loop. The special while loop marker is used to mark compilations of &apos;foreach&apos; expressions
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.UInt16s">
<summary>
 Constant uint16 arrays (used for parser tables)
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.Bytes">
<summary>
 Constant byte arrays (used for parser tables and other embedded data)
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.Array">
<summary>
 An operation representing the creation of an array value
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.Tuple">
<summary>
 An operation representing the creation of a tuple value
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.ExnConstr">
<summary>
 An operation representing the creation of an exception value using an F# exception declaration
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TOp.UnionCase">
<summary>
 An operation representing the creation of a union value of the particular union case
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Expr.Link">
<summary>
 Typechecking residue: A Expr.Link occurs for every use of a recursively bound variable. While type-checking 
 the recursive bindings a dummy expression is stored in the mutable reference cell. 
 After type checking the bindings this is replaced by a use of the variable, perhaps at an 
 appropriate type instantiation. These are immediately eliminated on subsequent rewrites. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Expr.TyChoose">
<summary>
 Typechecking residue: Indicates a free choice of typars that arises due to 
 minimization of polymorphism at let-rec bindings.  These are 
 resolved to a concrete instantiation on subsequent rewrites. 
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Expr.Op">
<summary>
 An intrinsic applied to some (strictly evaluated) arguments 
 A few of intrinsics (TOp_try, TOp.While, TOp.For) expect arguments kept in a normal form involving lambdas 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Expr.StaticOptimization">
<summary>
 If we statically know some infomation then in many cases we can use a more optimized expression 
 This is primarily used by terms in the standard library, particularly those implementing overloaded 
 operators. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Expr.Match">
<summary>
 Matches are a more complicated form of &quot;let&quot; with multiple possible destinations 
 and possibly multiple ways to get to each destination.  
 The first mark is that of the expression being matched, which is used 
 as the mark for all the decision making and binding that happens during the match. 
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Expr.Let">
<summary>
 Bind a value. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Expr.LetRec">
<summary>
 Bind a recursive set of values. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Expr.App">
<summary>
 Applications.
 Applications combine type and term applications, and are normalized so 
 that sequential applications are combined, so &quot;(f x y)&quot; becomes &quot;f [[x];[y]]&quot;. 
 The type attached to the function is the formal function type, used to ensure we don&apos;t build application 
 nodes that over-apply when instantiating at function types. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Expr.TyLambda">
<summary>
 Type lambdas.  These are used for the r.h.s. of polymorphic &apos;let&apos; bindings and 
 for expressions that implement first-class polymorphic values. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Expr.Lambda">
<summary>
 Lambda expressions. 
 Why multiple vspecs? A Expr.Lambda taking multiple arguments really accepts a tuple. 
 But it is in a convenient form to be compile accepting multiple 
 arguments, e.g. if compiled as a toplevel static method. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Expr.Sequential">
<summary>
 Sequence expressions, used for &quot;a;b&quot;, &quot;let a = e in b;a&quot; and &quot;a then b&quot; (the last an OO constructor). 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Expr.Val">
<summary>
 Reference a value. The flag is only relevant if the value is an object model member 
 and indicates base calls and special uses of object constructors. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Expr.Const">
<summary>
 A constant expression. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Expr">
<summary>
 The big type of expressions.  
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparReprInfo">
<summary>
 Records the extra metadata stored about typars for type parameters
 compiled as &quot;real&quot; IL type parameters, specifically for values with 
 ValReprInfo. Any information here is propagated from signature through
 to the compiled code.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ArgReprInfo">
<summary>
 Records the &quot;extra information&quot; for an argument compiled as a real
 method argument, specificially the argument name and attributes.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValReprInfo.ValReprInfo">
<summary>
 ValReprInfo (numTypars, args, result)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValReprInfo">
<summary>
 Records the &quot;extra information&quot; for a value compiled as a method (rather
 than a closure or a local), including argument names, attributes etc.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.DecisionTreeTarget">
<summary>
 A target of a decision tree. Can be thought of as a little function, though is compiled as a local block. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Test.ActivePatternCase">
<summary>
 Test.ActivePatternCase(activePatExpr, activePatResTys, activePatIdentity, idx, activePatInfo)

 Run the active pattern and bind a successful result to a 
 variable in the remaining tree. 
     activePatExpr     -- The active pattern function being called, perhaps applied to some active pattern parameters.
     activePatResTys   -- The result types (case types) of the active pattern.
     activePatIdentity -- The value and the types it is applied to. If there are any active pattern parameters then this is empty. 
     idx               -- The case number of of the active pattern which the test relates to.
     activePatternInfo -- The extracted info for the active pattern.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Test.IsInst">
<summary>
 IsInst(source, target)

 Test if the input to a decision tree is an instance of the given type 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Test.IsNull">
<summary>
 Test if the input to a decision tree is null 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Test.Const">
<summary>
 Test if the input to a decision tree is the given constant value 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Test.ArrayLength">
<summary>
 Test if the input to a decision tree is an array of the given length 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Test.UnionCase">
<summary>
 Test if the input to a decision tree matches the given union case
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.DecisionTree.TDBind">
<summary>
 TDBind(binding, body)

 Bind the given value throught the remaining cases of the dtree. 
 These arise from active patterns and some optimizations to prevent
 repeated computations in decision trees.
    binding -- the value and the expression it is bound to
    body -- the rest of the decision tree
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.DecisionTree.TDSuccess">
<summary>
 TDSuccess(results, targets)

 Indicates the decision tree has terminated with success, calling the given target with the given parameters.
    results -- the expressions to be bound to the variables at the target
    target -- the target number for the continuation
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.DecisionTree.TDSwitch">
<summary>
 TDSwitch(input, cases, default, range)

 Indicates a decision point in a decision tree. 
    input -- the expression being tested
    cases -- the list of tests and their subsequent decision trees
    default -- the default decision tree, if any
    range -- (precise documentation  needed)
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.DecisionTree">
<summary>
 Decision trees. Pattern matching has been compiled down to
 a decision tree by this point.  The right-hand-sides (actions) of
 the decision tree are labelled by integers that are unique for that
 particular tree.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Const">
<summary>
 Constants in expressions
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.AttribNamedArg">
<summary>
 AttribExpr(source, evaluated)
 AttribNamedArg(name,type,isField,value)
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.AttribExpr">
<summary>
 We keep both source expression and evaluated expression around to help intellisense and signature printing
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Attrib">
<summary>
 Attrib(kind,unnamedArgs,propVal,appliedToAGetterOrSetter,targetsOpt,range)
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.AttribKind.FSAttrib">
<summary>
 Indicates an attribute refers to a type defined in an imported F# assembly 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.AttribKind.ILAttrib">
<summary>
 Indicates an attribute refers to a type defined in an imported .NET assembly 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.PickledModuleInfo">
<summary>
 Represents the information saved in the assembly signature data resource for an F# assembly
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.CcuResolutionResult">
<summary>
 The result of attempting to resolve an assembly name to a full ccu.
 UnresolvedCcu will contain the name of the assembly that could not be resolved.
</summary>
</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.CcuThunk.orphanfixup">
<summary>
 ccu.orphanfixup is true when a reference is missing in the transitive closure of static references that
 may potentially be required for the metadata of referenced DLLs. It is set to true if the &quot;loader&quot;
 used in the F# metadata-deserializer or the .NET metadata reader returns a failing value (e.g. None).
 Note: When used from Visual Studio, the loader will not automatically chase down transitively referenced DLLs - they
 must be in the explicit references in the project.
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.CcuThunk.UsesQuotations(System.Boolean)">
<summary>
 Indicates that this DLL uses quotation literals somewhere. This is used to implement a restriction on static linking
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.CcuThunk.UsesQuotations">
<summary>
 Indicates that this DLL uses quotation literals somewhere. This is used to implement a restriction on static linking
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.CcuThunk.TypeForwarders">
<summary>
 The table of type forwarders for this assembly
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.CcuThunk.Stamp">
<summary>
 A unique stamp for this DLL 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.CcuThunk.SourceCodeDirectory">
<summary>
 A hint as to where does the code for the CCU live (e.g what was the tcConfig.implicitIncludeDir at compilation time for this DLL?) 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.CcuThunk.RootTypeAndExceptionDefinitions">
<summary>
 The table of type definitions at the &quot;root&quot; of the assembly
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.CcuThunk.RootModulesAndNamespaces">
<summary>
 The table of modules and namespaces at the &quot;root&quot; of the assembly
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.CcuThunk.QualifiedName">
<summary>
 The fully qualified assembly reference string to refer to this assembly. This is persisted in quotations 
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.CcuThunk.IsProviderGenerated">
<summary>
 Is the CCu an EST injected assembly
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.CcuThunk.IsFSharp">
<summary>
 Indicates that this DLL was compiled using the F# compiler and has F# metadata
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.CcuThunk.ILScopeRef">
<summary>
 Holds the data indicating how this assembly/module is referenced from the code being compiled. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.CcuThunk.FileName">
<summary>
 Holds the filename for the DLL, if any 
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.CcuThunk.Contents">
<summary>
 A handle to the full specification of the contents of the module contained in this ccu
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.CcuThunk.TryForward(System.String[],System.String)">
<summary>
 Try to resolve a path into the CCU by referencing the .NET/CLI type forwarder table of the CCU
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.CcuThunk.MemberSignatureEquality(Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Used to make forward calls into the type/assembly loader when comparing member signatures during linking
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.CcuThunk.ImportProvidedType(Microsoft.FSharp.Compiler.Tainted{Microsoft.FSharp.Compiler.ExtensionTyping.ProvidedType})">
<summary>
 Used to make &apos;forward&apos; calls into the loader during linking
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.CcuThunk.FixupOrphaned">
<summary>
 Fixup a CCU to record it as &quot;orphaned&quot;, i.e. not available
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.CcuThunk.Fixup(Microsoft.FSharp.Compiler.Tast.CcuThunk)">
<summary>
 Fixup a CCU to have the given contents
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.CcuThunk.EnsureDerefable(System.String[])">
<summary>
 Ensure the ccu is derefable in advance. Supply a path to attach to any resulting error message.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.CcuThunk.CreateDelayed(System.String)">
<summary>
 Create a CCU with the given name but where the contents have not yet been specified
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.CcuThunk.Create(System.String,Microsoft.FSharp.Compiler.Tast.CcuData)">
<summary>
 Create a CCU with the given name and contents
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.CcuThunk">
<summary>
 A relinkable handle to the contents of a compilation unit. Relinking is performed by mutation.
 A compilation unit is, more or less, the new material created in one
 invocation of the compiler.  Due to static linking assemblies may hold more 
 than one compilation unit (i.e. when two assemblies are merged into a compilation
 the resulting assembly will contain 3 CUs).  Compilation units are also created for referenced
 .NET assemblies. 
 
 References to items such as type constructors are via 
 cross-compilation-unit thunks, which directly reference the data structures that define
 these modules.  Thus, when saving out values to disk we only wish 
 to save out the &quot;current&quot; part of the term graph.  When reading values
 back in we &quot;fixup&quot; the links to previously referenced modules.

 All non-local accesses to the data structures are mediated
 by ccu-thunks.  Ultimately, a ccu-thunk is either a (named) element of
 the data structure, or it is a delayed fixup, i.e. an invalid dangling
 reference that has not had an appropriate fixup applied.  
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.CcuTypeForwarderTable">
<summary>
 Represents a table of .NET CLI type forwarders for an assembly
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.CcuData.TypeForwarders">
<summary>
 The table of .NET CLI type forwarders for this assembly
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.CcuData.MemberSignatureEquality">
<summary>
 A helper function used to link method signatures using type equality. This is effectively a forward call to the type equality 
 logic in tastops.fs
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.CcuData.Contents">
<summary>
 A handle to the full specification of the contents of the module contained in this ccu
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.CcuData.UsesQuotations">
<summary>
 Indicates that this DLL uses quotation literals somewhere. This is used to implement a restriction on static linking
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.CcuData.ImportProvidedType">
<summary>
 A helper function used to link method signatures using type equality. This is effectively a forward call to the type equality 
 logic in tastops.fs
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.CcuData.InvalidateEvent">
<summary>
 Triggered when the contents of the CCU are invalidated
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.CcuData.IsProviderGenerated">
<summary>
 Is the CCu an assembly inected by a type provider
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.CcuData.IsFSharp">
<summary>
 Indicates that this DLL was compiled using the F# compiler and has F# metadata
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.CcuData.SourceCodeDirectory">
<summary>
 A hint as to where does the code for the CCU live (e.g what was the tcConfig.implicitIncludeDir at compilation time for this DLL?) 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.CcuData.QualifiedName">
<summary>
 The fully qualified assembly reference string to refer to this assembly. This is persisted in quotations 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.CcuData.Stamp">
<summary>
 A unique stamp for this DLL 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.CcuData.ILScopeRef">
<summary>
 Holds the data indicating how this assembly/module is referenced from the code being compiled. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.CcuData.FileName">
<summary>
 Holds the filename for the DLL, if any 
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.MeasureExpr.MeasureOne">
<summary>
 The unit of measure &apos;1&apos;, e.g. float = float&lt;1&gt;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.MeasureExpr.MeasureInv">
<summary>
 An inverse of a units of measure expression
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.MeasureExpr.MeasureProd">
<summary>
 A product of two units of measure
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.MeasureExpr.MeasureCon">
<summary>
 A constant, leaf unit-of-measure such as &apos;kg&apos; or &apos;m&apos;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.MeasureExpr.MeasureVar">
<summary>
 A variable unit-of-measure
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TType.TType_measure">
<summary>
 Indicates the type is a unit-of-measure expression being used as an argument to a type or member
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TType.TType_var">
<summary>
 Indicates the type is a variable type, whether declared, generalized or an inference type parameter  
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TType.TType_ucase">
<summary>
 TType_ucase(unionCaseRef, typeInstantiation)

 Indicates the type is a non-F#-visible type representing a &quot;proof&quot; that a union value belongs to a particular union case
 These types are not user-visible and will never appear as an inferred type. They are the types given to
 the temporaries arising out of pattern matching on union values.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TType.TType_fun">
<summary>
 TType_fun(domainType,rangeType).

 Indicates the type is a function type 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TType.TType_tuple">
<summary>
 TType_tuple(elementTypes).

 Indicates the type is a tuple type. elementTypes must be of length 2 or greater.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TType.TType_app">
<summary>
 TType_app(tyconRef, typeInstantiation).

 Indicates the type is build from a named type and a number of type arguments
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TType.TType_forall">
<summary>
 TType_forall(typars, bodyTy).

 Indicates the type is a universal type, only used for types of values and members 
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TType">
<summary>
 The algebra of types
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.ValRef.nlr">
<summary>
 Indicates a reference to something bound in another CCU 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.ValRef.binding">
<summary>
 Indicates a reference to something bound in this CCU 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValRef">
<summary>
 References are either local or nonlocal
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceRef">
<summary>
 note: ModuleOrNamespaceRef and TyconRef are type equivalent 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.EntityRef.nlr">
<summary>
 Indicates a reference to something bound in another CCU 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.EntityRef.binding">
<summary>
 Indicates a reference to something bound in this CCU 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.XmlDocSig">
<summary>
 The XML documentation sig-string of the entity, if any, to use to lookup an .xml doc file. This also acts
 as a cache for this sig-string computation.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.XmlDoc">
<summary>
 The XML documentation of the entity, if any. If the entity is backed by provided metadata
 then this _does_ include this documentation. If the entity is backed by Abstract IL metadata
 or comes from another F# assembly then it does not (because the documentation will get read from 
 an XML file).
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.UnionTypeInfo">
<summary>
 Get the union cases and other union-type information for a type, if any
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.UnionCasesAsList">
<summary>
 Get the union cases for a type, if any, as a list
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.UnionCasesArray">
<summary>
 Get the union cases for a type, if any
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.TypeReprInfo">
<summary>
 The information about the r.h.s. of a type definition, if any. For example, the r.h.s. of a union or record type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.TypeReprAccessibility">
<summary>
 Get the value representing the accessiblity of the r.h.s. of an F# type definition.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.TypeOrMeasureKind">
<summary>
 The kind of the type definition - is it a measure definition or a type definition?
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.TypeContents">
<summary>
 The logical contents of the entity when it is a type definition.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.TypeAbbrev">
<summary>
 Indicates if this entity is an F# type abbreviation definition
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.TyparsNoRange">
<summary>
 Get the type parameters for an entity that is a type declaration, otherwise return the empty list.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.TrueInstanceFieldsAsList">
<summary>
 Get a list of all instance fields for F#-defined record, struct and class fields in this type definition,
 excluding compiler-generate fields.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.TrueFieldsAsList">
<summary>
 Get a list of all fields for F#-defined record, struct and class fields in this type definition,
 including static fields, but excluding compiler-generate fields.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.Stamp">
<summary>
 A unique stamp for this module, namespace or type definition within the context of this compilation. 
 Note that because of signatures, there are situations where in a single compilation the &quot;same&quot; 
 module, namespace or type may have two distinct Entity objects that have distinct stamps.
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.Range">
<summary>
 The code location where the module, namespace or type is defined.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.PublicPath">
<summary>
 Get a blob of data indicating how this type is nested in other namespaces, modules or types.
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.PreEstablishedHasDefaultConstructor">
<summary>
 Indicates if we have pre-determined that a type definition has a default constructor.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.ModuleOrNamespaceType">
<summary>
 The logical contents of the entity when it is a module or namespace fragment.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.MembersOfFSharpTyconSorted">
<summary>
 Gets the immediate members of an F# type definition, excluding compiler-generated ones.
 Note: result is alphabetically sorted, then for each name the results are in declaration order
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.MembersOfFSharpTyconByName">
<summary>
 Gets all immediate members of an F# type definition keyed by name, including compiler-generated ones.
 Note: result is a indexed table, and for each name the results are in reverse declaration order
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.LogicalName">
<summary>
 The name of the namespace, module or type, possibly with mangling, e.g. List`1, List or FailureException 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsUnionTycon">
<summary>
 Indicate if this is a type whose r.h.s. is known to be a union type definition.
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsStructOrEnumTycon">
<summary>
 Indicates if this is a struct or enum type definition , i.e. a value type definition
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsRecordTycon">
<summary>
 Indicates if this is an F# type definition whose r.h.s. is known to be a record type definition.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsProvidedNamespace">
<summary>
 Indicates if the entity is a provided namespace fragment
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsProvidedGeneratedTycon">
<summary>
 Indicates if the entity is a generated provided type definition, i.e. not erased.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsProvidedErasedTycon">
<summary>
 Indicates if the entity is an erased provided type definition
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsProvided">
<summary>
 Indicates if the entity is a provided namespace fragment
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsPrefixDisplay">
<summary>
 Indicates the type prefers the &quot;tycon&lt;a,b&gt;&quot; syntax for display etc. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsNamespace">
<summary>
 Indicates if the entity is a namespace
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsModuleOrNamespace">
<summary>
 Indicates the &quot;tycon blob&quot; is actually a module 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsModule">
<summary>
 Indicates if the entity is an F# module definition
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsMeasureableReprTycon">
<summary>
 Indicates if this is an F# type definition which is one of the special types in FSharp.Core.dll like &apos;float&lt;_&gt;&apos; which
 defines a measure type with a relation to an existing non-measure type as a representation.
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsILTycon">
<summary>
 Indicate if this is a type definition backed by Abstract IL metadata.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsILStructOrEnumTycon">
<summary>
 Indicates if this is a .NET-defined struct or enum type definition , i.e. a value type definition
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsILEnumTycon">
<summary>
 Indicates if this is a .NET-defined enum type definition 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsHiddenReprTycon">
<summary>
 Indicates if this is an F# type definition whose r.h.s. definition is unknown (i.e. a traditional ML &apos;abstract&apos; type in a signature,
 which in F# is called a &apos;unknown representation&apos; type).
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsFSharpStructOrEnumTycon">
<summary>
 Indicates if this is an F#-defined struct or enum type definition , i.e. a value type definition
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsFSharpObjectModelTycon">
<summary>
 Indicates if this is an F# type definition whose r.h.s. is known to be some kind of F# object model definition
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsFSharpInterfaceTycon">
<summary>
 Indicates if this is an F#-defined interface type definition 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsFSharpEnumTycon">
<summary>
 Indicates if this is an F#-defined enum type definition 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsFSharpDelegateTycon">
<summary>
 Indicates if this is an F#-defined delegate type definition 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsExceptionDecl">
<summary>
 Indicates if the entity represents an F# exception declaration.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsErased">
<summary>
 Indicates if the entity is erased, either a measure definition, or an erased provided type definition
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsEnumTycon">
<summary>
 Indicates if this is an enum type definition 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.IsAsmReprTycon">
<summary>
 Indicates if this is an F# type definition which is one of the special types in FSharp.Core.dll which uses 
 an assembly-code representation for the type, e.g. the primitive array type constructor.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.ImmediateInterfacesOfFSharpTycon">
<summary>
 Gets the immediate interface definitions of an F# type definition. Further interfaces may be supported through class and interface inheritance.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.ImmediateInterfaceTypesOfFSharpTycon">
<summary>
 Gets the immediate interface types of an F# type definition. Further interfaces may be supported through class and interface inheritance.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.Id">
<summary>
 The identifier at the point of declaration of the type definition.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.ILTyconRawMetadata">
<summary>
 Get the Abstract IL metadata for this type definition, assuming it is backed by Abstract IL metadata.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.ILTyconInfo">
<summary>
 Get the Abstract IL scope, nesting and metadata for this 
 type definition, assuming it is backed by Abstract IL metadata.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.HasSelfReferentialConstructor">
<summary>
 Indicates if we have pre-determined that a type definition has a self-referential constructor using &apos;as x&apos;
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.GeneratedHashAndEqualsWithComparerValues">
<summary>
 Gets any implicit hash/equals (with comparer argument) methods added to an F# record, union or struct type definition.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.GeneratedHashAndEqualsValues">
<summary>
 Gets any implicit hash/equals methods added to an F# record, union or struct type definition.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.GeneratedCompareToWithComparerValues">
<summary>
 Gets any implicit CompareTo (with comparer argument) methods added to an F# record, union or struct type definition.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.GeneratedCompareToValues">
<summary>
 Gets any implicit CompareTo methods added to an F# record, union or struct type definition.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.FSharpObjectModelTypeInfo">
<summary>
 Get the blob of information associated with an F# object-model type definition, i.e. class, interface, struct etc.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.ExceptionInfo">
<summary>
 The information about the r.h.s. of an F# exception definition, if any. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.DisplayNameWithStaticParametersAndUnderscoreTypars">
<summary>
 The display name of the namespace, module or type with &lt;_,_,_&gt; added for generic types,  including static parameters
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.DisplayNameWithStaticParameters">
<summary>
 The display name of the namespace, module or type, e.g. List instead of List`1, including static parameters
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.DisplayName">
<summary>
 The display name of the namespace, module or type, e.g. List instead of List`1, not including static parameters
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.DemangledModuleOrNamespaceName">
<summary>
 Demangle the module name, if FSharpModuleWithSuffix is used
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.CompiledRepresentationForNamedType">
<summary>
 Gets the data indicating the compiled representation of a named type or module in terms of Abstract IL data structures.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.CompiledRepresentation">
<summary>
 Gets the data indicating the compiled representation of a type or module in terms of Abstract IL data structures.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.CompiledReprCache">
<summary>
 Get the cache of the compiled ILTypeRef representation of this module or type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.CompiledName">
<summary>
 The compiled name of the namespace, module or type, e.g. FSharpList`1, ListModule or FailureException 
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.CompilationPath">
<summary>
 Get a blob of data indicating how this type is nested inside other namespaces, modules and types.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.CanDeref">
<summary>
 Is the destination assembly available?
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.Attribs">
<summary>
 The F#-defined custom attributes of the entity, if any. If the entity is backed by Abstract IL or provided metadata
 then this does not include any attributes from those sources.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.AllInstanceFieldsAsList">
<summary>
 Get a list of all instance fields for F#-defined record, struct and class fields in this type definition.
 including hidden fields from the compilation of implicit class constructions.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.AllFieldsAsList">
<summary>
 Get a list of fields for all the F#-defined record, struct and class fields in this type definition, including
 static fields, &apos;val&apos; declarations and hidden fields from the compilation of implicit class constructions.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.AllFieldsArray">
<summary>
 Get an array of fields for all the F#-defined record, struct and class fields in this type definition, including
 static fields, &apos;val&apos; declarations and hidden fields from the compilation of implicit class constructions.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.AllFieldTable">
<summary>
 Get a table of fields for all the F#-defined record, struct and class fields in this type definition, including
 static fields, &apos;val&apos; declarations and hidden fields from the compilation of implicit class constructions.
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityRef.Accessibility">
<summary>
 Get the value representing the accessiblity of an F# type definition or module.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.EntityRef.Typars(Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Get the type parameters for an entity that is a type declaration, otherwise return the empty list.
 
 Lazy because it may read metadata, must provide a context &quot;range&quot; in case error occurs reading metadata.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.EntityRef.GetUnionCaseByName(System.String)">
<summary>
 Get a union case of a type by name
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.EntityRef.GetFieldByName(System.String)">
<summary>
 Get a field by name.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.EntityRef.GetFieldByIndex(System.Int32)">
<summary>
 Get a field by index in definition order
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.NonLocalEntityRef.TryModuleOrNamespaceType">
<summary>
 Try to get the details of the module or namespace fragment referred to by this non-local reference.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.NonLocalEntityRef.TryDeref">
<summary>
 Try to link a non-local entity reference to an actual entity
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.NonLocalEntityRef.Path">
<summary>
 Get the path into the CCU referenced by the nonlocal reference.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.NonLocalEntityRef.ModuleOrNamespaceType">
<summary>
 Get the details of the module or namespace fragment for the entity referred to by this non-local reference.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.NonLocalEntityRef.LastItemMangledName">
<summary>
 Get the mangled name of the last item in the path of the nonlocal reference.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.NonLocalEntityRef.EnclosingMangledPath">
<summary>
 Get the all-but-last names of the path of the nonlocal reference.
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.NonLocalEntityRef.Deref">
<summary>
 Dereference the nonlocal reference, and raise an error if this fails.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.NonLocalEntityRef.Ccu">
<summary>
 Get the CCU referenced by the nonlocal reference.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.NonLocalEntityRef.AssemblyName">
<summary>
 Get the name of the assembly referenced by the nonlocal reference.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.NonLocalEntityRef.TryDerefEntityPathViaProvidedType(Microsoft.FSharp.Compiler.Tast.CcuThunk,System.String[],System.Int32,Microsoft.FSharp.Compiler.Tast.Entity)">
<summary>
 Try to find the entity correspondng to the given path, using type-providers to link the data
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.NonLocalEntityRef.TryDerefEntityPath(Microsoft.FSharp.Compiler.Tast.CcuThunk,System.String[],System.Int32,Microsoft.FSharp.Compiler.Tast.Entity)">
<summary>
 Try to find the entity correspondng to the given path in the given CCU
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.NonLocalEntityRef">
<summary>
 Index into the namespace/module structure of a particular CCU 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.NonLocalValOrMemberRef.ItemKey">
<summary>
 The name of the value, or the full signature of the member
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.NonLocalValOrMemberRef.EnclosingEntity">
<summary>
 A reference to the entity containing the value or member. THis will always be a non-local reference
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.ValMemberInfo.IsImplemented">
<summary>
 Gets updated with &apos;true&apos; if an abstract slot is implemented in the file being typechecked.  Internal only. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.ValMemberInfo.ImplementedSlotSigs">
<summary>
 Updated with the full implemented slotsig after interface implementation relation is checked 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.ValMemberInfo.ApparentParent">
<summary>
 The parent type. For an extension member this is the type being extended 
</summary>
</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.ValData.val_xmldocsig">
<summary>
 XML documentation signature for the value
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.ValData.val_xmldoc">
<summary>
 XML documentation attached to a value.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.ValData.val_attribs">
<summary>
 Custom attributes attached to the value. These contain references to other values (i.e. constructors in types). Mutable to fixup  
 these value references after copying a colelction of values. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.ValData.val_member_info">
<summary>
 Is the value actually an instance method/property/event that augments 
 a type, and if so what name does it take in the IL?
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.ValData.val_access">
<summary>
 How visible is this? 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.ValData.val_defn">
<summary>
 What is the original, unoptimized, closed-term definition, if any? 
 Used to implement [&lt;ReflectedDefinition&gt;]
</summary>
</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.ValData.val_flags">
<summary>
 See vflags section further below for encoding/decodings here 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.XmlDocSig(System.String)">
<summary>
Get the signature for the value&apos;s XML documentation
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.XmlDocSig">
<summary>
Get the signature for the value&apos;s XML documentation
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.XmlDoc">
<summary>
 Get the declared documentation for the value
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.ValReprInfo">
<summary>
 Records the &quot;extra information&quot; for a value compiled as a method.

 This indicates the number of arguments in each position for a curried 
 functions, and relates to the F# spec for arity analysis.
 For module-defined values, the currying is based 
 on the number of lambdas, and in each position the elements are 
 based on attempting to deconstruct the type of the argument as a 
 tuple-type.  

 The field is mutable because arities for recursive 
 values are only inferred after the r.h.s. is analyzed, but the 
 value itself is created before the r.h.s. is analyzed. 

 TLR also sets this for inner bindings that it wants to 
 represent as &quot;top level&quot; bindings.     
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.TypeScheme">
<summary>
 Get the type of the value including any generic type parameters
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.Type">
<summary>
 The type of the value. 
 May be a TType_forall for a generic value. 
 May be a type variable or type containing type variables during type inference. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.Typars">
<summary>
 Get the generic type parameters for the value
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.TopValActualParent">
<summary>
 Get the actual parent entity for the value (a module or a type), i.e. the entity under which the
 value will appear in compiled code. For extension members this is the module where the extension member
 is declared.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.TauType">
<summary>
 Get the type of the value after removing any generic type parameters
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.Stamp">
<summary>
 A unique stamp within the context of this invocation of the compiler process 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.ReflectedDefinition">
<summary>
 The quotation expression associated with a value given the [&lt;ReflectedDefinition&gt;] tag
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.RecursiveValInfo">
<summary>
 Get the information about the value used during type inference
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.Range">
<summary>
 The place where the value was defined. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.PublicPath">
<summary>
 Get the public path to the value, if any? Should be set if and only if
 IsMemberOrModuleBinding is set.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.PropertyName">
<summary>
   - If this is a property then this is &apos;Foo&apos; 
   - If this is an implementation of an abstract slot then this is the name of the property implemented by the abstract slot
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.PermitsExplicitTypeInstantiation">
<summary>
 Indicates if this is allows the use of an explicit type instantiation (i.e. does it itself have explciti type arguments,
 or does it have a signature?)
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.NumObjArgs">
<summary>
 Get the number of &apos;this&apos;/&apos;self&apos; object arguments for the member. Instance extension members return &apos;1&apos;.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.MustInline">
<summary>
 Indicates whether the inline declaration for the value indicate that the value must be inlined?
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.MemberInfo">
<summary>
 Is this a member, if so some more data about the member.

 Note, the value may still be (a) an extension member or (b) and abtract slot without
 a true body. These cases are often causes of bugs in the compiler.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.MemberApparentParent">
<summary>
 Get the apparent parent entity for a member
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.MakesNoCriticalTailcalls">
<summary>
 Indicates if this is inferred to be a method or function that definitely makes no critical tailcalls?
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.LogicalName">
<summary>
 The name of the method. 
   - If this is a property then this is &apos;get_Foo&apos; or &apos;set_Foo&apos;
   - If this is an implementation of an abstract slot then this is the name of the method implemented by the abstract slot
   - If this is an extension member then this will be the simple name
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.LiteralValue">
<summary>
 The value of a value or member marked with [&lt;LiteralAttribute&gt;] 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.LinkagePartialKey">
<summary>
 The partial information used to index the methods of all those in a ModuleOrNamespace.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.LinkageFullKey">
<summary>
 The full information used to identify a specific overloaded method amongst all those in a ModuleOrNamespace.
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.IsOverrideOrExplicitImpl">
<summary>
 Indicates if this value was a member declared &apos;override&apos; or an implementation of an interface slot
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.IsMutable">
<summary>
 Indicates if this is declared &apos;mutable&apos;
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.IsModuleBinding">
<summary>
 Indicates if this is an F#-defined value in a module, or an extension member, but excluding compiler generated bindings from optimizations
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.IsMemberOrModuleBinding">
<summary>
 Is this a member definition or module definition?
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.IsMember">
<summary>
 Indicates if this is a member, and if so, gives some more data about the member.

 Note, the value may still be (a) an extension member or (b) and abtract slot without
 a true body. These cases are often causes of bugs in the compiler.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.IsLinked">
<summary>
 Indicates if a value is linked to backing data yet. Only used during unpickling of F# metadata.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.IsIntrinsicMember">
<summary>
 Indicates if this is a member, excluding extension members
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.IsInstanceMember">
<summary>
 Indicates if this is an F#-defined instance member. 

 Note, the value may still be (a) an extension member or (b) and abtract slot without
 a true body. These cases are often causes of bugs in the compiler.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.IsIncrClassGeneratedMember">
<summary>
 Indicates if this is a member generated from the de-sugaring of &apos;let&apos; function bindings in the implicit class syntax?
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.IsIncrClassConstructor">
<summary>
 Indicates if this is a constructor member generated from the de-sugaring of implicit constructor for a class type?
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.IsExtensionMember">
<summary>
 Indicates if this is an F#-defined extension member
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.IsDispatchSlot">
<summary>
 Indicates if this member is an F#-defined dispatch slot.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.IsConstructor">
<summary>
 Indicates if this is an F#-defined &apos;new&apos; constructor member
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.IsCompilerGenerated">
<summary>
 Indicates whether this value was generated by the compiler.

 Note: this is true for the overrides generated by hash/compare augmentations
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.IsCompiledIntoModule">
<summary>
 Indicates if this is something compiled into a module, i.e. a user-defined value, an extension member or a compiler-generated value
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.IsCompiledAsTopLevel">
<summary>
 Is this represented as a &quot;top level&quot; static binding (i.e. a static field, static member,
 instance member), rather than an &quot;inner&quot; binding that may result in a closure.

 This is implied by IsMemberOrModuleBinding, however not vice versa, for two reasons.
 Some optimizations mutate this value when they decide to change the representation of a 
 binding to be IsCompiledAsTopLevel. Second, even immediately after type checking we expect
 some non-module, non-member bindings to be marked IsCompiledAsTopLevel, e.g. &apos;y&apos; in 
 &apos;let x = let y = 1 in y + y&apos; (NOTE: check this, don&apos;t take it as gospel)
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.IsCompiledAsStaticPropertyWithoutField">
<summary>
 Indicates if the backing field for a static value is suppressed.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.IsClassConstructor">
<summary>
 Indicates if this is a compiler-generated class constructor member
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.InlineInfo">
<summary>
 Get the inline declaration on the value
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.HasBeenReferenced">
<summary>
 Indicates if this is ever referenced?
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.DisplayName">
<summary>
   - If this is a property then this is &apos;Foo&apos; 
   - If this is an implementation of an abstract slot then this is the name of the method implemented by the abstract slot
   - If this is an operator then this is &apos;(+)&apos;
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.DefinitionRange">
<summary>
 Range of the definition (implementation) of the value, used by Visual Studio 
 Updated by mutation when the implementation is matched against the signature. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.CoreDisplayName">
<summary>
 The name of the method. 
   - If this is a property then this is &apos;Foo&apos; 
   - If this is an implementation of an abstract slot then this is the name of the method implemented by the abstract slot
   - If this is an operator then this is &apos;op_Addition&apos;
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.CompiledName">
<summary>
 The name of the method in compiled code (with some exceptions where ilxgen.fs decides not to use a method impl)
   - If this is a property then this is &apos;get_Foo&apos; or &apos;set_Foo&apos;
   - If this is an implementation of an abstract slot then this may be a mangled name
   - If this is an extension member then this will be a mangled name
   - If this is an operator then this is &apos;op_Addition&apos;
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.BaseOrThisInfo">
<summary>
 Indicates if this is a &apos;base&apos; or &apos;this&apos; value?
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.Attribs">
<summary>
 Get the declared attributes for the value
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.ApparentParent">
<summary>
 Get the apparent parent entity for the value, i.e. the entity under with which the
 value is associated. For extension members this is the nominal type the member extends.
 For other values it is just the actual parent.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.ActualParent">
<summary>
 The parent type or module, if any (None for expression bindings and parameters)
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Val.Accessibility">
<summary>
 How visible is this value, function or member?
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Val.NewUnlinked">
<summary>
 Create a new value with empty, unlinked data. Only used during unpickling of F# metadata.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Val.New(Microsoft.FSharp.Compiler.Tast.ValData)">
<summary>
 Create a new value with the given backing data. Only used during unpickling of F# metadata.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Val.Link(Microsoft.FSharp.Compiler.Tast.ValData)">
<summary>
 Link a value based on empty, unlinked data to the given data. Only used during unpickling of F# metadata.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.ValLinkageFullKey.TypeForLinkage">
<summary>
 The full type of the value for the purposes of linking. May be None for non-members, since they can&apos;t be overloaded.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.ValLinkageFullKey.PartialKey">
<summary>
 The partial information used to index the value in a ModuleOrNamespace.
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValLinkageFullKey">
<summary>
 The full information used to identify a specific overloaded method
 amongst all those in a ModuleOrNamespace.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.ValLinkagePartialKey.TotalArgCount">
<summary>
 Indicates the total argument count of the member.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.ValLinkagePartialKey.LogicalName">
<summary>
 Indicates the logical name of the member. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.ValLinkagePartialKey.MemberIsOverride">
<summary>
 Indicates if the member is an override. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.ValLinkagePartialKey.MemberParentMangledName">
<summary>
 The name of the type with which the member is associated. None for non-member values.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValLinkagePartialKey">
<summary>
 The partial information used to index the methods of all those in a ModuleOrNamespace.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TraitConstraintSln.BuiltInSln">
<summary>
 Indicates a trait is solved by a &apos;fake&apos; instance of an operator, like &apos;+&apos; on integers
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TraitConstraintSln.ClosedExprSln">
<summary>
 ClosedExprSln(expr)

 Indicates a trait is solved by an erased provided expression
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TraitConstraintSln.ILMethSln">
<summary>
 ILMethSln(typ, extOpt, ilMethodRef, minst)

 Indicates a trait is solved by a .NET method.
    typ         -- the type and its instantiation
    extOpt      -- information about an extension member, if any
    ilMethodRef -- the method that solves the trait constraint
    minst       -- the generic method instantiation 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TraitConstraintSln.FSRecdFieldSln">
<summary>
 FSRecdFieldSln(tinst, rfref, isSetProp)

 Indicates a trait is solved by an F# record field.
    tinst   -- the instantiation of the declaring type
    rfref   -- the reference to the record field
    isSetProp -- indicates if this is a set of a record field
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TraitConstraintSln.FSMethSln">
<summary>
 FSMethSln(typ, vref, minst)

 Indicates a trait is solved by an F# method.
    typ   -- the type and its instantiation
    vref  -- the method that solves the trait constraint
    minst -- the generic method instantiation 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TraitConstraintSln">
<summary>
 Indicates the solution of a member constraint during inference.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TraitConstraintInfo.TTrait">
<summary>
 TTrait(tys,nm,memFlags,argtys,rty,colution)

 Indicates the signature of a member constraint. Contains a mutable solution cell
 to store the inferred solution of the constraint.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.TraitConstraintInfo.Solution(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Compiler.Tast.TraitConstraintSln})">
<summary>
 Get or set the solution of the member constraint during inference
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.TraitConstraintInfo.Solution">
<summary>
 Get or set the solution of the member constraint during inference
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.TraitConstraintInfo.ReturnType">
<summary>
 Get the return type recorded in the member constraint.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.TraitConstraintInfo.MemberName">
<summary>
 Get the member name associated with the member constraint.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TraitConstraintInfo">
<summary>
 The specification of a member constraint that must be solved 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparConstraint.IsUnmanaged">
<summary>
 Indicates a constraint that a type is .NET unmanaged type
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparConstraint.IsDelegate">
<summary>
 Indicates a constraint that a type is a delegate from the given tuple of args to the given return type
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparConstraint.SupportsEquality">
<summary>
 Indicates a constraint that a type does not have the Equality(false) attribute, or is not a structural type with this attribute, with special rules for some known structural container types
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparConstraint.SupportsComparison">
<summary>
 Indicates a constraint that a type implements IComparable, with special rules for some known structural container types
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparConstraint.IsEnum">
<summary>
 Indicates a constraint that a type is an enum with the given underlying 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparConstraint.RequiresDefaultConstructor">
<summary>
 Indicates a constraint that a type has a parameterless constructor 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparConstraint.SimpleChoice">
<summary>
 Indicates a constraint that a type is a simple choice between one of the given ground types. Only arises from &apos;printf&apos; format strings. See format.fs 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparConstraint.IsReferenceType">
<summary>
 Indicates a constraint that a type is a reference type 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparConstraint.IsNonNullableStruct">
<summary>
 Indicates a constraint that a type is a non-Nullable value type 
 These are part of .NET&apos;s model of generic constraints, and in order to 
 generate verifiable code we must attach them to F# generalzied type variables as well. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparConstraint.MayResolveMember">
<summary>
 Indicates a constraint that a type has a member with the given signature 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparConstraint.SupportsNull">
<summary>
 Indicates a constraint that a type has a &apos;null&apos; value 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparConstraint.DefaultsTo">
<summary>
 Indicates a default value for an inference type variable should it be netiher generalized nor solved 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparConstraint.CoercesTo">
<summary>
 Indicates a constraint that a type is a subtype of the given type 
</summary>
</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.Typar.AsType">
<summary>
 A cached TAST type used when this type variable is used as type.
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Typar.StaticReq">
<summary>
 Indicates if the type variable has a static &quot;head type&quot; requirement, i.e. ^a variables used in FSharp.Core and member constraints.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Typar.Stamp">
<summary>
 The unique stamp of the typar definition
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Typar.Solution">
<summary>
 The inferred equivalence for the type inference variable, if any.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Typar.Rigidity">
<summary>
 Indicates if the type variable can be sovled or given new constraints. The status of a type variable
 generally always evolves towards being either rigid or solved. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Typar.Kind">
<summary>
 Indicates whether a type variable can be instantiated by types or units-of-measure.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Typar.IsSolved">
<summary>
 Indicates if a type variable has been solved.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Typar.IsLinked">
<summary>
 Indicates if a type variable has been linked. Only used during unpickling of F# metadata.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Typar.IsFromError">
<summary>
 Indicates if the type inference variable was generated after an error when type checking expressions or patterns
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Typar.IsErased">
<summary>
 Indicates whether a type variable is erased in compiled .NET IL code, i.e. whether it is a unit-of-measure variable
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Typar.IsCompilerGenerated">
<summary>
 Indicates if the type variable is compiler generated, i.e. is an implicit type inference variable 
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Typar.EqualityConditionalOn">
<summary>
 Indicates that whether or not a generic type definition satisfies the equality constraint is dependent on whether this type variable satisfies the equality constraint.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Typar.DynamicReq">
<summary>
 Indicates if a type parameter is needed at runtime and may not be eliminated
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Typar.DisplayName">
<summary>
 Indicates the display name of a type variable
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Typar.Constraints">
<summary>
 The inferred constraints for the type inference variable, if any
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Typar.ComparisonConditionalOn">
<summary>
 Indicates that whether or not a generic type definition satisfies the comparison constraint is dependent on whether this type variable satisfies the comparison constraint.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Typar.Attribs">
<summary>
 The declared attributes of the type parameter. Empty for type inference variables and parameters from .NET 
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Typar.SetStaticReq(Microsoft.FSharp.Compiler.Ast.TyparStaticReq)">
<summary>
 Sets whether a type variable has a static requirement
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Typar.SetRigidity(Microsoft.FSharp.Compiler.Tast.TyparRigidity)">
<summary>
 Sets the rigidity of a type variable
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Typar.SetIdent(Microsoft.FSharp.Compiler.Ast.Ident)">
<summary>
 Sets the identifier assocaited with a type variable
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Typar.SetEqualityDependsOn(System.Boolean)">
<summary>
 Sets whether the equality constraint of a type definition depends on this type variable 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Typar.SetDynamicReq(Microsoft.FSharp.Compiler.Tast.TyparDynamicReq)">
<summary>
 Sets whether a type variable is required at runtime
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Typar.SetCompilerGenerated(System.Boolean)">
<summary>
 Sets whether a type variable is compiler generated
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Typar.SetComparisonDependsOn(System.Boolean)">
<summary>
 Sets whether the comparison constraint of a type definition depends on this type variable 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Typar.NewUnlinked">
<summary>
 Creates a type variable that contains empty data, and is not yet linked. Only used during unpickling of F# metadata.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Typar.New(Microsoft.FSharp.Compiler.Tast.TyparData)">
<summary>
 Creates a type variable based on the given data. Only used during unpickling of F# metadata.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Typar.Link(Microsoft.FSharp.Compiler.Tast.TyparData)">
<summary>
 Links a previously unlinked type variable to the given data. Only used during unpickling of F# metadata.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Typar.FixupConstraints(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TyparConstraint})">
<summary>
 Adjusts the constraints associated with a type variable
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Typar">
<summary>
 A declared generic type/measure parameter, or a type/measure inference variable.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyparData.typar_constraints">
<summary>
 The inferred constraints for the type inference variable 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyparData.typar_solution">
<summary>
 An inferred equivalence for a type inference variable. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyparData.typar_attribs">
<summary>
 The declared attributes of the type parameter. Empty for type inference variables. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyparData.typar_xmldoc">
<summary>
 The documentation for the type parameter. Empty for type inference variables.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyparData.typar_stamp">
<summary>
 The unique stamp of the typar blob. 
</summary>
</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyparData.typar_il_name">
<summary>
 MUTABILITY: we set the names of generalized inference type parameters to make the look nice for IL code generation 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyparData.typar_id">
<summary>
 MUTABILITY: we set the names of generalized inference type parameters to make the look nice for IL code generation 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparData">
<summary>
 Backing data for type parameters and type inference variables
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Accessibility.TAccess">
<summary>
 Indicates the construct can only be accessed from any code in the given type constructor, module or assembly. [] indicates global scope. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Construct">
<summary>
 A set of static methods for constructing types.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.entities@1350">
<summary>
 Mutation used during compilation of FSharp.Core.dll
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.TypesByAccessNames">
<summary>
 Get a table of types defined within this module, namespace or type. The 
 table is indexed by both name and, for generic types, also by mangled name.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.TypeDefinitions">
<summary>
 Get a list of types defined within this module, namespace or type. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.TypeAndExceptionDefinitions">
<summary>
 Get a list of type and exception definitions defined within this module, namespace or type. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.ModulesAndNamespacesByDemangledName">
<summary>
 Get a table of nested module and namespace fragments indexed by demangled name (so &apos;ListModule&apos; becomes &apos;List&apos;)
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.ModuleOrNamespaceKind">
<summary>
 Namespace or module-compiled-as-type? 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.ModuleAndNamespaceDefinitions">
<summary>
 Get a list of module and namespace definitions defined within this module, namespace or type. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.ExceptionDefinitionsByDemangledName">
<summary>
 Get a table of F# exception definitions indexed by demangled name, so &apos;FailureException&apos; is indexed by &apos;Failure&apos;
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.ExceptionDefinitions">
<summary>
 Get a list of F# exception definitions defined within this module, namespace or type. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.AllValsByLogicalName">
<summary>
 Get a table of values indexed by logical name
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.AllValsAndMembersByPartialLinkageKey">
<summary>
 Get a table of values and members indexed by partial linkage key, which includes name, the mangled name of the parent type (if any), 
 and the method argument count (if any).
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.AllValsAndMembersByLogicalNameUncached">
<summary>
 Compute a table of values and members indexed by logical name.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.AllValsAndMembers">
<summary>
 Values, including members in F# types in this module-or-namespace-fragment. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.AllEntitiesByLogicalMangledName">
<summary>
 Get a table of entities indexed by both logical name
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.AllEntitiesByCompiledAndLogicalMangledNames">
<summary>
 Get a table of entities indexed by both logical and compiled names
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.AllEntities">
<summary>
 Type, mapping mangled name to Tycon, e.g. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.ActivePatternElemRefLookupTable">
<summary>
 Get a table of the active patterns defined in this module.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.TypesByDemangledNameAndArity(Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Get a table of types defined within this module, namespace or type. The 
 table is indexed by both name and generic arity. This means that for generic 
 types &quot;List`1&quot;, the entry (List,1) will be present.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.TryLinkVal(Microsoft.FSharp.Compiler.Tast.CcuThunk,Microsoft.FSharp.Compiler.Tast.ValLinkageFullKey)">
<summary>
 Try to find the member with the given linkage key in the given module.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.AddVal(Microsoft.FSharp.Compiler.Tast.Val)">
<summary>
 Return a new module or namespace type with a value added.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.AddProvidedTypeEntity(Microsoft.FSharp.Compiler.Tast.Entity)">
<summary>
 Mutation used in hosting scenarios to hold the hosted types in this module or namespace
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.AddModuleOrNamespaceByMutation(Microsoft.FSharp.Compiler.Tast.Entity)">
<summary>
 Mutation used during compilation of FSharp.Core.dll
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType.AddEntity(Microsoft.FSharp.Compiler.Tast.Entity)">
<summary>
 Return a new module or namespace type with an entity added.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ExceptionInfo.TExnNone">
<summary>
 Indicates that an exception is abstract, i.e. is in a signature file, and we do not know the representation 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ExceptionInfo.TExnFresh">
<summary>
 Indicates that an exception carries the given record of values 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ExceptionInfo.TExnAsmRepr">
<summary>
 Indicates that an exception is shorthand for the given .NET exception type 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ExceptionInfo.TExnAbbrevRepr">
<summary>
 Indicates that an exception is an abbreviation for the given exception 
</summary>
</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.RecdField.rfield_id">
<summary>
 Name/declaration-location of the field 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.RecdField.rfield_fattribs">
<summary>
 Attributes attached to generated field 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.RecdField.rfield_pattribs">
<summary>
 Attributes attached to generated property 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.RecdField.rfield_access">
<summary>
  Indicates the declared visibility of the field, not taking signatures into account 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.RecdField.rfield_const">
<summary>
 The default initialization info, for static literals 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.RecdField.rfield_secret">
<summary>
 Indicates a compiler generated field, not visible to Intellisense or name resolution 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.RecdField.rfield_volatile">
<summary>
 Indicates a volatile field 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.RecdField.rfield_static">
<summary>
 Indicates a static field 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.RecdField.rfield_type">
<summary>
 The type of the field, w.r.t. the generic parameters of the enclosing type constructor 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.RecdField.rfield_xmldocsig">
<summary>
 XML Documentation signature for the field
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.RecdField.rfield_xmldoc">
<summary>
 Documentation for the field 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.RecdField.rfield_mutable">
<summary>
 Is the field declared mutable in F#? 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.RecdField">
<summary>
 This may represent a &quot;field&quot; in either a struct, class, record or union
 It is normally compiled to a property.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.UnionCase.Attribs">
<summary>
 Attributes, attached to the generated static method to make instances of the case 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.UnionCase.Accessibility">
<summary>
  Indicates the declared visibility of the union constructor, not taking signatures into account 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.UnionCase.Id">
<summary>
 Name/range of the case 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.UnionCase.XmlDocSig">
<summary>
 XML documentation signature for the case
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.UnionCase.XmlDoc">
<summary>
 Documentation for the case 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.UnionCase.CompiledName">
<summary>
 Name of the case in generated IL code 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.UnionCase.ReturnType">
<summary>
 Return type constructed by the case. Normally exactly the type of the enclosing type, sometimes an abbreviation of it 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.UnionCase.FieldTable">
<summary>
 Data carried by the case. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyconUnionData.CompiledRepresentation">
<summary>
 The ILX data structure representing the discriminated union. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyconUnionData.CasesTable">
<summary>
 The cases contained in the discriminated union. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyconUnionCases.CasesByName">
<summary>
 The cases of the discriminated union, indexed by name. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyconUnionCases.CasesByIndex">
<summary>
 The cases of the discriminated union, in declaration order. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyconRecdFields.FieldsByName">
<summary>
 The fields of the record, indexed by name. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyconRecdFields.FieldsByIndex">
<summary>
 The fields of the record, in declaration order. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyconObjModelData.fsobjmodel_rfields">
<summary>
 The fields of the class, struct or enum 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyconObjModelData.fsobjmodel_vslots">
<summary>
 The declared abstract slots of the class, interface or struct 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyconObjModelData.fsobjmodel_kind">
<summary>
 Indicates whether the type declaration is a class, interface, enum, delegate or struct 
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyconObjModelKind.TTyconEnum">
<summary>
 Indicates the type is an enumeration 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyconObjModelKind.TTyconDelegate">
<summary>
 Indicates the type is a delegate with the given Invoke signature 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyconObjModelKind.TTyconStruct">
<summary>
 Indicates the type is a struct 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyconObjModelKind.TTyconInterface">
<summary>
 Indicates the type is an interface 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyconObjModelKind.TTyconClass">
<summary>
 Indicates the type is a class (also used for units-of-measure)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TProvidedTypeInfo.IsSuppressRelocate">
<summary>
 Indicates the type is generated, but type-relocation is suppressed
</summary>
</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TProvidedTypeInfo.IsDelegate">
<summary>
 A flag read from the provided type and used to compute basic properties of the type definition.
 Reading is delayed, since it looks at the .BaseType
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TProvidedTypeInfo.UnderlyingTypeOfEnum">
<summary>
 A type read from the provided type and used to compute basic properties of the type definition.
 Reading is delayed, since it does an import on the underlying type
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TProvidedTypeInfo.IsEnum">
<summary>
 A flag read eagerly from the provided type and used to compute basic properties of the type definition.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TProvidedTypeInfo.IsStructOrEnum">
<summary>
 A flag read eagerly from the provided type and used to compute basic properties of the type definition.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TProvidedTypeInfo.IsInterface">
<summary>
 A flag read eagerly from the provided type and used to compute basic properties of the type definition.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TProvidedTypeInfo.IsSealed">
<summary>
 A flag read eagerly from the provided type and used to compute basic properties of the type definition.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TProvidedTypeInfo.IsClass">
<summary>
 A flag read eagerly from the provided type and used to compute basic properties of the type definition.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TProvidedTypeInfo.LazyBaseType">
<summary>
 The base type of the type. We use it to compute the compiled representation of the type for erased types.
 Reading is delayed, since it does an import on the underlying type
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TProvidedTypeInfo.ProvidedType">
<summary>
 The underlying System.Type (wrapped as a ProvidedType to make sure we don&apos;t call random things on
 System.Type, and wrapped as Tainted to make sure we track which provider this came from, for reporting
 error messages)
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TProvidedTypeInfo.ResolutionEnvironment">
<summary>
 The parameters given to the provider that provided to this type.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TProvidedTypeInfo">
<summary>
 The information kept about a provided type
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyconRepresentation.TNoRepr">
<summary>
 The &apos;NoRepr&apos; value here has four meanings: 
     (1) it indicates &apos;not yet known&apos; during the first 2 phases of establishing type definitions
     (2) it indicates &apos;no representation&apos;, i.e. &apos;type X&apos; in signatures
     (3) it is the setting used for exception definitions (!)
     (4) it is the setting used for modules and namespaces.
 
 It would be better to separate the &quot;not yet known&quot; and other cases out.
 The information for exception definitions should be folded into here.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyconRepresentation.TProvidedNamespaceExtensionPoint">
<summary>
 Indicates the representation information for a provided namespace.  
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyconRepresentation.TProvidedTypeExtensionPoint">
<summary>
 TProvidedTypeExtensionPoint

 Indicates the representation information for a provided type. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyconRepresentation.TMeasureableRepr">
<summary>
 Indicates the type is parameterized on a measure (e.g. float&lt;_&gt;) but erases to some other type (e.g. float)
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyconRepresentation.TAsmRepr">
<summary>
 Indicates the type is implemented as IL assembly code using the given closed Abstract IL type 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyconRepresentation.TILObjModelRepr">
<summary>
 TILObjModelRepr(scope, nesting, definition)

 Indicates the type is a type from a .NET assembly without F# metadata.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyconRepresentation.TFiniteUnionRepr">
<summary>
 Indicates the type is a discriminated union 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyconRepresentation.TRecdRepr">
<summary>
 Indicates the type is a record 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyconRepresentation.TFsObjModelRepr">
<summary>
 Indicates the type is a class, struct, enum, delegate or interface 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyconRepresentation">
<summary>
 The information for the contents of a type. Also used for a provided namespace.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyconAugmentation.tcaug_abstract">
<summary>
 Set to true if the type is determined to be abstract 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyconAugmentation.tcaug_closed">
<summary>
 Set to true at the end of the scope where proper augmentations are allowed 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyconAugmentation.tcaug_super">
<summary>
 Super type, if any 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyconAugmentation.tcaug_interfaces">
<summary>
 Interface implementations - boolean indicates compiler-generated 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyconAugmentation.tcaug_adhoc">
<summary>
 Properties, methods etc. as lookup table
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyconAugmentation.tcaug_adhoc_list">
<summary>
 Properties, methods etc. in declaration order. The boolean flag for each indicates if the
 member is known to be an explicit interface implementation. This must be computed and
 saved prior to remapping assembly information.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyconAugmentation.tcaug_hasObjectGetHashCode">
<summary>
 True if the type defined an Object.GetHashCode method. In this 
 case we give a warning if we auto-generate a hash method since the semantics may not match up
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyconAugmentation.tcaug_hash_and_equals_withc">
<summary>
 This is the value implementing the auto-generated comparison
 semantics if any. It is not present if the type defines its own implementation
 of IStructuralEquatable or if the type doesn&apos;t implement IComparable implicitly.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyconAugmentation.tcaug_equals">
<summary>
 This is the value implementing the auto-generated equality 
 semantics if any. It is not present if the type defines its own implementation 
 of Object.Equals or if the type doesn&apos;t override Object.Equals implicitly. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyconAugmentation.tcaug_compare_withc">
<summary>
 This is the value implementing the auto-generated comparison
 semantics if any. It is not present if the type defines its own implementation
 of IStructuralComparable or if the type doesn&apos;t implement IComparable implicitly.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.TyconAugmentation.tcaug_compare">
<summary>
 This is the value implementing the auto-generated comparison 
 semantics if any. It is not present if the type defines its own implementation 
 of IComparable or if the type doesn&apos;t implement IComparable implicitly. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.EntityData.entity_il_repr_cache">
<summary>
 Used during codegen to hold the ILX representation indicating how to access the type 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.EntityData.entity_cpath">
<summary>
 The stable path to the type, e.g. Microsoft.FSharp.Core.FSharpFunc`2 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.EntityData.entity_accessiblity">
<summary>
 Indicates how visible is the entitiy is.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.EntityData.entity_pubpath">
<summary>
 The stable path to the type, e.g. Microsoft.FSharp.Core.FSharpFunc`2 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.EntityData.entity_xmldocsig">
<summary>
 The XML document signature for this entity
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.EntityData.entity_xmldoc">
<summary>
 The declared documentation for the type or module 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.EntityData.entity_modul_contents">
<summary>
 This field is used when the &apos;tycon&apos; is really a module definition. It holds statically nested type definitions and nested modules 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.EntityData.entity_exn_info">
<summary>
 Field used when the &apos;tycon&apos; is really an exception definition
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.EntityData.entity_tycon_tcaug">
<summary>
 The methods and properties of the type 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.EntityData.entity_tycon_abbrev">
<summary>
 If non-None, indicates the type is an abbreviation for another type. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.EntityData.entity_tycon_repr">
<summary>
 The declared representation of the type, i.e. record, union, class etc. 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.EntityData.entity_attribs">
<summary>
 The declared attributes for the type 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.EntityData.entity_tycon_repr_accessibility">
<summary>
 The declared accessibility of the representation, not taking signatures into account 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.EntityData.entity_range">
<summary>
 The declaration location for the type constructor 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.EntityData.entity_compiled_name">
<summary>
 The name of the type, possibly with `n mangling 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.EntityData.entity_logical_name">
<summary>
 The name of the type, possibly with `n mangling 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.EntityData.entity_stamp">
<summary>
 The unique stamp of the &quot;tycon blob&quot;. Note the same tycon in signature and implementation get different stamps 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:Microsoft.FSharp.Compiler.Tast.EntityData.entity_typars">
<summary>
 The declared type parameters of the type  
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.XmlDocSig(System.String)">
<summary>
 The XML documentation sig-string of the entity, if any, to use to lookup an .xml doc file. This also acts
 as a cache for this sig-string computation.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.XmlDocSig">
<summary>
 The XML documentation sig-string of the entity, if any, to use to lookup an .xml doc file. This also acts
 as a cache for this sig-string computation.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.XmlDoc">
<summary>
 The XML documentation of the entity, if any. If the entity is backed by provided metadata
 then this _does_ include this documentation. If the entity is backed by Abstract IL metadata
 or comes from another F# assembly then it does not (because the documentation will get read from 
 an XML file).
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.UnionTypeInfo">
<summary>
 Get the union cases and other union-type information for a type, if any
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.UnionCasesAsList">
<summary>
 Get the union cases for a type, if any, as a list
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.UnionCasesArray">
<summary>
 Get the union cases for a type, if any
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.TypeReprInfo">
<summary>
 The information about the r.h.s. of a type definition, if any. For example, the r.h.s. of a union or record type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.TypeReprAccessibility">
<summary>
 Get the value representing the accessiblity of the r.h.s. of an F# type definition.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.TypeOrMeasureKind">
<summary>
 The kind of the type definition - is it a measure definition or a type definition?
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.TypeContents">
<summary>
 The logical contents of the entity when it is a type definition.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.TypeAbbrev">
<summary>
 Get the type abbreviated by this type definition, if it is an F# type abbreviation definition
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.TyparsNoRange">
<summary>
 Get the type parameters for an entity that is a type declaration, otherwise return the empty list.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.TrueInstanceFieldsAsList">
<summary>
 Get a list of all instance fields for F#-defined record, struct and class fields in this type definition,
 excluding compiler-generate fields.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.TrueFieldsAsList">
<summary>
 Get a list of all fields for F#-defined record, struct and class fields in this type definition,
 including static fields, but excluding compiler-generate fields.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.Stamp">
<summary>
 A unique stamp for this module, namespace or type definition within the context of this compilation. 
 Note that because of signatures, there are situations where in a single compilation the &quot;same&quot; 
 module, namespace or type may have two distinct Entity objects that have distinct stamps.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.Range">
<summary>
 The code location where the module, namespace or type is defined.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.PublicPath">
<summary>
 Get a blob of data indicating how this type is nested in other namespaces, modules or types.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.PreEstablishedHasDefaultConstructor">
<summary>
 Indicates if we have pre-determined that a type definition has a default constructor.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.ModuleOrNamespaceType">
<summary>
 The logical contents of the entity when it is a module or namespace fragment.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.MembersOfFSharpTyconSorted">
<summary>
 Gets the immediate members of an F# type definition, excluding compiler-generated ones.
 Note: result is alphabetically sorted, then for each name the results are in declaration order
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.MembersOfFSharpTyconByName">
<summary>
 Gets all immediate members of an F# type definition keyed by name, including compiler-generated ones.
 Note: result is a indexed table, and for each name the results are in reverse declaration order
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.LogicalName">
<summary>
 The name of the namespace, module or type, possibly with mangling, e.g. List`1, List or FailureException 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsUnionTycon">
<summary>
 Indicate if this is a type whose r.h.s. is known to be a union type definition.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsTypeAbbrev">
<summary>
 Indicates if this entity is an F# type abbreviation definition
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsStructOrEnumTycon">
<summary>
 Indicates if this is a struct or enum type definition , i.e. a value type definition
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsRecordTycon">
<summary>
 Indicates if this is an F# type definition whose r.h.s. is known to be a record type definition.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsProvidedNamespace">
<summary>
 Indicates if the entity is a provided namespace fragment
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsProvidedGeneratedTycon">
<summary>
 Indicates if the entity is a generated provided type definition, i.e. not erased.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsProvidedErasedTycon">
<summary>
 Indicates if the entity is an erased provided type definition
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsProvided">
<summary>
 Indicates if the entity is a provided type or namespace definition
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsPrefixDisplay">
<summary>
 Indicates the type prefers the &quot;tycon&lt;a,b&gt;&quot; syntax for display etc. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsNamespace">
<summary>
 Indicates if the entity is a namespace
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsModuleOrNamespace">
<summary>
 Indicates the &quot;tycon blob&quot; is actually a module 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsModule">
<summary>
 Indicates if the entity is an F# module definition
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsMeasureableReprTycon">
<summary>
 Indicates if this is an F# type definition which is one of the special types in FSharp.Core.dll like &apos;float&lt;_&gt;&apos; which
 defines a measure type with a relation to an existing non-measure type as a representation.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsLinked">
<summary>
 Indicates if the entity is linked to backing data. Only used during unpickling of F# metadata.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsILTycon">
<summary>
 Indicate if this is a type definition backed by Abstract IL metadata.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsILStructOrEnumTycon">
<summary>
 Indicates if this is a .NET-defined struct or enum type definition , i.e. a value type definition
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsILEnumTycon">
<summary>
 Indicates if this is a .NET-defined enum type definition 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsHiddenReprTycon">
<summary>
 Indicates if this is an F# type definition whose r.h.s. definition is unknown (i.e. a traditional ML &apos;abstract&apos; type in a signature,
 which in F# is called a &apos;unknown representation&apos; type).
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsFSharpStructOrEnumTycon">
<summary>
 Indicates if this is an F#-defined struct or enum type definition , i.e. a value type definition
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsFSharpObjectModelTycon">
<summary>
 Indicates if this is an F# type definition whose r.h.s. is known to be some kind of F# object model definition
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsFSharpInterfaceTycon">
<summary>
 Indicates if this is an F#-defined interface type definition 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsFSharpEnumTycon">
<summary>
 Indicates if this is an F#-defined enum type definition 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsFSharpDelegateTycon">
<summary>
 Indicates if this is an F#-defined delegate type definition 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsFSharpClassTycon">
<summary>
 Indicates if this is an F#-defined class type definition 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsExceptionDecl">
<summary>
 Indicates if the entity represents an F# exception declaration.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsErased">
<summary>
 Indicates if the entity is erased, either a measure definition, or an erased provided type definition
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsEnumTycon">
<summary>
 Indicates if this is an enum type definition 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.IsAsmReprTycon">
<summary>
 Indicates if this is an F# type definition which is one of the special types in FSharp.Core.dll which uses 
 an assembly-code representation for the type, e.g. the primitive array type constructor.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.ImmediateInterfacesOfFSharpTycon">
<summary>
 Gets the immediate interface definitions of an F# type definition. Further interfaces may be supported through class and interface inheritance.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.ImmediateInterfaceTypesOfFSharpTycon">
<summary>
 Gets the immediate interface types of an F# type definition. Further interfaces may be supported through class and interface inheritance.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.Id">
<summary>
 The identifier at the point of declaration of the type definition.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.ILTyconRawMetadata">
<summary>
 Get the Abstract IL metadata for this type definition, assuming it is backed by Abstract IL metadata.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.ILTyconInfo">
<summary>
 Get the Abstract IL scope, nesting and metadata for this 
 type definition, assuming it is backed by Abstract IL metadata.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.HasSelfReferentialConstructor">
<summary>
 Indicates if we have pre-determined that a type definition has a self-referential constructor using &apos;as x&apos;
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.GeneratedHashAndEqualsWithComparerValues">
<summary>
 Gets any implicit hash/equals (with comparer argument) methods added to an F# record, union or struct type definition.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.GeneratedHashAndEqualsValues">
<summary>
 Gets any implicit hash/equals methods added to an F# record, union or struct type definition.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.GeneratedCompareToWithComparerValues">
<summary>
 Gets any implicit CompareTo (with comparer argument) methods added to an F# record, union or struct type definition.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.GeneratedCompareToValues">
<summary>
 Gets any implicit CompareTo methods added to an F# record, union or struct type definition.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.FSharpObjectModelTypeInfo">
<summary>
 Get the blob of information associated with an F# object-model type definition, i.e. class, interface, struct etc.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.ExceptionInfo">
<summary>
 The information about the r.h.s. of an F# exception definition, if any. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.DisplayNameWithStaticParametersAndUnderscoreTypars">
<summary>
 The display name of the namespace, module or type with &lt;_,_,_&gt; added for generic types, plus static parameters if any
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.DisplayNameWithStaticParameters">
<summary>
 The display name of the namespace, module or type, e.g. List instead of List`1, including static parameters if any
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.DisplayName">
<summary>
 The display name of the namespace, module or type, e.g. List instead of List`1, and no static parameters
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.DemangledModuleOrNamespaceName">
<summary>
 Demangle the module name, if FSharpModuleWithSuffix is used
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.CompiledRepresentationForNamedType">
<summary>
 Gets the data indicating the compiled representation of a named type or module in terms of Abstract IL data structures.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.CompiledRepresentation">
<summary>
 Gets the data indicating the compiled representation of a type or module in terms of Abstract IL data structures.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.CompiledReprCache">
<summary>
 Get the cache of the compiled ILTypeRef representation of this module or type.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.CompiledName">
<summary>
 The compiled name of the namespace, module or type, e.g. FSharpList`1, ListModule or FailureException 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.CompilationPathOpt">
<summary>
 Get a blob of data indicating how this type is nested inside other namespaces, modules and types.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.CompilationPath">
<summary>
 Get a blob of data indicating how this type is nested inside other namespaces, modules and types.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.Attribs">
<summary>
 The F#-defined custom attributes of the entity, if any. If the entity is backed by Abstract IL or provided metadata
 then this does not include any attributes from those sources.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.AllInstanceFieldsAsList">
<summary>
 Get a list of all instance fields for F#-defined record, struct and class fields in this type definition.
 including hidden fields from the compilation of implicit class constructions.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.AllGeneratedValues">
<summary>
 Gets all implicit hash/equals/compare methods added to an F# record, union or struct type definition.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.AllFieldsAsList">
<summary>
 Get a list of fields for all the F#-defined record, struct and class fields in this type definition, including
 static fields, &apos;val&apos; declarations and hidden fields from the compilation of implicit class constructions.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.AllFieldsArray">
<summary>
 Get an array of fields for all the F#-defined record, struct and class fields in this type definition, including
 static fields, &apos;val&apos; declarations and hidden fields from the compilation of implicit class constructions.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.AllFieldTable">
<summary>
 Get a table of fields for all the F#-defined record, struct and class fields in this type definition, including
 static fields, &apos;val&apos; declarations and hidden fields from the compilation of implicit class constructions.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.Entity.Accessibility">
<summary>
 Get the value representing the accessiblity of an F# type definition or module.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Entity.Typars(Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Get the type parameters for an entity that is a type declaration, otherwise return the empty list.
 
 Lazy because it may read metadata, must provide a context &quot;range&quot; in case error occurs reading metadata.
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Entity.SetAttribs(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Attrib})">
<summary>
 Set the custom attributes on an F# type definition.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Entity.NewUnlinked">
<summary>
 Create a new entity with empty, unlinked data. Only used during unpickling of F# metadata.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Entity.New``1(``0,Microsoft.FSharp.Compiler.Tast.EntityData)">
<summary>
 Create a new entity with the given backing data. Only used during unpickling of F# metadata.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Entity.Link(Microsoft.FSharp.Compiler.Tast.EntityData)">
<summary>
 Link an entity based on empty, unlinked data to the given data. Only used during unpickling of F# metadata.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Entity.GetUnionCaseByName(System.String)">
<summary>
 Get a union case of a type by name
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Entity.GetFieldByName(System.String)">
<summary>
 Get a field by name.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Entity.GetFieldByIndex(System.Int32)">
<summary>
 Get a field by index in definition order
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.Entity.DemangleEntityName(System.String,Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceKind)">
<summary>
 String &apos;Module&apos; off an F# module name, if FSharpModuleWithSuffix is used
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.PublicPath">
<summary>
 A public path records where a construct lives within the global namespace
 of a CCU.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.CompilationPath">
<summary>
 The information ILXGEN needs about the location of an item
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceKind.Namespace">
<summary>
 Indicates that a &apos;module&apos; is really a namespace 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceKind.ModuleOrType">
<summary>
 Indicates that a module is compiled to a class with the same name as the original module 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceKind.FSharpModuleWithSuffix">
<summary>
 Indicates that a module is compiled to a class with the &quot;Module&quot; suffix added. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityFlags.ReservedBitForPickleFormatTyconReprFlag">
<summary>
 This bit is reserved for us in the pickle format, see pickle.fs, it&apos;s bing listed here to stop it ever being used for anything else
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.EntityFlags.PickledBits">
<summary>
 Get the flags as included in the F# binary metadata
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.EntityFlags">
<summary>
 Encode entity flags into a bit field. We leave lots of space to allow for future expansion.
</summary>
</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.TyparFlags.StaticReq">
<summary>
 Indicates if the type variable has a static &quot;head type&quot; requirement, i.e. ^a variables used in FSharp.Core and member constraints.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.TyparFlags.Rigidity">
<summary>
 Indicates if the type variable can be sovled or given new constraints. The status of a type variable
 generally always evolves towards being either rigid or solved. 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.TyparFlags.PickledBits">
<summary>
 Get the flags as included in the F# binary metadata. We pickle this as int64 to allow for future expansion
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.TyparFlags.Kind">
<summary>
 Indicates whether a type variable can be instantiated by types or units-of-measure.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.TyparFlags.IsFromError">
<summary>
 Indicates if the type inference variable was generated after an error when type checking expressions or patterns
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.TyparFlags.IsCompilerGenerated">
<summary>
 Indicates if the type variable is compiler generated, i.e. is an implicit type inference variable 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.TyparFlags.EqualityConditionalOn">
<summary>
 Indicates that whether or not a generic type definition satisfies the equality constraint is dependent on whether this type variable satisfies the equality constraint.
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.TyparFlags.DynamicReq">
<summary>
 Indicates if a type parameter is needed at runtime and may not be eliminated
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.TyparFlags.ComparisonConditionalOn">
<summary>
 Indicates that whether or not a generic type definition satisfies the comparison constraint is dependent on whether this type variable satisfies the comparison constraint.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparFlags">
<summary>
 Encode typar flags into a bit field  
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparRigidity.Anon">
<summary>
 Indicates the type parameter derives from an &apos;_&apos; anonymous type
 For units-of-measure, we give a warning if this gets solved to &apos;1&apos;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparRigidity.Flexible">
<summary>
 Indicates the type parameter is an inference variable may be solved
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparRigidity.WarnIfNotRigid">
<summary>
 Indicates we give a warning if the type parameter is ever solved
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparRigidity.WillBeRigid">
<summary>
 Indicates the type parameter can&apos;t be solved, but the variable is not set to &quot;rigid&quot; until after inference is complete
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparRigidity.Rigid">
<summary>
 Indicates the type parameter can&apos;t be solved
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparRigidity">
<summary>
 Indicates if the type variable can be sovled or given new constraints. The status of a type variable
 evolves towards being either rigid or solved. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.ValFlags.PickledBits">
<summary>
 Get the flags as included in the F# binary metadata
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValBaseOrThisInfo.MemberThisVal">
<summary>
 Indicates the &apos;this&apos; value specified in a memberm e.g. &apos;x&apos; in &apos;member x.M() = 1&apos;
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValBaseOrThisInfo.NormalVal">
<summary>
 Indicates a normal value
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValBaseOrThisInfo.BaseVal">
<summary>
 Indicates the value called &apos;base&apos; available for calling base class members
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValBaseOrThisInfo.CtorThisVal">
<summary>
 Indicates a ref-cell holding &apos;this&apos; or the implicit &apos;this&apos; used throughout an 
 implicit constructor to access and set values
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparDynamicReq.Yes">
<summary>
 Indicates the type parameter is needed at runtime and may not be eliminated
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparDynamicReq.No">
<summary>
 Indicates the type parameter is not needed at runtime and may be eliminated
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.TyparDynamicReq">
<summary>
 Indicates if a type parameter is needed at runtime and may not be eliminated
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValRecursiveScopeInfo.ValNotInRecScope">
<summary>
 The normal value for this flag when the value is not within its recursive scope 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValRecursiveScopeInfo.ValInRecScope">
<summary>
 Set while the value is within its recursive scope. The flag indicates if the value has been eagerly generalized and accepts generic-recursive calls 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValRecursiveScopeInfo">
<summary>
 A flag associated with values that indicates whether the recursive scope of the value is currently being processed, and 
 if the value has been generalized or not as yet.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValInline.Never">
<summary>
 Indicates the value must never be inlined by the optimizer
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValInline.Optional">
<summary>
 Indicates the value may optionally be inlined by the optimizer
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValInline.Always">
<summary>
 Indicates the value is inlined but the .NET IL code for the function still exists, e.g. to satisfy interfaces on objects, but that it is also always inlined 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValInline.PseudoVal">
<summary>
 Indicates the value must always be inlined and no .NET IL code is generated for the value/function
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.Unique">
<summary>
 Unique name generator for stamps attached to lambdas and object expressions
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.combineModuleOrNamespaceTypes(Microsoft.FSharp.Collections.FSharpList{System.String},Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType,Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType)">
<summary>
 Combine module types when multiple namespace fragments contribute to the
 same namespace, making new module specs as we go.
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.combineMaps``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{``0},``1},Microsoft.FSharp.Collections.FSharpMap{``2,``0},Microsoft.FSharp.Collections.FSharpMap{``2,``0})">
<summary>
 Combine two maps where the given function reconciles entries that have the same key
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.NewModifiedVal(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Tast.ValData,Microsoft.FSharp.Compiler.Tast.ValData},Microsoft.FSharp.Compiler.Tast.Val)">
<summary>
 Create a Val based on an existing one using the function &apos;f&apos;. 
 We require that we be given the parent for the new Val. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.NewModifiedModuleOrNamespace(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType,Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType},Microsoft.FSharp.Compiler.Tast.Entity)">
<summary>
 Create a module Tycon based on an existing one using the function &apos;f&apos;. 
 We require that we be given the parent for the new module. 
 We pass the new module to &apos;f&apos; in case it needs to reparent the 
 contents of the module. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.NewModifiedTycon(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Tast.EntityData,Microsoft.FSharp.Compiler.Tast.EntityData},Microsoft.FSharp.Compiler.Tast.Entity)">
<summary>
 Create a tycon based on an existing one using the function &apos;f&apos;. 
 We require that we be given the new parent for the new tycon. 
 We pass the new tycon to &apos;f&apos; in case it needs to reparent the 
 contents of the tycon. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.accessSubstPaths(Microsoft.FSharp.Compiler.Tast.CompilationPath,Microsoft.FSharp.Compiler.Tast.CompilationPath,Microsoft.FSharp.Compiler.Tast.Accessibility)">
<summary>
 Given (newPath,oldPath) replace oldPath by newPath in the TAccess.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.primValRefEq(System.Boolean,Microsoft.FSharp.Compiler.Tast.CcuThunk,Microsoft.FSharp.Compiler.Tast.ValRef,Microsoft.FSharp.Compiler.Tast.ValRef)">
<summary>
 Primitive routine to compare two ValRef&apos;s for equality.  On the whol value identity is not particularly
 significant in F#. However it is significant for
    (a) Active Patterns 
    (b) detecting uses of &quot;special known values&quot; from FSharp.Core.dll, such as &apos;seq&apos; 
        and quotation splicing 

 Note this routine doesn&apos;t take type forwarding into account
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.primUnionCaseRefEq(System.Boolean,Microsoft.FSharp.Compiler.Tast.CcuThunk,Microsoft.FSharp.Compiler.Tast.UnionCaseRef,Microsoft.FSharp.Compiler.Tast.UnionCaseRef)">
<summary>
 Primitive routine to compare two UnionCaseRef&apos;s for equality
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.primEntityRefEq(System.Boolean,Microsoft.FSharp.Compiler.Tast.CcuThunk,Microsoft.FSharp.Compiler.Tast.EntityRef,Microsoft.FSharp.Compiler.Tast.EntityRef)">
<summary>
 Primitive routine to compare two EntityRef&apos;s for equality
 This takes into account the possibility that they may have type forwarders
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.nonLocalRefDefinitelyNotEq(Microsoft.FSharp.Compiler.Tast.NonLocalEntityRef,Microsoft.FSharp.Compiler.Tast.NonLocalEntityRef)">
<summary>
 This predicate tests if non-local resolution paths are definitely known to resolve
 to different entities. All references with different named paths always resolve to 
 different entities. Two references with the same named paths may resolve to the same 
 entities even if they reference through different CCUs, because one reference
 may be forwarded to another via a .NET TypeForwarder.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.rescopePubPath(Microsoft.FSharp.Compiler.Tast.CcuThunk,Microsoft.FSharp.Compiler.Tast.PublicPath)">
<summary>
 From Ref_private to Ref_nonlocal when exporting data.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.rescopePubPathToParent(Microsoft.FSharp.Compiler.Tast.CcuThunk,Microsoft.FSharp.Compiler.Tast.PublicPath)">
<summary>
 From Ref_private to Ref_nonlocal when exporting data.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.mkModuleUnionCaseRef(Microsoft.FSharp.Compiler.Tast.EntityRef,Microsoft.FSharp.Compiler.Tast.Entity,Microsoft.FSharp.Compiler.Tast.UnionCase)">
<summary>
 Make a reference to a union case for type in a module or namespace
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.|ValDeref|(Microsoft.FSharp.Compiler.Tast.ValRef)">
<summary>
 For derefencing in the middle of a pattern
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.ccuEq(Microsoft.FSharp.Compiler.Tast.CcuThunk,Microsoft.FSharp.Compiler.Tast.CcuThunk)">
<summary>
 Equality on CCU references, implemented as reference equality except when unresolved
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.valEq(Microsoft.FSharp.Compiler.Tast.Val,Microsoft.FSharp.Compiler.Tast.Val)">
<summary>
 Equality on value specs, implemented as reference equality
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.typarRefEq(Microsoft.FSharp.Compiler.Tast.Typar,Microsoft.FSharp.Compiler.Tast.Typar)">
<summary>
 Equality on type varialbes, implemented as reference equality. This should be equivalent to using typarEq.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.KeyTyconByAccessNames``1(System.String,``0)">
<summary>
 Generic types can be accessed either by &apos;List&apos; or &apos;List`1&apos;. This lists both keys. The second form should really be deprecated.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tast.mustinline(Microsoft.FSharp.Compiler.Tast.ValInline)">
<summary>
 Returns true if the implementation of a value must always be inlined
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.globalStableNameGenerator">
<summary>
 A global generator of stable compiler generated names
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.globalNng">
<summary>
 A global generator of compiler generated names
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Tast.newStamp">
<summary>
 Unique name generator for stamps attached to to val_specs, tycon_specs etc.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tast.ValReprInfoModule">
<summary>
 Metadata on values (names of arguments etc. 
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Tast">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tastops.TyconRefMultiMap`1">
<summary>
 Maps TyconRef to list of T based on stamp keys
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tastops.TyconRefMap`1">
<summary>
 Maps TyconRef to T based on stamp keys
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tastops.TyparMap`1">
<summary>
 Maps Typar to T based on stamp keys
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tastops.ValMultiMap`1">
<summary>
 Maps Val&apos;s to list of T based on stamp keys
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tastops.ValHash`1">
<summary>
 Mutable data structure mapping Val&apos;s to T based on stamp keys
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tastops.ValMap`1">
<summary>
 Maps Val to T, based on stamps
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tastops.TypeScheme">
<summary>
 TypeSchme (generalizedTypars, tauTy)

    generalizedTypars -- the truly generalized type parameters 
    tauTy  --  the body of the generalized type. A &apos;tau&apos; type is one with its type paramaeters stripped off.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.|SpecialComparableHeadType|_|(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Determines types that are potentially known to satisfy the &apos;comparable&apos; constraint and returns
 a set of residual types that must also satisfy the constraint
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.TryDecodeTypeProviderAssemblyAttr(Microsoft.FSharp.Compiler.AbstractIL.IL.ILGlobals,Microsoft.FSharp.Compiler.AbstractIL.IL.ILAttribute)">
<summary>
 returns Some(assemblyName) for success
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.StripSelfRefCell(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Tast.ValBaseOrThisInfo,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 For &quot;type Class as self&quot;, &apos;self&apos; is fixed up after initialization. To support this,
 it is converted behind the scenes to a ref. This function strips off the ref and
 returns the underlying type.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.rankOfArrayTy(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Get the rank of an array type
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.destArrayTy(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Get the element type of an array type
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.mkValAddr(Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.ValRef)">
<summary>
 &amp;localv           
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.mkAddrGet(Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.ValRef)">
<summary>
 *localv_ptr        
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.mkAddrSet(Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.ValRef,Microsoft.FSharp.Compiler.Tast.Expr)">
<summary>
  *localv_ptr = e   
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.mkValSet(Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.ValRef,Microsoft.FSharp.Compiler.Tast.Expr)">
<summary>
   localv &lt;- e      
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.IsHiddenTycon(Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Compiler.Tastops.Remap,Microsoft.FSharp.Compiler.Tastops.SignatureHidingInfo}},Microsoft.FSharp.Compiler.Tast.Entity)">
<summary>
 Query SignatureRepackageInfo
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.freeInBindingRhs(Microsoft.FSharp.Compiler.Tastops.FreeVarOptions,Microsoft.FSharp.Compiler.Tast.Binding)">
<summary>
 Get the free variables in the right hand side of a binding.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.freeInExpr(Microsoft.FSharp.Compiler.Tastops.FreeVarOptions,Microsoft.FSharp.Compiler.Tast.Expr)">
<summary>
 Get the free variables in an expression.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.freeInModuleOrNamespace(Microsoft.FSharp.Compiler.Tastops.FreeVarOptions,Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceExpr)">
<summary>
 Get the free variables in a module definition.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.qualifiedMangledNameOfTyconRef(Microsoft.FSharp.Compiler.Tast.EntityRef,System.String)">
<summary>
 A unique qualified name for each type definition, used to qualify the names of interface implementation methods
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.fullDisplayTextOfModRef(Microsoft.FSharp.Compiler.Tast.EntityRef)">
<summary>
 Return the full text for an item as we want it displayed to the user as a fully qualified entity
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.PartitionValRefTypars(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Tast.ValRef)">
<summary>
 Returns (parentTypars,memberParentTypars,memberMethodTypars,memberToParentInst,tinst)
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.PartitionValTypars(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Tast.Val)">
<summary>
 Returns (parentTypars,memberParentTypars,memberMethodTypars,memberToParentInst,tinst)
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.PartitionValTyparsForApparentEnclosingType(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Tast.Val)">
<summary>
 Returns (parentTypars,memberParentTypars,memberMethodTypars,memberToParentInst,tinst)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.tryNiceEntityRefOfTy(Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Try to get a TyconRef for a type without erasing type abbreviations
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.stripExnEqns(Microsoft.FSharp.Compiler.Tast.EntityRef)">
<summary>
 See through F# exception abbreviations
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.stripTyEqnsA(Microsoft.FSharp.Compiler.Env.TcGlobals,System.Boolean,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 set bool to &apos;true&apos; to allow shortcutting of type parameter equation chains during stripping 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.mkLocal(Microsoft.FSharp.Compiler.Range.range,System.String,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Return the local and an expression to reference it
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Tastops.exprForVal(Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.Val)">
<summary>
 Note: try to use exprForValRef or the expression returned from mkLocal instead of this. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tastops.DebugPrint">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tastops.SimplifyTypes">
<summary>
 Utilities used in simplifying types for visual presentation
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tastops.PrettyTypes">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tastops">
<summary>
 Derived expression manipulation and construction functions.
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Tlr">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.TypeChecker">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Typrelns.CalledMeth`1.UnnamedCalledOutArgs">
<summary>
 unnamed called out args: return these as part of the return tuple
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Typrelns.CalledMeth`1.UnnamedCalledOptArgs">
<summary>
 unnamed called optional args: pass defaults for these
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Typrelns.CalledMeth`1.UnassignedNamedArgs">
<summary>
 unassigned args
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Typrelns.CalledMeth`1.ReturnType">
<summary>
 return type
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Typrelns.CalledMeth`1.Method">
<summary>
 the method we&apos;re attempting to call 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Typrelns.CalledMeth`1.CallerTyArgs">
<summary>
 the formal instantiation of the method we&apos;re attempting to call 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Typrelns.CalledMeth`1.CallerObjArgTys">
<summary>
 The types of the actual object arguments, if any
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Typrelns.CalledMeth`1.CalledTyArgs">
<summary>
 the instantiation of the method we&apos;re attempting to call 
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Typrelns.CalledMeth`1.AttributeAssignedNamedArgs">
<summary>
 args assigned to specifiy values for attribute fields and properties (these are not necessarily &quot;property sets&quot;)
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Typrelns.CalledMeth`1.AssociatedPropertyInfo">
<summary>
 the property related to the method we&apos;re attempting to call, if any  
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Microsoft.FSharp.Compiler.Typrelns.CalledMeth`1.AssignedItemSetters">
<summary>
 named setters
</summary>
</member>
<member name="P:Microsoft.FSharp.Compiler.Typrelns.CalledMeth`1.ArgSets">
<summary>
 The argument analysis for each set of curried arguments
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Typrelns.CalledMeth`1">
<summary>
 Represents the syntactic matching between a caller of a method and the called method.

 The constructor takes all the information about the caller and called side of a method, match up named arguments, property setters etc., 
 and returns a CalledMeth object for further analysis.
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Typrelns.CalledMethArgSet`1.AssignedNamedArgs">
<summary>
 Named args
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Typrelns.CalledMethArgSet`1.ParamArrayCallerArgs">
<summary>
 Any unnamed caller arguments assigned to a &quot;param array&quot; argument
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Typrelns.CalledMethArgSet`1.ParamArrayCalledArgOpt">
<summary>
 The called &quot;ParamArray&quot; argument, if any
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Typrelns.CalledMethArgSet`1.UnnamedCallerArgs">
<summary>
 Any unnamed caller arguments not otherwise assigned 
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Typrelns.CalledMethArgSet`1.UnnamedCalledArgs">
<summary>
 The called arguments corresponding to &quot;unnamed&quot; arguments
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Typrelns.AssignedItemSetter`1">
<summary>
 Represents the resolution of a caller argument as a named-setter argument
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Typrelns.AssignedItemSetterTarget">
<summary>
 Represents the possibilities for a named-setter argument (a property, field , or a record field setter)
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Typrelns.AssignedCalledArg`1.CallerArg">
<summary>
 The argument on the caller side
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Typrelns.AssignedCalledArg`1.CalledArg">
<summary>
 The called argument in the method
</summary>
</member>
<member name="F:Microsoft.FSharp.Compiler.Typrelns.AssignedCalledArg`1.NamedArgIdOpt">
<summary>
 The identifier for a named argument, if any
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Typrelns.AssignedCalledArg`1">
<summary>
 Represents a match between a caller argument and a called argument, arising from either
 a named argument or an unnamed argument.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Typrelns.CalledArg">
<summary>
 Represents the information about an argument in the method being called
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Typrelns.CallerArg`1.CallerArg">
<summary>
 CallerArg(ty, range, isOpt, exprInfo)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Typrelns.CallerArg`1">
<summary>
 In the following, &apos;T gets instantiated to: 
   1. the expression being supplied for an argument 
   2. &quot;unit&quot;, when simply checking for the existence of an overload that satisfies 
      a signature, or when finding the corresponding witness. 
 Note the parametricity helps ensure that overload resolution doesn&apos;t depend on the 
 expression on the callside (though it is in some circumstances allowed 
 to depend on some type information inferred syntactically from that 
 expression, e.g. a lambda expression may be converted to a delegate as 
 an adhoc conversion. 

 The bool indicates if named using a &apos;?&apos; 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Typrelns.OverrideInfo">
<summary>
 The overall information about a method implementation in a class or object expression 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.BuildNewDelegateExpr(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Compiler.Infos.EventInfo},Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Compiler.Infos.MethInfo,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType},Microsoft.FSharp.Compiler.Tast.Expr,Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Compiler.Range.range)">
<summary>
 Implements the elaborated form of adhoc conversions from functions to delegates at member callsites
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.BuildMethodCall(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Tast.ValRef,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Tast.ValUseFlag,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Compiler.Range.range,System.Tuple{Microsoft.FSharp.Compiler.Tast.Expr,Microsoft.FSharp.Compiler.Tast.TType}}}}},Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Tastops.Mutates,Microsoft.FSharp.Compiler.Range.range,System.Boolean,Microsoft.FSharp.Compiler.Infos.MethInfo,Microsoft.FSharp.Compiler.Tast.ValUseFlag,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.TType},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Expr},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Expr})">
<summary>
 Build an expression that calls a given method info. 
 This is called after overload resolution, and also to call other 
 methods such as &apos;setters&apos; for properties. 
</summary>
</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.TakeObjAddrForMethodCall``1(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Infos.MethInfo,Microsoft.FSharp.Compiler.Tastops.Mutates,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Expr},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Compiler.Tast.TType},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Expr},System.Tuple{Microsoft.FSharp.Compiler.Tast.Expr,``0}}})">
<summary>
 Adjust the &apos;this&apos; pointer before making a call 
 Take the address of a struct, and coerce to an interface/base/constraint type if necessary 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.ComputeConstrainedCallInfo(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Expr},Microsoft.FSharp.Compiler.Infos.MethInfo)">
<summary>
 Compute whether we insert a &apos;coerce&apos; on the &apos;this&apos; pointer for an object model call 
 For example, when calling an interface method on a struct, or a method on a constrained 
 variable type. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.IsBaseCall(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Expr})">
<summary>
 Is this a &apos;base&apos; call (in the sense of C#) 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.GetAbstractPropInfosForSynPropertyDecl``2(Microsoft.FSharp.Compiler.Infos.InfoReader,Microsoft.FSharp.Compiler.Infos.AccessorDomain,Microsoft.FSharp.Compiler.Ast.Ident,Microsoft.FSharp.Compiler.Range.range,System.Tuple{Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Compiler.Typrelns.SlotImplSet}},``0,``1)">
<summary>
 Get the proeprties relevant to deterimining if a uniquely-identified-override exists based on the syntactic information 
 at the member signature prior to type inference. This is used to pre-assign type information if it does 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.GetAbstractMethInfosForSynMethodDecl(Microsoft.FSharp.Compiler.Infos.InfoReader,Microsoft.FSharp.Compiler.Infos.AccessorDomain,Microsoft.FSharp.Compiler.Ast.Ident,Microsoft.FSharp.Compiler.Range.range,System.Tuple{Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Compiler.Typrelns.SlotImplSet}},Microsoft.FSharp.Compiler.Ast.SynValInfo)">
<summary>
 Get the methods relevant to deterimining if a uniquely-identified-override exists based on the syntactic information 
 at the member signature prior to type inference. This is used to pre-assign type information if it does 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.FindUniqueFeasibleSupertype(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 &quot;Single Feasible Type&quot; inference
 Look for the unique supertype of ty2 for which ty2 :&gt; ty1 might feasibly hold
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.FinalTypeDefinitionChecksAtEndOfInferenceScope(Microsoft.FSharp.Compiler.Infos.InfoReader,System.Boolean,Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Tast.Entity)">
<summary>
 &quot;Type Completion&quot; inference and a few other checks at the end of the inference scope
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.IteratedAdjustArityOfLambda(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Tast.ValReprInfo,Microsoft.FSharp.Compiler.Tast.Expr)">
<summary>
 Do AdjustArityOfLambdaBody for a series of  
 iterated lambdas, producing one method.  
 The required iterated function arity (List.length topValInfo) must be identical 
 to the iterated function arity of the input lambda (List.length vsl) 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.tryDestTopLambda(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Tast.ValReprInfo,Microsoft.FSharp.Compiler.Tast.Expr,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 Break apart lambdas. Needs ChooseTyparSolutionsForFreeChoiceTypars because it&apos;s used in
 PostTypecheckSemanticChecks before we&apos;ve eliminated these nodes.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.ChooseTyparSolutionAndRange(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Tast.Typar)">
<summary>
 Choose solutions for Expr.TyChoose type &quot;hidden&quot; variables introduced
 by letrec nodes. Also used by the pattern match compiler to choose type
 variables when compiling patterns at generalized bindings.
     e.g. let ([],x) = ([],[])
 Here x gets a generalized type &quot;list&lt;&apos;T&gt;&quot;.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.TypeFeasiblySubsumesType(System.Int32,Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Compiler.Typrelns.CanCoerce,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 The feasible coercion relation. Part of the language spec.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.TypesFeasiblyEquiv``1(System.Int32,Microsoft.FSharp.Compiler.Env.TcGlobals,``0,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Compiler.Tast.TType)">
<summary>
 The feasible equivalence relation. Part of the language spec.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.ProvidedMethodCalls.eraseSystemType(Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tainted{Microsoft.FSharp.Compiler.ExtensionTyping.ProvidedType})">
<summary>
 Erasure over System.Type.

 This is a reimplementation of the logic of provided-type erasure, working entirely over (tainted, provided) System.Type
 values. This is used when preparing ParameterInfo objects to give to the provider in GetInvokerExpression. 
 These ParameterInfo have erased ParameterType - giving the provider an erased type makes it considerably easier 
 to implement a correct GetInvokerExpression.

 Ideally we would implement this operation by converting to an F# TType using ImportSystemType, and then erasing, and then converting
 back to System.Type. However, there is currently no way to get from an arbitrary F# TType (even the TType for 
 System.Object) to a System.Type to give to the type provider.
</summary>
</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.Typrelns.ProvidedMethodCalls">

</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.DispatchSlotChecking.CheckImplementationRelationAtEndOfInferenceScope(Microsoft.FSharp.Compiler.Infos.InfoReader,Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Tast.Entity,System.Boolean)">
<summary>
 Check that a type definition implements all its required interfaces after processing all declarations 
 within a file.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.DispatchSlotChecking.GetSlotImplSets(Microsoft.FSharp.Compiler.Infos.InfoReader,Microsoft.FSharp.Compiler.Tastops.DisplayEnv,System.Boolean,Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Compiler.Range.range}})">
<summary>
 Get the slots of a type that can or must be implemented. This depends
 partly on the full set of interface types that are being implemented
 simultaneously, e.g.
    { new C with  interface I2 = ... interface I3 = ... }
 allReqdTys = {C;I2;I3}

 allReqdTys can include one class/record/union type. 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.DispatchSlotChecking.CheckOverridesAreAllUsedOnce(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,System.Boolean,Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Collections.FSharpMap{System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Typrelns.RequiredSlot}},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Typrelns.OverrideInfo},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Typrelns.OverrideInfo})">
<summary>
 Check all implementations implement some dispatch slot.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.DispatchSlotChecking.CheckDispatchSlotsAreImplemented(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,System.Boolean,Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Typrelns.RequiredSlot},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Typrelns.OverrideInfo},Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Typrelns.OverrideInfo})">
<summary>
 Check all dispatch slots are implemented by some override.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.DispatchSlotChecking.DispatchSlotIsAlreadyImplemented(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Collections.FSharpMap{System.String,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Typrelns.OverrideInfo}},Microsoft.FSharp.Compiler.Infos.MethInfo)">
<summary>
 Check if a dispatch slot is already implemented
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.DispatchSlotChecking.OverrideImplementsDispatchSlot(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.MethInfo,Microsoft.FSharp.Compiler.Typrelns.OverrideInfo)">
<summary>
 Check if an override implements a dispatch slot 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.DispatchSlotChecking.IsExactMatch(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.MethInfo,Microsoft.FSharp.Compiler.Typrelns.OverrideInfo)">
<summary>
 Check if an override exactly matches the requirements for a dispatch slot 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.DispatchSlotChecking.ComposeTyparInsts``1(Microsoft.FSharp.Collections.FSharpList{System.Tuple{``0,Microsoft.FSharp.Compiler.Tast.TType}},Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Compiler.Tast.Typar,Microsoft.FSharp.Compiler.Tast.TType}})">
<summary>
 Compose two instantiations of type parameters.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.DispatchSlotChecking.ReverseTyparRenaming(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Compiler.Tast.Typar,Microsoft.FSharp.Compiler.Tast.TType}})">
<summary>
 Compute the reverse of a type parameter renaming.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.DispatchSlotChecking.IsPartialMatch(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.MethInfo,Microsoft.FSharp.Compiler.Typrelns.OverrideInfo)">
<summary>
 Check if an override is a partial match for the requirements for a dispatch slot 
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.DispatchSlotChecking.IsTyparKindMatch(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Infos.MethInfo,Microsoft.FSharp.Compiler.Typrelns.OverrideInfo)">
<summary>
 Check if the kinds of type parameters match between a dispatch slot and an override.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.DispatchSlotChecking.IsImplMatch(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Infos.MethInfo,Microsoft.FSharp.Compiler.Typrelns.OverrideInfo)">
<summary>
 Check if an override matches a dispatch slot by name
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.DispatchSlotChecking.IsNameMatch(Microsoft.FSharp.Compiler.Infos.MethInfo,Microsoft.FSharp.Compiler.Typrelns.OverrideInfo)">
<summary>
 Check if an override matches a dispatch slot by name
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.DispatchSlotChecking.GetObjectExprOverrideInfo(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Compiler.Ast.Ident,Microsoft.FSharp.Compiler.Ast.MemberFlags,Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Compiler.Tast.ValReprInfo,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Compiler.Tast.Attrib},Microsoft.FSharp.Compiler.Tast.Expr)">
<summary>
 Get the override information for an object expression method being used to implement dispatch slots
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.DispatchSlotChecking.GetTypeMemberOverrideInfo(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Tast.TType,Microsoft.FSharp.Compiler.Tast.ValRef)">
<summary>
 Get the override info for a value being used to implement a dispatch slot.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.DispatchSlotChecking.GetInheritedMemberOverrideInfo(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Typrelns.OverrideCanImplement,Microsoft.FSharp.Compiler.Infos.MethInfo)">
<summary>
 Get the override info for an existing (inherited) method being used to implement a dispatch slot.
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.DispatchSlotChecking.FormatMethInfoSig(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Infos.MethInfo)">
<summary>
 Format the signature of a MethInfo as a string as part of an error message
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.DispatchSlotChecking.FormatOverride(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Typrelns.OverrideInfo)">
<summary>
 Format the signature of an override as a string as part of an error message
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.DispatchSlotChecking.PrintMethInfoSigToBuffer(Microsoft.FSharp.Compiler.Env.TcGlobals,Microsoft.FSharp.Compiler.Import.ImportMap,Microsoft.FSharp.Compiler.Range.range,Microsoft.FSharp.Compiler.Tastops.DisplayEnv,System.Text.StringBuilder,Microsoft.FSharp.Compiler.Infos.MethInfo)">
<summary>
 Print the signature of a MethInfo to a buffer as part of an error message
</summary>
</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.DispatchSlotChecking.PrintOverrideToBuffer(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,System.Text.StringBuilder,Microsoft.FSharp.Compiler.Typrelns.OverrideInfo)">
<summary>
 Print the signature of an override to a buffer as part of an error message
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Typrelns.DispatchSlotChecking">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Microsoft.FSharp.Compiler.Typrelns.SignatureConformance.CheckNamesOfModuleOrNamespaceContents(Microsoft.FSharp.Compiler.Tastops.DisplayEnv,Microsoft.FSharp.Compiler.Tast.EntityRef,Microsoft.FSharp.Compiler.Tast.ModuleOrNamespaceType)">
<summary>
 Check the names add up between a signature and its implementation. We check this first.
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Typrelns.SignatureConformance">
<summary>
 Containment relation for module types
</summary>
</member>
<member name="T:Microsoft.FSharp.Compiler.Typrelns">
<summary>
 Primary relations on types and signatures, with the exception of
 constraint solving and method overload resolution.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Microsoft.FSharp.Compiler.UnicodeLexing">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Viz.Visualizable.Make(System.Object)">
<summary>
 assuming this assembly is already in the debuggee process, then Viz.Visualiable.Make(foo) in the Watch window will make a visualizer for foo
</summary>
</member>
<member name="">

</member>
<member name="T:Viz.Visualizable">
<summary>
 This type exists to have a concrete &apos;Target&apos; type for a DebuggerVisualizerAttribute.
 Ideally it would be out in its own assembly, but then the compiler would need to take a dependency on that assembly, so instead we 
 pragmatically just shove this into the compiler assembly itself.
</summary>
</member>
</members>
</doc>
